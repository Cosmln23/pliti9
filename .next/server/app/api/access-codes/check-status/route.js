"use strict";(()=>{var e={};e.id=9590,e.ids=[9590],e.modules={30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},92882:(e,t,s)=>{s.r(t),s.d(t,{headerHooks:()=>E,originalPathname:()=>h,patchFetch:()=>v,requestAsyncStorage:()=>l,routeModule:()=>_,serverHooks:()=>m,staticGenerationAsyncStorage:()=>p,staticGenerationBailout:()=>g});var a={};s.r(a),s.d(a,{GET:()=>d,POST:()=>u});var r=s(95419),n=s(69108),i=s(99678),o=s(78070),c=s(24522);async function u(e){try{let{code:t}=await e.json();if(!t)return o.Z.json({error:"Codul de acces este obligatoriu"},{status:400});let s=t.trim().toUpperCase(),a=await (0,c.Xg)(s);if(!a)return o.Z.json({exists:!1,status:"not_found",message:"Codul nu există \xeen sistem"},{status:404});let r=new Date,n=new Date(a.expires_at),i=r>n,u=n.getTime()-r.getTime(),d=Math.floor(u/36e5),_=Math.floor(u%36e5/6e4);return o.Z.json({exists:!0,code:a.code,email:a.email,status:i?"expired":a.status,created_at:a.created_at,expires_at:a.expires_at,last_used_at:a.last_used_at,usage_count:a.usage_count,expired:i,time_remaining:{total_minutes:i?0:Math.floor(u/6e4),hours:i?0:d,minutes:i?0:_,formatted:i?"EXPIRAT":`${d}h ${_}m`,percentage:i?0:Math.floor(u/288e5*100)},access_info:{type:"flexible_8h",can_reenter:!i,multiple_sessions:!i,resilient_to_interruptions:!0},payment_info:{amount:a.amount,payment_method:a.payment_method,payment_intent_id:a.payment_intent_id}})}catch(e){return console.error("Error checking access code status:",e),o.Z.json({error:"Eroare internă server",message:"Nu s-a putut verifica statusul codului"},{status:500})}}async function d(e){let{searchParams:t}=new URL(e.url),s=t.get("code");if(!s)return o.Z.json({error:"Parametrul code este obligatoriu"},{status:400});try{let e=await (0,c.Xg)(s.trim().toUpperCase());if(!e)return o.Z.json({exists:!1,message:"Codul nu există \xeen sistem"});let t=new Date,a=new Date(e.expires_at),r=t>a,n=a.getTime()-t.getTime();return o.Z.json({exists:!0,code:e.code,status:r?"expired":e.status,expired:r,expires_at:e.expires_at,usage_count:e.usage_count,time_remaining_minutes:r?0:Math.floor(n/6e4),created_at:e.created_at,last_used_at:e.last_used_at})}catch(e){return console.error("Error checking access code status:",e),o.Z.json({error:"Eroare la verificarea statusului"},{status:500})}}let _=new r.AppRouteRouteModule({definition:{kind:n.x.APP_ROUTE,page:"/api/access-codes/check-status/route",pathname:"/api/access-codes/check-status",filename:"route",bundlePath:"app/api/access-codes/check-status/route"},resolvedPagePath:"C:\\Users\\user\\Desktop\\plipli paranormal\\app\\api\\access-codes\\check-status\\route.ts",nextConfigOutput:"",userland:a}),{requestAsyncStorage:l,staticGenerationAsyncStorage:p,serverHooks:m,headerHooks:E,staticGenerationBailout:g}=_,h="/api/access-codes/check-status/route";function v(){return(0,i.patchFetch)({serverHooks:m,staticGenerationAsyncStorage:p})}},24522:(e,t,s)=>{s.d(t,{TC:()=>_,OF:()=>r,VT:()=>c,Xg:()=>n,en:()=>i,RG:()=>o,yj:()=>d,B6:()=>l,xL:()=>u});let a=new(require("pg")).Pool({connectionString:"postgresql://localhost:5432/plipli9_local"});async function r(e){return(await a.query(`INSERT INTO access_codes (code, email, phone_number, payment_intent_id, amount, payment_method, expires_at, status, usage_count, ip_address) 
     VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *`,[e.code,e.email,e.phone_number,e.payment_intent_id,e.amount,e.payment_method,e.expires_at,e.status,e.usage_count,e.ip_address])).rows[0]}async function n(e){let t=await a.query("SELECT * FROM access_codes WHERE code = $1 LIMIT 1",[e]);return t.rows.length>0?t.rows[0]:null}async function i(){return(await a.query("SELECT * FROM access_codes WHERE status = $1 AND expires_at > NOW()",["active"])).rows}async function o(){let e=await a.query("SELECT * FROM live_sessions WHERE status = $1 ORDER BY started_at DESC LIMIT 1",["active"]);return e.rows.length>0?e.rows[0]:null}async function c(e){await a.query("UPDATE live_sessions SET status = $1, ended_at = NOW() WHERE session_id = $2",["ended",e])}async function u(e){try{let t=e.trim().toUpperCase(),s=await a.query(`SELECT * FROM access_codes 
       WHERE code = $1 AND status = 'active' AND expires_at > CURRENT_TIMESTAMP`,[t]);if(0===s.rows.length)return null;return s.rows[0]}catch(e){return console.error("Eroare validare cod acces:",e),null}}async function d(e,t){try{let s=`session_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;return await a.query(`UPDATE access_codes 
       SET 
         active_session_id = $1,
         active_device_info = $2,
         session_started_at = CURRENT_TIMESTAMP,
         last_activity_at = CURRENT_TIMESTAMP
       WHERE code = $3`,[s,JSON.stringify(t),e]),{success:!0,sessionId:s}}catch(e){throw console.error("Eroare pornire sesiune:",e),e}}async function _(e,t){try{let s=await a.query(`SELECT 
        active_session_id, 
        active_device_info, 
        session_started_at,
        status,
        expires_at
      FROM access_codes 
      WHERE code = $1`,[e]);if(0===s.rows.length)return{canAccess:!1,needsTakeover:!1,message:"Cod invalid sau expirat"};let r=s.rows[0];if(new Date>new Date(r.expires_at))return{canAccess:!1,needsTakeover:!1,message:"Cod expirat"};if(!r.active_session_id)return{canAccess:!0,needsTakeover:!1,message:"Cod disponibil pentru utilizare"};let n=r.active_device_info;if(n&&n.userAgent===t.userAgent&&n.ip===t.ip)return{canAccess:!0,needsTakeover:!1,message:"Sesiune existentă pe același dispozitiv"};return{canAccess:!1,needsTakeover:!0,currentDevice:{userAgent:n?.userAgent||"Unknown",ip:n?.ip||"Unknown",connectedAt:r.session_started_at,sessionId:r.active_session_id},message:"Cod \xeen folosință pe alt dispozitiv"}}catch(e){throw console.error("Eroare verificare sesiune:",e),e}}async function l(e,t){try{let s=`session_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;return await a.query(`UPDATE access_codes 
       SET 
         active_session_id = $1,
         active_device_info = $2,
         session_started_at = CURRENT_TIMESTAMP,
         last_activity_at = CURRENT_TIMESTAMP,
         status = 'in_use',
         previous_sessions = previous_sessions || $3::jsonb
       WHERE code = $4`,[s,JSON.stringify(t),JSON.stringify([{...t,takenAt:new Date().toISOString(),action:"takeover"}]),e]),{success:!0,sessionId:s}}catch(e){throw console.error("Eroare takeover sesiune:",e),e}}}};var t=require("../../../../webpack-runtime.js");t.C(e);var s=e=>t(t.s=e),a=t.X(0,[1638,6206],()=>s(92882));module.exports=a})();