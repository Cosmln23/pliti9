"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xstate";
exports.ids = ["vendor-chunks/xstate"];
exports.modules = {

/***/ "(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/xstate/actors/dist/xstate-actors.development.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyActor: () => (/* binding */ createEmptyActor),\n/* harmony export */   fromCallback: () => (/* binding */ fromCallback),\n/* harmony export */   fromEventObservable: () => (/* binding */ fromEventObservable),\n/* harmony export */   fromObservable: () => (/* binding */ fromObservable),\n/* harmony export */   fromPromise: () => (/* binding */ fromPromise),\n/* harmony export */   fromTransition: () => (/* binding */ fromTransition)\n/* harmony export */ });\n/* harmony import */ var _dist_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/raise-59549771.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-59549771.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */ /**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromTransition(transition, initialContext) {\n    return {\n        config: transition,\n        transition: (snapshot, event, actorScope)=>{\n            return {\n                ...snapshot,\n                context: transition(snapshot.context, event, actorScope)\n            };\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: typeof initialContext === \"function\" ? initialContext({\n                    input\n                }) : initialContext\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n}\nconst instanceStates = /* #__PURE__ */ new WeakMap();\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */ /**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromCallback(callback) {\n    const logic = {\n        config: callback,\n        start: (state, actorScope)=>{\n            const { self, system, emit } = actorScope;\n            const callbackState = {\n                receivers: undefined,\n                dispose: undefined\n            };\n            instanceStates.set(self, callbackState);\n            callbackState.dispose = callback({\n                input: state.input,\n                system,\n                self,\n                sendBack: (event)=>{\n                    if (self.getSnapshot().status === \"stopped\") {\n                        return;\n                    }\n                    if (self._parent) {\n                        system._relay(self, self._parent, event);\n                    }\n                },\n                receive: (listener)=>{\n                    callbackState.receivers ??= new Set();\n                    callbackState.receivers.add(listener);\n                },\n                emit\n            });\n        },\n        transition: (state, event, actorScope)=>{\n            const callbackState = instanceStates.get(actorScope.self);\n            if (event.type === _dist_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X) {\n                state = {\n                    ...state,\n                    status: \"stopped\",\n                    error: undefined\n                };\n                callbackState.dispose?.();\n                return state;\n            }\n            callbackState.receivers?.forEach((receiver)=>receiver(event));\n            return state;\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                input\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n    return logic;\n}\nconst XSTATE_OBSERVABLE_NEXT = \"xstate.observable.next\";\nconst XSTATE_OBSERVABLE_ERROR = \"xstate.observable.error\";\nconst XSTATE_OBSERVABLE_COMPLETE = \"xstate.observable.complete\";\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */ /**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */ function fromObservable(observableCreator) {\n    // TODO: add event types\n    const logic = {\n        config: observableCreator,\n        transition: (snapshot, event)=>{\n            if (snapshot.status !== \"active\") {\n                return snapshot;\n            }\n            switch(event.type){\n                case XSTATE_OBSERVABLE_NEXT:\n                    {\n                        const newSnapshot = {\n                            ...snapshot,\n                            context: event.data\n                        };\n                        return newSnapshot;\n                    }\n                case XSTATE_OBSERVABLE_ERROR:\n                    return {\n                        ...snapshot,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case XSTATE_OBSERVABLE_COMPLETE:\n                    return {\n                        ...snapshot,\n                        status: \"done\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case _dist_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    snapshot._subscription.unsubscribe();\n                    return {\n                        ...snapshot,\n                        status: \"stopped\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                default:\n                    return snapshot;\n            }\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: undefined,\n                input,\n                _subscription: undefined\n            };\n        },\n        start: (state, { self, system, emit })=>{\n            if (state.status === \"done\") {\n                // Do not restart a completed observable\n                return;\n            }\n            state._subscription = observableCreator({\n                input: state.input,\n                system,\n                self,\n                emit\n            }).subscribe({\n                next: (value)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_NEXT,\n                        data: value\n                    });\n                },\n                error: (err)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_ERROR,\n                        data: err\n                    });\n                },\n                complete: ()=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_COMPLETE\n                    });\n                }\n            });\n        },\n        getPersistedSnapshot: ({ _subscription, ...state })=>state,\n        restoreSnapshot: (state)=>({\n                ...state,\n                _subscription: undefined\n            })\n    };\n    return logic;\n}\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */ function fromEventObservable(lazyObservable) {\n    // TODO: event types\n    const logic = {\n        config: lazyObservable,\n        transition: (state, event)=>{\n            if (state.status !== \"active\") {\n                return state;\n            }\n            switch(event.type){\n                case XSTATE_OBSERVABLE_ERROR:\n                    return {\n                        ...state,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case XSTATE_OBSERVABLE_COMPLETE:\n                    return {\n                        ...state,\n                        status: \"done\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case _dist_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    state._subscription.unsubscribe();\n                    return {\n                        ...state,\n                        status: \"stopped\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                default:\n                    return state;\n            }\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: undefined,\n                input,\n                _subscription: undefined\n            };\n        },\n        start: (state, { self, system, emit })=>{\n            if (state.status === \"done\") {\n                // Do not restart a completed observable\n                return;\n            }\n            state._subscription = lazyObservable({\n                input: state.input,\n                system,\n                self,\n                emit\n            }).subscribe({\n                next: (value)=>{\n                    if (self._parent) {\n                        system._relay(self, self._parent, value);\n                    }\n                },\n                error: (err)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_ERROR,\n                        data: err\n                    });\n                },\n                complete: ()=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_COMPLETE\n                    });\n                }\n            });\n        },\n        getPersistedSnapshot: ({ _subscription, ...snapshot })=>snapshot,\n        restoreSnapshot: (snapshot)=>({\n                ...snapshot,\n                _subscription: undefined\n            })\n    };\n    return logic;\n}\nconst XSTATE_PROMISE_RESOLVE = \"xstate.promise.resolve\";\nconst XSTATE_PROMISE_REJECT = \"xstate.promise.reject\";\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */ const controllerMap = new WeakMap();\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromPromise(promiseCreator) {\n    const logic = {\n        config: promiseCreator,\n        transition: (state, event, scope)=>{\n            if (state.status !== \"active\") {\n                return state;\n            }\n            switch(event.type){\n                case XSTATE_PROMISE_RESOLVE:\n                    {\n                        const resolvedValue = event.data;\n                        return {\n                            ...state,\n                            status: \"done\",\n                            output: resolvedValue,\n                            input: undefined\n                        };\n                    }\n                case XSTATE_PROMISE_REJECT:\n                    return {\n                        ...state,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined\n                    };\n                case _dist_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    {\n                        controllerMap.get(scope.self)?.abort();\n                        return {\n                            ...state,\n                            status: \"stopped\",\n                            input: undefined\n                        };\n                    }\n                default:\n                    return state;\n            }\n        },\n        start: (state, { self, system, emit })=>{\n            // TODO: determine how to allow customizing this so that promises\n            // can be restarted if necessary\n            if (state.status !== \"active\") {\n                return;\n            }\n            const controller = new AbortController();\n            controllerMap.set(self, controller);\n            const resolvedPromise = Promise.resolve(promiseCreator({\n                input: state.input,\n                system,\n                self,\n                signal: controller.signal,\n                emit\n            }));\n            resolvedPromise.then((response)=>{\n                if (self.getSnapshot().status !== \"active\") {\n                    return;\n                }\n                controllerMap.delete(self);\n                system._relay(self, self, {\n                    type: XSTATE_PROMISE_RESOLVE,\n                    data: response\n                });\n            }, (errorData)=>{\n                if (self.getSnapshot().status !== \"active\") {\n                    return;\n                }\n                controllerMap.delete(self);\n                system._relay(self, self, {\n                    type: XSTATE_PROMISE_REJECT,\n                    data: errorData\n                });\n            });\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                input\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n    return logic;\n}\nconst emptyLogic = fromTransition((_)=>undefined, undefined);\nfunction createEmptyActor() {\n    return (0,_dist_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(emptyLogic);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtHO0FBQzVDO0FBRXREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5REMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlFQyxHQUNELFNBQVNJLGVBQWVDLFVBQVUsRUFBRUMsY0FBYztJQUNoRCxPQUFPO1FBQ0xDLFFBQVFGO1FBQ1JBLFlBQVksQ0FBQ0csVUFBVUMsT0FBT0M7WUFDNUIsT0FBTztnQkFDTCxHQUFHRixRQUFRO2dCQUNYRyxTQUFTTixXQUFXRyxTQUFTRyxPQUFPLEVBQUVGLE9BQU9DO1lBQy9DO1FBQ0Y7UUFDQUUsb0JBQW9CLENBQUNDLEdBQUdDO1lBQ3RCLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JDLFFBQVFDO2dCQUNSQyxPQUFPRDtnQkFDUE4sU0FBUyxPQUFPTCxtQkFBbUIsYUFBYUEsZUFBZTtvQkFDN0RRO2dCQUNGLEtBQUtSO1lBQ1A7UUFDRjtRQUNBYSxzQkFBc0JYLENBQUFBLFdBQVlBO1FBQ2xDWSxpQkFBaUJaLENBQUFBLFdBQVlBO0lBQy9CO0FBQ0Y7QUFFQSxNQUFNYSxpQkFBaUIsYUFBYSxHQUFFLElBQUlDO0FBRTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQ0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpRUMsR0FDRCxTQUFTQyxhQUFhQyxRQUFRO0lBQzVCLE1BQU1DLFFBQVE7UUFDWmxCLFFBQVFpQjtRQUNSRSxPQUFPLENBQUNDLE9BQU9qQjtZQUNiLE1BQU0sRUFDSmtCLElB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QjtBQUNUO0FBRUEsTUFBTXdELGFBQWE3RSxlQUFlUyxDQUFBQSxJQUFLSSxXQUFXQTtBQUNsRCxTQUFTaUU7SUFDUCxPQUFPL0UsMEVBQVdBLENBQUM4RTtBQUNyQjtBQUU0RyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsaXBsaTktcGFyYW5vcm1hbC8uL25vZGVfbW9kdWxlcy94c3RhdGUvYWN0b3JzL2Rpc3QveHN0YXRlLWFjdG9ycy5kZXZlbG9wbWVudC5lc20uanM/MmJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBYIGFzIFhTVEFURV9TVE9QLCBBIGFzIGNyZWF0ZUFjdG9yIH0gZnJvbSAnLi4vLi4vZGlzdC9yYWlzZS01OTU0OTc3MS5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi9kZXYvZGlzdC94c3RhdGUtZGV2LmRldmVsb3BtZW50LmVzbS5qcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tVHJhbnNpdGlvbmAuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge1xuICogICBmcm9tVHJhbnNpdGlvbixcbiAqICAgY3JlYXRlQWN0b3IsXG4gKiAgIHR5cGUgQW55QWN0b3JTeXN0ZW1cbiAqIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyogVGhlIGFjdG9yJ3Mgc3RvcmVkIGNvbnRleHQuXG4gKiB0eXBlIENvbnRleHQgPSB7XG4gKiAgIC8vIFRoZSBjdXJyZW50IGNvdW50LlxuICogICBjb3VudDogbnVtYmVyO1xuICogICAvLyBUaGUgYW1vdW50IHRvIGluY3JlYXNlIGBjb3VudGAgYnkuXG4gKiAgIHN0ZXA6IG51bWJlcjtcbiAqIH07XG4gKiAvLyBUaGUgZXZlbnRzIHRoZSBhY3RvciByZWNlaXZlcy5cbiAqIHR5cGUgRXZlbnQgPSB7IHR5cGU6ICdpbmNyZW1lbnQnIH07XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IHN0ZXA/OiBudW1iZXIgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IGluY3JlbWVudHMgYGNvdW50YCBieSBgc3RlcGAgd2hlbiBpdCByZWNlaXZlcyBhbiBldmVudCBvZlxuICogLy8gdHlwZSBgaW5jcmVtZW50YC5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbVRyYW5zaXRpb248Q29udGV4dCwgRXZlbnQsIEFueUFjdG9yU3lzdGVtLCBJbnB1dD4oXG4gKiAgIChzdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUpID0+IHtcbiAqICAgICBhY3RvclNjb3BlLnNlbGY7XG4gKiAgICAgLy8gICAgICAgICBePyBUcmFuc2l0aW9uQWN0b3JSZWY8Q29udGV4dCwgRXZlbnQ+XG4gKlxuICogICAgIGlmIChldmVudC50eXBlID09PSAnaW5jcmVtZW50Jykge1xuICogICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAgIGNvdW50OiBzdGF0ZS5jb3VudCArIHN0YXRlLnN0ZXBcbiAqICAgICAgIH07XG4gKiAgICAgfVxuICogICAgIHJldHVybiBzdGF0ZTtcbiAqICAgfSxcbiAqICAgKHsgaW5wdXQsIHNlbGYgfSkgPT4ge1xuICogICAgIHNlbGY7XG4gKiAgICAgLy8gXj8gVHJhbnNpdGlvbkFjdG9yUmVmPENvbnRleHQsIEV2ZW50PlxuICpcbiAqICAgICByZXR1cm4ge1xuICogICAgICAgY291bnQ6IDAsXG4gKiAgICAgICBzdGVwOiBpbnB1dC5zdGVwID8/IDFcbiAqICAgICB9O1xuICogICB9XG4gKiApO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMsIHsgaW5wdXQ6IHsgc3RlcDogMTAgfSB9KTtcbiAqIC8vICAgIF4/IFRyYW5zaXRpb25BY3RvclJlZjxDb250ZXh0LCBFdmVudD5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZyb21UcmFuc2l0aW9ufVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhY3RvciBsb2dpYyBnaXZlbiBhIHRyYW5zaXRpb24gZnVuY3Rpb24gYW5kIGl0cyBpbml0aWFsIHN0YXRlLlxuICpcbiAqIEEg4oCcdHJhbnNpdGlvbiBmdW5jdGlvbuKAnSBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGN1cnJlbnQgYHN0YXRlYCBhbmRcbiAqIHJlY2VpdmVkIGBldmVudGAgb2JqZWN0IGFzIGFyZ3VtZW50cywgYW5kIHJldHVybnMgdGhlIG5leHQgc3RhdGUsIHNpbWlsYXIgdG9cbiAqIGEgcmVkdWNlci5cbiAqXG4gKiBBY3RvcnMgY3JlYXRlZCBmcm9tIHRyYW5zaXRpb24gbG9naWMgKOKAnHRyYW5zaXRpb24gYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBSZWNlaXZlIGV2ZW50c1xuICogLSBFbWl0IHNuYXBzaG90cyBvZiBpdHMgc3RhdGVcbiAqXG4gKiBUaGUgdHJhbnNpdGlvbiBmdW5jdGlvbuKAmXMgYHN0YXRlYCBpcyB1c2VkIGFzIGl0cyB0cmFuc2l0aW9uIGFjdG9y4oCZc1xuICogYGNvbnRleHRgLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgXCJzdGF0ZVwiIGZvciBhIHRyYW5zaXRpb24gZnVuY3Rpb24gaXMgcHJvdmlkZWQgYnkgdGhlIGluaXRpYWxcbiAqIHN0YXRlIGFyZ3VtZW50LCBhbmQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBTdGF0ZSBvYmplY3Qgb2YgYW4gYWN0b3Igb3IgYVxuICogc3RhdGUgd2l0aGluIGEgbWFjaGluZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHRyYW5zaXRpb25Mb2dpYyA9IGZyb21UcmFuc2l0aW9uKFxuICogICAoc3RhdGUsIGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdpbmNyZW1lbnQnKSB7XG4gKiAgICAgICByZXR1cm4ge1xuICogICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICAgY291bnQ6IHN0YXRlLmNvdW50ICsgMVxuICogICAgICAgfTtcbiAqICAgICB9XG4gKiAgICAgcmV0dXJuIHN0YXRlO1xuICogICB9LFxuICogICB7IGNvdW50OiAwIH1cbiAqICk7XG4gKlxuICogY29uc3QgdHJhbnNpdGlvbkFjdG9yID0gY3JlYXRlQWN0b3IodHJhbnNpdGlvbkxvZ2ljKTtcbiAqIHRyYW5zaXRpb25BY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAqIH0pO1xuICogdHJhbnNpdGlvbkFjdG9yLnN0YXJ0KCk7XG4gKiAvLyA9PiB7XG4gKiAvLyAgIHN0YXR1czogJ2FjdGl2ZScsXG4gKiAvLyAgIGNvbnRleHQ6IHsgY291bnQ6IDAgfSxcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKlxuICogdHJhbnNpdGlvbkFjdG9yLnNlbmQoeyB0eXBlOiAnaW5jcmVtZW50JyB9KTtcbiAqIC8vID0+IHtcbiAqIC8vICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAqIC8vICAgY29udGV4dDogeyBjb3VudDogMSB9LFxuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIFRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uIHVzZWQgdG8gZGVzY3JpYmUgdGhlIHRyYW5zaXRpb25cbiAqICAgbG9naWMuIEl0IHNob3VsZCByZXR1cm4gdGhlIG5leHQgc3RhdGUgZ2l2ZW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGV2ZW50LlxuICogICBJdCByZWNlaXZlcyB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czpcbiAqXG4gKiAgIC0gYHN0YXRlYCAtIHRoZSBjdXJyZW50IHN0YXRlLlxuICogICAtIGBldmVudGAgLSB0aGUgcmVjZWl2ZWQgZXZlbnQuXG4gKiAgIC0gYGFjdG9yU2NvcGVgIC0gdGhlIGFjdG9yIHNjb3BlIG9iamVjdCwgd2l0aCBwcm9wZXJ0aWVzIGxpa2UgYHNlbGZgIGFuZFxuICogICAgICAgYHN5c3RlbWAuXG4gKlxuICogQHBhcmFtIGluaXRpYWxDb250ZXh0IFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uLCBlaXRoZXIgYW5cbiAqICAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3RhdGUsIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHN0YXRlIG9iamVjdC5cbiAqICAgSWYgYSBmdW5jdGlvbiwgaXQgd2lsbCByZWNlaXZlIGFzIGl0cyBvbmx5IGFyZ3VtZW50IGFuIG9iamVjdCB3aXRoIHRoZVxuICogICBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYGlucHV0YCAtIHRoZSBgaW5wdXRgIHByb3ZpZGVkIHRvIGl0cyBwYXJlbnQgdHJhbnNpdGlvbiBhY3Rvci5cbiAqICAgLSBgc2VsZmAgLSBhIHJlZmVyZW5jZSB0byBpdHMgcGFyZW50IHRyYW5zaXRpb24gYWN0b3IuXG4gKlxuICogQHJldHVybnMgQWN0b3IgbG9naWNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2lucHV0IHwgSW5wdXQgZG9jc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IGlucHV0IGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBmcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBpbml0aWFsQ29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZzogdHJhbnNpdGlvbixcbiAgICB0cmFuc2l0aW9uOiAoc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgY29udGV4dDogdHJhbnNpdGlvbihzbmFwc2hvdC5jb250ZXh0LCBldmVudCwgYWN0b3JTY29wZSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRleHQ6IHR5cGVvZiBpbml0aWFsQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxDb250ZXh0KHtcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9KSA6IGluaXRpYWxDb250ZXh0XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90LFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3RcbiAgfTtcbn1cblxuY29uc3QgaW5zdGFuY2VTdGF0ZXMgPSAvKiAjX19QVVJFX18gKi9uZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbUNhbGxiYWNrYC5cbiAqXG4gKiBUaGUgdHlwZSBvZiBgc2VsZmAgd2l0aGluIHRoZSBhY3RvcidzIGxvZ2ljLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21DYWxsYmFjaywgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIC8vIFRoZSBldmVudHMgdGhlIGFjdG9yIHJlY2VpdmVzLlxuICogdHlwZSBFdmVudCA9IHsgdHlwZTogJ3NvbWVFdmVudCcgfTtcbiAqIC8vIFRoZSBhY3RvcidzIGlucHV0LlxuICogdHlwZSBJbnB1dCA9IHsgbmFtZTogc3RyaW5nIH07XG4gKlxuICogLy8gQWN0b3IgbG9naWMgdGhhdCBsb2dzIHdoZW5ldmVyIGl0IHJlY2VpdmVzIGFuIGV2ZW50IG9mIHR5cGUgYHNvbWVFdmVudGAuXG4gKiBjb25zdCBsb2dpYyA9IGZyb21DYWxsYmFjazxFdmVudCwgSW5wdXQ+KCh7IHNlbGYsIGlucHV0LCByZWNlaXZlIH0pID0+IHtcbiAqICAgc2VsZjtcbiAqICAgLy8gXj8gQ2FsbGJhY2tBY3RvclJlZjxFdmVudCwgSW5wdXQ+XG4gKlxuICogICByZWNlaXZlKChldmVudCkgPT4ge1xuICogICAgIGlmIChldmVudC50eXBlID09PSAnc29tZUV2ZW50Jykge1xuICogICAgICAgY29uc29sZS5sb2coYCR7aW5wdXQubmFtZX06IHJlY2VpdmVkIFwic29tZUV2ZW50XCIgZXZlbnRgKTtcbiAqICAgICAgIC8vIGxvZ3MgJ215QWN0b3I6IHJlY2VpdmVkIFwic29tZUV2ZW50XCIgZXZlbnQnXG4gKiAgICAgfVxuICogICB9KTtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMsIHsgaW5wdXQ6IHsgbmFtZTogJ215QWN0b3InIH0gfSk7XG4gKiAvLyAgICBePyBDYWxsYmFja0FjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZyb21DYWxsYmFja31cbiAqL1xuXG4vKipcbiAqIEFuIGFjdG9yIGxvZ2ljIGNyZWF0b3Igd2hpY2ggcmV0dXJucyBjYWxsYmFjayBsb2dpYyBhcyBkZWZpbmVkIGJ5IGEgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBVc2VmdWwgZm9yIHN1YnNjcmlwdGlvbi1iYXNlZCBvciBvdGhlciBmcmVlLWZvcm0gbG9naWMgdGhhdCBjYW4gc2VuZCBldmVudHNcbiAqIGJhY2sgdG8gdGhlIHBhcmVudCBhY3Rvci5cbiAqXG4gKiBBY3RvcnMgY3JlYXRlZCBmcm9tIGNhbGxiYWNrIGxvZ2ljICjigJxjYWxsYmFjayBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIFJlY2VpdmUgZXZlbnRzIHZpYSB0aGUgYHJlY2VpdmVgIGZ1bmN0aW9uXG4gKiAtIFNlbmQgZXZlbnRzIHRvIHRoZSBwYXJlbnQgYWN0b3IgdmlhIHRoZSBgc2VuZEJhY2tgIGZ1bmN0aW9uXG4gKlxuICogQ2FsbGJhY2sgYWN0b3JzIGFyZSBhIGJpdCBkaWZmZXJlbnQgZnJvbSBvdGhlciBhY3RvcnMgaW4gdGhhdCB0aGV5OlxuICpcbiAqIC0gRG8gbm90IHdvcmsgd2l0aCBgb25Eb25lYFxuICogLSBEbyBub3QgcHJvZHVjZSBhIHNuYXBzaG90IHVzaW5nIGAuZ2V0U25hcHNob3QoKWBcbiAqIC0gRG8gbm90IGVtaXQgdmFsdWVzIHdoZW4gdXNlZCB3aXRoIGAuc3Vic2NyaWJlKClgXG4gKiAtIENhbiBub3QgYmUgc3RvcHBlZCB3aXRoIGAuc3RvcCgpYFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgY2FsbGJhY2tMb2dpYyA9IGZyb21DYWxsYmFjaygoeyBzZW5kQmFjaywgcmVjZWl2ZSB9KSA9PiB7XG4gKiAgIGxldCBsb2NrU3RhdHVzID0gJ3VubG9ja2VkJztcbiAqXG4gKiAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAqICAgICBpZiAobG9ja1N0YXR1cyA9PT0gJ2xvY2tlZCcpIHtcbiAqICAgICAgIHJldHVybjtcbiAqICAgICB9XG4gKiAgICAgc2VuZEJhY2soZXZlbnQpO1xuICogICB9O1xuICpcbiAqICAgcmVjZWl2ZSgoZXZlbnQpID0+IHtcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2xvY2snKSB7XG4gKiAgICAgICBsb2NrU3RhdHVzID0gJ2xvY2tlZCc7XG4gKiAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAndW5sb2NrJykge1xuICogICAgICAgbG9ja1N0YXR1cyA9ICd1bmxvY2tlZCc7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKTtcbiAqXG4gKiAgIHJldHVybiAoKSA9PiB7XG4gKiAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICogICB9O1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdXNlZCB0byBkZXNjcmliZSB0aGUgY2FsbGJhY2sgbG9naWNcbiAqICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGByZWNlaXZlYCAtIEEgZnVuY3Rpb24gdGhhdCBjYW4gc2VuZCBldmVudHMgYmFjayB0byB0aGUgcGFyZW50IGFjdG9yOyB0aGVcbiAqICAgICAgIGxpc3RlbmVyIGlzIHRoZW4gY2FsbGVkIHdoZW5ldmVyIGV2ZW50cyBhcmUgcmVjZWl2ZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiAgICAgICBhY3RvclxuICogICAtIGBzZW5kQmFja2AgLSBBIGZ1bmN0aW9uIHRoYXQgY2FuIHNlbmQgZXZlbnRzIGJhY2sgdG8gdGhlIHBhcmVudCBhY3RvclxuICogICAtIGBpbnB1dGAgLSBEYXRhIHRoYXQgd2FzIHByb3ZpZGVkIHRvIHRoZSBjYWxsYmFjayBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3Igb2YgdGhlIGNhbGxiYWNrIGFjdG9yXG4gKiAgIC0gYHN5c3RlbWAgLSBUaGUgYWN0b3Igc3lzdGVtIHRvIHdoaWNoIHRoZSBjYWxsYmFjayBhY3RvciBiZWxvbmdzIFRoZSBjYWxsYmFja1xuICogICAgICAgZnVuY3Rpb24gY2FuIChvcHRpb25hbGx5KSByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWRcbiAqICAgICAgIHdoZW4gdGhlIGFjdG9yIGlzIHN0b3BwZWQuXG4gKlxuICogQHJldHVybnMgQ2FsbGJhY2sgbG9naWNcbiAqIEBzZWUge0BsaW5rIENhbGxiYWNrTG9naWNGdW5jdGlvbn0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBpdHMgb2JqZWN0IGFyZ3VtZW50XG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGxvZ2ljID0ge1xuICAgIGNvbmZpZzogY2FsbGJhY2ssXG4gICAgc3RhcnQ6IChzdGF0ZSwgYWN0b3JTY29wZSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxmLFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIGVtaXRcbiAgICAgIH0gPSBhY3RvclNjb3BlO1xuICAgICAgY29uc3QgY2FsbGJhY2tTdGF0ZSA9IHtcbiAgICAgICAgcmVjZWl2ZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIGRpc3Bvc2U6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGluc3RhbmNlU3RhdGVzLnNldChzZWxmLCBjYWxsYmFja1N0YXRlKTtcbiAgICAgIGNhbGxiYWNrU3RhdGUuZGlzcG9zZSA9IGNhbGxiYWNrKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNlbmRCYWNrOiBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuZ2V0U25hcHNob3QoKS5zdGF0dXMgPT09ICdzdG9wcGVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZi5fcGFyZW50KSB7XG4gICAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYuX3BhcmVudCwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVjZWl2ZTogbGlzdGVuZXIgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrU3RhdGUucmVjZWl2ZXJzID8/PSBuZXcgU2V0KCk7XG4gICAgICAgICAgY2FsbGJhY2tTdGF0ZS5yZWNlaXZlcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW1pdFxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja1N0YXRlID0gaW5zdGFuY2VTdGF0ZXMuZ2V0KGFjdG9yU2NvcGUuc2VsZik7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gWFNUQVRFX1NUT1ApIHtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgc3RhdHVzOiAnc3RvcHBlZCcsXG4gICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBjYWxsYmFja1N0YXRlLmRpc3Bvc2U/LigpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICBjYWxsYmFja1N0YXRlLnJlY2VpdmVycz8uZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlcihldmVudCkpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90XG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgWFNUQVRFX09CU0VSVkFCTEVfTkVYVCA9ICd4c3RhdGUub2JzZXJ2YWJsZS5uZXh0JztcbmNvbnN0IFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SID0gJ3hzdGF0ZS5vYnNlcnZhYmxlLmVycm9yJztcbmNvbnN0IFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFID0gJ3hzdGF0ZS5vYnNlcnZhYmxlLmNvbXBsZXRlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdG9yIGNyZWF0ZWQgYnkgYGZyb21PYnNlcnZhYmxlYCBvciBgZnJvbUV2ZW50T2JzZXJ2YWJsZWAuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tT2JzZXJ2YWJsZSwgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgaW50ZXJ2YWwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiAvLyBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgb2JzZXJ2ZWQgYnkgdGhlIGFjdG9yJ3MgbG9naWMuXG4gKiB0eXBlIENvbnRleHQgPSBudW1iZXI7XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IHBlcmlvZD86IG51bWJlciB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgb2JzZXJ2ZXMgYSBudW1iZXIgaW5jcmVtZW50ZWQgZXZlcnkgYGlucHV0LnBlcmlvZGBcbiAqIC8vIG1pbGxpc2Vjb25kcyAoZGVmYXVsdDogMV8wMDApLlxuICogY29uc3QgbG9naWMgPSBmcm9tT2JzZXJ2YWJsZTxDb250ZXh0LCBJbnB1dD4oKHsgaW5wdXQsIHNlbGYgfSkgPT4ge1xuICogICBzZWxmO1xuICogICAvLyBePyBPYnNlcnZhYmxlQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICpcbiAqICAgcmV0dXJuIGludGVydmFsKGlucHV0LnBlcmlvZCA/PyAxXzAwMCk7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IHBlcmlvZDogMl8wMDAgfSB9KTtcbiAqIC8vICAgIF4/IE9ic2VydmFibGVBY3RvclJlZjxFdmVudCwgSW5wdXQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tT2JzZXJ2YWJsZX1cbiAqIEBzZWUge0BsaW5rIGZyb21FdmVudE9ic2VydmFibGV9XG4gKi9cblxuLyoqXG4gKiBPYnNlcnZhYmxlIGFjdG9yIGxvZ2ljIGlzIGRlc2NyaWJlZCBieSBhbiBvYnNlcnZhYmxlIHN0cmVhbSBvZiB2YWx1ZXMuIEFjdG9yc1xuICogY3JlYXRlZCBmcm9tIG9ic2VydmFibGUgbG9naWMgKOKAnG9ic2VydmFibGUgYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBFbWl0IHNuYXBzaG90cyBvZiB0aGUgb2JzZXJ2YWJsZeKAmXMgZW1pdHRlZCB2YWx1ZVxuICpcbiAqIFRoZSBvYnNlcnZhYmxl4oCZcyBlbWl0dGVkIHZhbHVlIGlzIHVzZWQgYXMgaXRzIG9ic2VydmFibGUgYWN0b3LigJlzIGBjb250ZXh0YC5cbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBvYnNlcnZhYmxlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21PYnNlcnZhYmxlLCBjcmVhdGVBY3RvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBpbnRlcnZhbCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IGxvZ2ljID0gZnJvbU9ic2VydmFibGUoKG9iaikgPT4gaW50ZXJ2YWwoMTAwMCkpO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMpO1xuICpcbiAqIGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAqICAgY29uc29sZS5sb2coc25hcHNob3QuY29udGV4dCk7XG4gKiB9KTtcbiAqXG4gKiBhY3Rvci5zdGFydCgpO1xuICogLy8gQXQgZXZlcnkgc2Vjb25kOlxuICogLy8gTG9ncyAwXG4gKiAvLyBMb2dzIDFcbiAqIC8vIExvZ3MgMlxuICogLy8gLi4uXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZUNyZWF0b3IgQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gb2JzZXJ2YWJsZS4gSXQgcmVjZWl2ZXNcbiAqICAgb25lIGFyZ3VtZW50LCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBpbnB1dGAgLSBEYXRhIHRoYXQgd2FzIHByb3ZpZGVkIHRvIHRoZSBvYnNlcnZhYmxlIGFjdG9yXG4gKiAgIC0gYHNlbGZgIC0gVGhlIHBhcmVudCBhY3RvclxuICogICAtIGBzeXN0ZW1gIC0gVGhlIGFjdG9yIHN5c3RlbSB0byB3aGljaCB0aGUgb2JzZXJ2YWJsZSBhY3RvciBiZWxvbmdzXG4gKlxuICogICBJdCBzaG91bGQgcmV0dXJuIGEge0BsaW5rIFN1YnNjcmliYWJsZX0sIHdoaWNoIGlzIGNvbXBhdGlibGUgd2l0aCBhbiBSeEpTXG4gKiAgIE9ic2VydmFibGUsIGFsdGhvdWdoIFJ4SlMgaXMgbm90IHJlcXVpcmVkIHRvIGNyZWF0ZSB0aGVtLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yeGpzLmRldn0gZm9yIGRvY3VtZW50YXRpb24gb24gUnhKUyBPYnNlcnZhYmxlIGFuZCBvYnNlcnZhYmxlIGNyZWF0b3JzLlxuICogQHNlZSB7QGxpbmsgU3Vic2NyaWJhYmxlfSBpbnRlcmZhY2UgaW4gWFN0YXRlLCB3aGljaCBpcyBiYXNlZCBvbiBhbmQgY29tcGF0aWJsZSB3aXRoIFJ4SlMgT2JzZXJ2YWJsZS5cbiAqL1xuZnVuY3Rpb24gZnJvbU9ic2VydmFibGUob2JzZXJ2YWJsZUNyZWF0b3IpIHtcbiAgLy8gVE9ETzogYWRkIGV2ZW50IHR5cGVzXG4gIGNvbnN0IGxvZ2ljID0ge1xuICAgIGNvbmZpZzogb2JzZXJ2YWJsZUNyZWF0b3IsXG4gICAgdHJhbnNpdGlvbjogKHNuYXBzaG90LCBldmVudCkgPT4ge1xuICAgICAgaWYgKHNuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgWFNUQVRFX09CU0VSVkFCTEVfTkVYVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBuZXdTbmFwc2hvdCA9IHtcbiAgICAgICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IGV2ZW50LmRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3U25hcHNob3Q7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICAgIGVycm9yOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEU6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgc3RhdHVzOiAnZG9uZScsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfU1RPUDpcbiAgICAgICAgICBzbmFwc2hvdC5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgc3RhdHVzOiAnc3RvcHBlZCcsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9LFxuICAgIHN0YXJ0OiAoc3RhdGUsIHtcbiAgICAgIHNlbGYsXG4gICAgICBzeXN0ZW0sXG4gICAgICBlbWl0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ2RvbmUnKSB7XG4gICAgICAgIC8vIERvIG5vdCByZXN0YXJ0IGEgY29tcGxldGVkIG9ic2VydmFibGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RhdGUuX3N1YnNjcmlwdGlvbiA9IG9ic2VydmFibGVDcmVhdG9yKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGVtaXRcbiAgICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IHZhbHVlID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX05FWFQsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZXJyID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SLFxuICAgICAgICAgICAgZGF0YTogZXJyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiAoe1xuICAgICAgX3N1YnNjcmlwdGlvbixcbiAgICAgIC4uLnN0YXRlXG4gICAgfSkgPT4gc3RhdGUsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzdGF0ZSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICB9KVxuICB9O1xuICByZXR1cm4gbG9naWM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBldmVudCBvYnNlcnZhYmxlIGxvZ2ljIHRoYXQgbGlzdGVucyB0byBhbiBvYnNlcnZhYmxlIHRoYXQgZGVsaXZlcnNcbiAqIGV2ZW50IG9iamVjdHMuXG4gKlxuICogRXZlbnQgb2JzZXJ2YWJsZSBhY3RvciBsb2dpYyBpcyBkZXNjcmliZWQgYnkgYW4gb2JzZXJ2YWJsZSBzdHJlYW0gb2ZcbiAqIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy90cmFuc2l0aW9ucyNldmVudC1vYmplY3RzIHwgZXZlbnQgb2JqZWN0c30uXG4gKiBBY3RvcnMgY3JlYXRlZCBmcm9tIGV2ZW50IG9ic2VydmFibGUgbG9naWMgKOKAnGV2ZW50IG9ic2VydmFibGUgYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBJbXBsaWNpdGx5IHNlbmQgZXZlbnRzIHRvIGl0cyBwYXJlbnQgYWN0b3JcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgaXRzIGVtaXR0ZWQgZXZlbnQgb2JqZWN0c1xuICpcbiAqIFNlbmRpbmcgZXZlbnRzIHRvIGV2ZW50IG9ic2VydmFibGUgYWN0b3JzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgZnJvbUV2ZW50T2JzZXJ2YWJsZSxcbiAqICAgU3Vic2NyaWJhYmxlLFxuICogICBFdmVudE9iamVjdCxcbiAqICAgY3JlYXRlTWFjaGluZSxcbiAqICAgY3JlYXRlQWN0b3JcbiAqIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IG1vdXNlQ2xpY2tMb2dpYyA9IGZyb21FdmVudE9ic2VydmFibGUoXG4gKiAgICgpID0+IGZyb21FdmVudChkb2N1bWVudC5ib2R5LCAnY2xpY2snKSBhcyBTdWJzY3JpYmFibGU8RXZlbnRPYmplY3Q+XG4gKiApO1xuICpcbiAqIGNvbnN0IGNhbnZhc01hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgaW52b2tlOiB7XG4gKiAgICAgLy8gV2lsbCBzZW5kIG1vdXNlIGBjbGlja2AgZXZlbnRzIHRvIHRoZSBjYW52YXMgYWN0b3JcbiAqICAgICBzcmM6IG1vdXNlQ2xpY2tMb2dpY1xuICogICB9XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjYW52YXNBY3RvciA9IGNyZWF0ZUFjdG9yKGNhbnZhc01hY2hpbmUpO1xuICogY2FudmFzQWN0b3Iuc3RhcnQoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsYXp5T2JzZXJ2YWJsZSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBvYnNlcnZhYmxlIHRoYXQgZGVsaXZlcnNcbiAqICAgZXZlbnQgb2JqZWN0cy4gSXQgcmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiAgIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBpbnB1dGAgLSBEYXRhIHRoYXQgd2FzIHByb3ZpZGVkIHRvIHRoZSBldmVudCBvYnNlcnZhYmxlIGFjdG9yXG4gKiAgIC0gYHNlbGZgIC0gVGhlIHBhcmVudCBhY3RvclxuICogICAtIGBzeXN0ZW1gIC0gVGhlIGFjdG9yIHN5c3RlbSB0byB3aGljaCB0aGUgZXZlbnQgb2JzZXJ2YWJsZSBhY3RvciBiZWxvbmdzLlxuICpcbiAqICAgSXQgc2hvdWxkIHJldHVybiBhIHtAbGluayBTdWJzY3JpYmFibGV9LCB3aGljaCBpcyBjb21wYXRpYmxlIHdpdGggYW4gUnhKU1xuICogICBPYnNlcnZhYmxlLCBhbHRob3VnaCBSeEpTIGlzIG5vdCByZXF1aXJlZCB0byBjcmVhdGUgdGhlbS5cbiAqL1xuZnVuY3Rpb24gZnJvbUV2ZW50T2JzZXJ2YWJsZShsYXp5T2JzZXJ2YWJsZSkge1xuICAvLyBUT0RPOiBldmVudCB0eXBlc1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IGxhenlPYnNlcnZhYmxlLFxuICAgIHRyYW5zaXRpb246IChzdGF0ZSwgZXZlbnQpID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICAgIGVycm9yOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEU6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZG9uZScsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfU1RPUDpcbiAgICAgICAgICBzdGF0ZS5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnc3RvcHBlZCcsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9LFxuICAgIHN0YXJ0OiAoc3RhdGUsIHtcbiAgICAgIHNlbGYsXG4gICAgICBzeXN0ZW0sXG4gICAgICBlbWl0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ2RvbmUnKSB7XG4gICAgICAgIC8vIERvIG5vdCByZXN0YXJ0IGEgY29tcGxldGVkIG9ic2VydmFibGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RhdGUuX3N1YnNjcmlwdGlvbiA9IGxhenlPYnNlcnZhYmxlKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGVtaXRcbiAgICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAoc2VsZi5fcGFyZW50KSB7XG4gICAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYuX3BhcmVudCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUixcbiAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogKHtcbiAgICAgIF9zdWJzY3JpcHRpb24sXG4gICAgICAuLi5zbmFwc2hvdFxuICAgIH0pID0+IHNuYXBzaG90LFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc25hcHNob3QgPT4gKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG5jb25zdCBYU1RBVEVfUFJPTUlTRV9SRVNPTFZFID0gJ3hzdGF0ZS5wcm9taXNlLnJlc29sdmUnO1xuY29uc3QgWFNUQVRFX1BST01JU0VfUkVKRUNUID0gJ3hzdGF0ZS5wcm9taXNlLnJlamVjdCc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tUHJvbWlzZWAuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tUHJvbWlzZSwgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIC8vIFRoZSBhY3RvcidzIHJlc29sdmVkIG91dHB1dFxuICogdHlwZSBPdXRwdXQgPSBzdHJpbmc7XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IG1lc3NhZ2U6IHN0cmluZyB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgZmV0Y2hlcyB0aGUgdXJsIG9mIGFuIGltYWdlIG9mIGEgY2F0IHNheWluZyBgaW5wdXQubWVzc2FnZWAuXG4gKiBjb25zdCBsb2dpYyA9IGZyb21Qcm9taXNlPE91dHB1dCwgSW5wdXQ+KGFzeW5jICh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgc2VsZjtcbiAqICAgLy8gXj8gUHJvbWlzZUFjdG9yUmVmPE91dHB1dCwgSW5wdXQ+XG4gKlxuICogICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2goXG4gKiAgICAgYGh0dHBzOi8vY2F0YWFzLmNvbS9jYXQvc2F5cy8ke2lucHV0Lm1lc3NhZ2V9YFxuICogICApO1xuICogICBjb25zdCB1cmwgPSBhd2FpdCBkYXRhLmpzb24oKTtcbiAqICAgcmV0dXJuIHVybDtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMsIHsgaW5wdXQ6IHsgbWVzc2FnZTogJ2hlbGxvIHdvcmxkJyB9IH0pO1xuICogLy8gICAgXj8gUHJvbWlzZUFjdG9yUmVmPE91dHB1dCwgSW5wdXQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tUHJvbWlzZX1cbiAqL1xuXG5jb25zdCBjb250cm9sbGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBBbiBhY3RvciBsb2dpYyBjcmVhdG9yIHdoaWNoIHJldHVybnMgcHJvbWlzZSBsb2dpYyBhcyBkZWZpbmVkIGJ5IGFuIGFzeW5jXG4gKiBwcm9jZXNzIHRoYXQgcmVzb2x2ZXMgb3IgcmVqZWN0cyBhZnRlciBzb21lIHRpbWUuXG4gKlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBwcm9taXNlIGFjdG9yIGxvZ2ljICjigJxwcm9taXNlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gRW1pdCB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgdGhlIHByb21pc2VcbiAqIC0gT3V0cHV0IHRoZSByZXNvbHZlZCB2YWx1ZSBvZiB0aGUgcHJvbWlzZVxuICpcbiAqIFNlbmRpbmcgZXZlbnRzIHRvIHByb21pc2UgYWN0b3JzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgcHJvbWlzZUxvZ2ljID0gZnJvbVByb21pc2UoYXN5bmMgKCkgPT4ge1xuICogICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9leGFtcGxlLmNvbS8uLi4nKS50aGVuKChkYXRhKSA9PlxuICogICAgIGRhdGEuanNvbigpXG4gKiAgICk7XG4gKlxuICogICByZXR1cm4gcmVzdWx0O1xuICogfSk7XG4gKlxuICogY29uc3QgcHJvbWlzZUFjdG9yID0gY3JlYXRlQWN0b3IocHJvbWlzZUxvZ2ljKTtcbiAqIHByb21pc2VBY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAqIH0pO1xuICogcHJvbWlzZUFjdG9yLnN0YXJ0KCk7XG4gKiAvLyA9PiB7XG4gKiAvLyAgIG91dHB1dDogdW5kZWZpbmVkLFxuICogLy8gICBzdGF0dXM6ICdhY3RpdmUnXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICpcbiAqIC8vIEFmdGVyIHByb21pc2UgcmVzb2x2ZXNcbiAqIC8vID0+IHtcbiAqIC8vICAgb3V0cHV0OiB7IC4uLiB9LFxuICogLy8gICBzdGF0dXM6ICdkb25lJyxcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHJvbWlzZUNyZWF0b3IgQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgYW5kIGFjY2VwdHMgYW5cbiAqICAgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgcHJvbWlzZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3Igb2YgdGhlIHByb21pc2UgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIHByb21pc2UgYWN0b3IgYmVsb25nc1xuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2lucHV0IHwgSW5wdXQgZG9jc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IGlucHV0IGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBmcm9tUHJvbWlzZShwcm9taXNlQ3JlYXRvcikge1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IHByb21pc2VDcmVhdG9yLFxuICAgIHRyYW5zaXRpb246IChzdGF0ZSwgZXZlbnQsIHNjb3BlKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBYU1RBVEVfUFJPTUlTRV9SRVNPTFZFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHJlc29sdmVkVmFsdWUsXG4gICAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFhTVEFURV9QUk9NSVNFX1JFSkVDVDpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9TVE9QOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXJNYXAuZ2V0KHNjb3BlLnNlbGYpPy5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIC8vIFRPRE86IGRldGVybWluZSBob3cgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhpcyBzbyB0aGF0IHByb21pc2VzXG4gICAgICAvLyBjYW4gYmUgcmVzdGFydGVkIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnRyb2xsZXJNYXAuc2V0KHNlbGYsIGNvbnRyb2xsZXIpO1xuICAgICAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHByb21pc2VDcmVhdG9yKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGVtaXRcbiAgICAgIH0pKTtcbiAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0U25hcHNob3QoKS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXJNYXAuZGVsZXRlKHNlbGYpO1xuICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICB0eXBlOiBYU1RBVEVfUFJPTUlTRV9SRVNPTFZFLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlXG4gICAgICAgIH0pO1xuICAgICAgfSwgZXJyb3JEYXRhID0+IHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0U25hcHNob3QoKS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXJNYXAuZGVsZXRlKHNlbGYpO1xuICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICB0eXBlOiBYU1RBVEVfUFJPTUlTRV9SRUpFQ1QsXG4gICAgICAgICAgZGF0YTogZXJyb3JEYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90LFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3RcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG5jb25zdCBlbXB0eUxvZ2ljID0gZnJvbVRyYW5zaXRpb24oXyA9PiB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUFjdG9yKCkge1xuICByZXR1cm4gY3JlYXRlQWN0b3IoZW1wdHlMb2dpYyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVtcHR5QWN0b3IsIGZyb21DYWxsYmFjaywgZnJvbUV2ZW50T2JzZXJ2YWJsZSwgZnJvbU9ic2VydmFibGUsIGZyb21Qcm9taXNlLCBmcm9tVHJhbnNpdGlvbiB9O1xuIl0sIm5hbWVzIjpbIlgiLCJYU1RBVEVfU1RPUCIsIkEiLCJjcmVhdGVBY3RvciIsImZyb21UcmFuc2l0aW9uIiwidHJhbnNpdGlvbiIsImluaXRpYWxDb250ZXh0IiwiY29uZmlnIiwic25hcHNob3QiLCJldmVudCIsImFjdG9yU2NvcGUiLCJjb250ZXh0IiwiZ2V0SW5pdGlhbFNuYXBzaG90IiwiXyIsImlucHV0Iiwic3RhdHVzIiwib3V0cHV0IiwidW5kZWZpbmVkIiwiZXJyb3IiLCJnZXRQZXJzaXN0ZWRTbmFwc2hvdCIsInJlc3RvcmVTbmFwc2hvdCIsImluc3RhbmNlU3RhdGVzIiwiV2Vha01hcCIsImZyb21DYWxsYmFjayIsImNhbGxiYWNrIiwibG9naWMiLCJzdGFydCIsInN0YXRlIiwic2VsZiIsInN5c3RlbSIsImVtaXQiLCJjYWxsYmFja1N0YXRlIiwicmVjZWl2ZXJzIiwiZGlzcG9zZSIsInNldCIsInNlbmRCYWNrIiwiZ2V0U25hcHNob3QiLCJfcGFyZW50IiwiX3JlbGF5IiwicmVjZWl2ZSIsImxpc3RlbmVyIiwiU2V0IiwiYWRkIiwiZ2V0IiwidHlwZSIsImZvckVhY2giLCJyZWNlaXZlciIsIlhTVEFURV9PQlNFUlZBQkxFX05FWFQiLCJYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUiIsIlhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFIiwiZnJvbU9ic2VydmFibGUiLCJvYnNlcnZhYmxlQ3JlYXRvciIsIm5ld1NuYXBzaG90IiwiZGF0YSIsIl9zdWJzY3JpcHRpb24iLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZSIsIm5leHQiLCJ2YWx1ZSIsImVyciIsImNvbXBsZXRlIiwiZnJvbUV2ZW50T2JzZXJ2YWJsZSIsImxhenlPYnNlcnZhYmxlIiwiWFNUQVRFX1BST01JU0VfUkVTT0xWRSIsIlhTVEFURV9QUk9NSVNFX1JFSkVDVCIsImNvbnRyb2xsZXJNYXAiLCJmcm9tUHJvbWlzZSIsInByb21pc2VDcmVhdG9yIiwic2NvcGUiLCJyZXNvbHZlZFZhbHVlIiwiYWJvcnQiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwicmVzb2x2ZWRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzaWduYWwiLCJ0aGVuIiwicmVzcG9uc2UiLCJkZWxldGUiLCJlcnJvckRhdGEiLCJlbXB0eUxvZ2ljIiwiY3JlYXRlRW1wdHlBY3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dev/dist/xstate-dev.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devToolsAdapter: () => (/* binding */ devToolsAdapter),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   registerService: () => (/* binding */ registerService)\n/* harmony export */ });\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    {\n        console.warn(\"XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues\");\n    }\n}\nfunction getDevTools() {\n    const w = getGlobal();\n    if (w.__xstate__) {\n        return w.__xstate__;\n    }\n    return undefined;\n}\nfunction registerService(service) {\n    if (true) {\n        return;\n    }\n    const devTools = getDevTools();\n    if (devTools) {\n        devTools.register(service);\n    }\n}\nconst devToolsAdapter = (service)=>{\n    if (true) {\n        return;\n    }\n    const devTools = getDevTools();\n    if (devTools) {\n        devTools.register(service);\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1HQUFtRztBQUNuRyxTQUFTQTtJQUNQLElBQUksT0FBT0MsZUFBZSxhQUFhO1FBQ3JDLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9DLFNBQVMsYUFBYTtRQUMvQixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxLQUFrQixFQUFhLEVBRWxDO0lBQ0QsSUFBSSxPQUFPRSxXQUFXLGFBQWE7UUFDakMsT0FBT0E7SUFDVDtJQUNBO1FBQ0VDLFFBQVFDLElBQUksQ0FBQztJQUNmO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE1BQU1DLElBQUlSO0lBQ1YsSUFBSVEsRUFBRUMsVUFBVSxFQUFFO1FBQ2hCLE9BQU9ELEVBQUVDLFVBQVU7SUFDckI7SUFDQSxPQUFPQztBQUNUO0FBQ0EsU0FBU0MsZ0JBQWdCQyxPQUFPO0lBQzlCLElBQUksSUFBa0IsRUFBYTtRQUNqQztJQUNGO0lBQ0EsTUFBTUMsV0FBV047SUFDakIsSUFBSU0sVUFBVTtRQUNaQSxTQUFTQyxRQUFRLENBQUNGO0lBQ3BCO0FBQ0Y7QUFDQSxNQUFNRyxrQkFBa0JILENBQUFBO0lBQ3RCLElBQUksSUFBa0IsRUFBYTtRQUNqQztJQUNGO0lBQ0EsTUFBTUMsV0FBV047SUFDakIsSUFBSU0sVUFBVTtRQUNaQSxTQUFTQyxRQUFRLENBQUNGO0lBQ3BCO0FBQ0Y7QUFFdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGlwbGk5LXBhcmFub3JtYWwvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzPzRmZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9nbG9iYWxUaGlzXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIHtcbiAgICBjb25zb2xlLndhcm4oJ1hTdGF0ZSBjb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3QgaW4gdGhpcyBlbnZpcm9ubWVudC4gUGxlYXNlIGxldCB0aGUgbWFpbnRhaW5lcnMga25vdyBhbmQgcmFpc2UgYW4gaXNzdWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3N0YXRlbHlhaS94c3RhdGUvaXNzdWVzJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERldlRvb2xzKCkge1xuICBjb25zdCB3ID0gZ2V0R2xvYmFsKCk7XG4gIGlmICh3Ll9feHN0YXRlX18pIHtcbiAgICByZXR1cm4gdy5fX3hzdGF0ZV9fO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZWdpc3RlclNlcnZpY2Uoc2VydmljZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGV2VG9vbHMgPSBnZXREZXZUb29scygpO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBkZXZUb29scy5yZWdpc3RlcihzZXJ2aWNlKTtcbiAgfVxufVxuY29uc3QgZGV2VG9vbHNBZGFwdGVyID0gc2VydmljZSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZXZUb29scyA9IGdldERldlRvb2xzKCk7XG4gIGlmIChkZXZUb29scykge1xuICAgIGRldlRvb2xzLnJlZ2lzdGVyKHNlcnZpY2UpO1xuICB9XG59O1xuXG5leHBvcnQgeyBkZXZUb29sc0FkYXB0ZXIsIGdldEdsb2JhbCwgcmVnaXN0ZXJTZXJ2aWNlIH07XG4iXSwibmFtZXMiOlsiZ2V0R2xvYmFsIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJjb25zb2xlIiwid2FybiIsImdldERldlRvb2xzIiwidyIsIl9feHN0YXRlX18iLCJ1bmRlZmluZWQiLCJyZWdpc3RlclNlcnZpY2UiLCJzZXJ2aWNlIiwiZGV2VG9vbHMiLCJyZWdpc3RlciIsImRldlRvb2xzQWRhcHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/log-5a7b5528.development.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/xstate/dist/log-5a7b5528.development.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ SpecialTargets),\n/* harmony export */   a: () => (/* binding */ assign),\n/* harmony export */   b: () => (/* binding */ enqueueActions),\n/* harmony export */   c: () => (/* binding */ sendTo),\n/* harmony export */   e: () => (/* binding */ emit),\n/* harmony export */   f: () => (/* binding */ forwardTo),\n/* harmony export */   l: () => (/* binding */ log),\n/* harmony export */   s: () => (/* binding */ sendParent)\n/* harmony export */ });\n/* harmony import */ var _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-59549771.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-59549771.development.esm.js\");\n\nfunction createSpawner(actorScope, { machine, context }, event, spawnedChildren) {\n    const spawn = (src, options)=>{\n        if (typeof src === \"string\") {\n            const logic = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(machine, src);\n            if (!logic) {\n                throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n            }\n            const actorRef = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(logic, {\n                id: options?.id,\n                parent: actorScope.self,\n                syncSnapshot: options?.syncSnapshot,\n                input: typeof options?.input === \"function\" ? options.input({\n                    context,\n                    event,\n                    self: actorScope.self\n                }) : options?.input,\n                src,\n                systemId: options?.systemId\n            });\n            spawnedChildren[actorRef.id] = actorRef;\n            return actorRef;\n        } else {\n            const actorRef = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(src, {\n                id: options?.id,\n                parent: actorScope.self,\n                syncSnapshot: options?.syncSnapshot,\n                input: options?.input,\n                src,\n                systemId: options?.systemId\n            });\n            return actorRef;\n        }\n    };\n    return (src, options)=>{\n        const actorRef = spawn(src, options); // TODO: fix types\n        spawnedChildren[actorRef.id] = actorRef;\n        actorScope.defer(()=>{\n            if (actorRef._processingStatus === _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T.Stopped) {\n                return;\n            }\n            actorRef.start();\n        });\n        return actorRef;\n    };\n}\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, { assignment }) {\n    if (!snapshot.context) {\n        throw new Error(\"Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.\");\n    }\n    const spawnedChildren = {};\n    const assignArgs = {\n        context: snapshot.context,\n        event: actionArgs.event,\n        spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n        self: actorScope.self,\n        system: actorScope.system\n    };\n    let partialUpdate = {};\n    if (typeof assignment === \"function\") {\n        partialUpdate = assignment(assignArgs, actionParams);\n    } else {\n        for (const key of Object.keys(assignment)){\n            const propAssignment = assignment[key];\n            partialUpdate[key] = typeof propAssignment === \"function\" ? propAssignment(assignArgs, actionParams) : propAssignment;\n        }\n    }\n    const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n    return [\n        (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U)(snapshot, {\n            context: updatedContext,\n            children: Object.keys(spawnedChildren).length ? {\n                ...snapshot.children,\n                ...spawnedChildren\n            } : snapshot.children\n        }),\n        undefined,\n        undefined\n    ];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */ function assign(assignment) {\n    if (_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function assign(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    assign.type = \"xstate.assign\";\n    assign.assignment = assignment;\n    assign.resolve = resolveAssign;\n    return assign;\n}\nfunction resolveEmit(_, snapshot, args, actionParams, { event: eventOrExpr }) {\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    return [\n        snapshot,\n        {\n            event: resolvedEvent\n        },\n        undefined\n    ];\n}\nfunction executeEmit(actorScope, { event }) {\n    actorScope.defer(()=>actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */ function emit(/** The event to emit, or an expression that returns an event to emit. */ eventOrExpr) {\n    if (_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function emit(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    emit.type = \"xstate.emit\";\n    emit.event = eventOrExpr;\n    emit.resolve = resolveEmit;\n    emit.execute = executeEmit;\n    return emit;\n}\n// this is needed to make JSDoc `@link` work properly\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */ // https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n// @TODO: we can't use native `NoInfer` as we need those:\n// https://github.com/microsoft/TypeScript/pull/61092\n// https://github.com/microsoft/TypeScript/pull/61077\n// but even with those fixes native NoInfer still doesn't work - further issues have to be reproduced and fixed\n/** @deprecated Use the built-in `NoInfer` type instead */ /** The full definition of an event, with a string `type`. */ /**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */ /** @deprecated Use `AnyMachineSnapshot` instead */ // TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */ let SpecialTargets = /*#__PURE__*/ function(SpecialTargets) {\n    SpecialTargets[\"Parent\"] = \"#_parent\";\n    SpecialTargets[\"Internal\"] = \"#_internal\";\n    return SpecialTargets;\n}({});\n/** @deprecated Use `AnyActor` instead. */ // Based on RxJS types\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n/** @deprecated Use `Actor<T>` instead. */ /**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */ /** @deprecated */ // TODO: cover all that can be actually returned\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, { to, event: eventOrExpr, id, delay }, extra) {\n    const delaysMap = snapshot.machine.implementations.delays;\n    if (typeof eventOrExpr === \"string\") {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n    }\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    let resolvedDelay;\n    if (typeof delay === \"string\") {\n        const configDelay = delaysMap && delaysMap[delay];\n        resolvedDelay = typeof configDelay === \"function\" ? configDelay(args, actionParams) : configDelay;\n    } else {\n        resolvedDelay = typeof delay === \"function\" ? delay(args, actionParams) : delay;\n    }\n    const resolvedTarget = typeof to === \"function\" ? to(args, actionParams) : to;\n    let targetActorRef;\n    if (typeof resolvedTarget === \"string\") {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (resolvedTarget === SpecialTargets.Parent) {\n            targetActorRef = actorScope.self._parent;\n        } else if (resolvedTarget === SpecialTargets.Internal) {\n            targetActorRef = actorScope.self;\n        } else if (resolvedTarget.startsWith(\"#_\")) {\n            // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n            // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n            targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n        } else {\n            targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n        }\n        if (!targetActorRef) {\n            throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n        }\n    } else {\n        targetActorRef = resolvedTarget || actorScope.self;\n    }\n    return [\n        snapshot,\n        {\n            to: targetActorRef,\n            targetId: typeof resolvedTarget === \"string\" ? resolvedTarget : undefined,\n            event: resolvedEvent,\n            id,\n            delay: resolvedDelay\n        },\n        undefined\n    ];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n    if (typeof params.to === \"string\") {\n        params.to = snapshot.children[params.to];\n    }\n}\nfunction executeSendTo(actorScope, params) {\n    // this forms an outgoing events queue\n    // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n    actorScope.defer(()=>{\n        const { to, event, delay, id } = params;\n        if (typeof delay === \"number\") {\n            actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n            return;\n        }\n        actorScope.system._relay(actorScope.self, // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n        // if it initially started as a string\n        to, event.type === _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.W ? (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Y)(actorScope.self.id, event.data) : event);\n    });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */ function sendTo(to, eventOrExpr, options) {\n    if (_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `sendTo()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function sendTo(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    sendTo.type = \"xstate.sendTo\";\n    sendTo.to = to;\n    sendTo.event = eventOrExpr;\n    sendTo.id = options?.id;\n    sendTo.delay = options?.delay;\n    sendTo.resolve = resolveSendTo;\n    sendTo.retryResolve = retryResolveSendTo;\n    sendTo.execute = executeSendTo;\n    return sendTo;\n}\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */ function sendParent(event, options) {\n    return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */ function forwardTo(target, options) {\n    if (!target || typeof target === \"function\") {\n        const originalTarget = target;\n        target = (...args)=>{\n            const resolvedTarget = typeof originalTarget === \"function\" ? originalTarget(...args) : originalTarget;\n            if (!resolvedTarget) {\n                throw new Error(`Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`);\n            }\n            return resolvedTarget;\n        };\n    }\n    return sendTo(target, ({ event })=>event, options);\n}\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, { collect }) {\n    const actions = [];\n    const enqueue = function enqueue(action) {\n        actions.push(action);\n    };\n    enqueue.assign = (...args)=>{\n        actions.push(assign(...args));\n    };\n    enqueue.cancel = (...args)=>{\n        actions.push((0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(...args));\n    };\n    enqueue.raise = (...args)=>{\n        // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n        // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n        actions.push((0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.O)(...args));\n    };\n    enqueue.sendTo = (...args)=>{\n        // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n        // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n        actions.push(sendTo(...args));\n    };\n    enqueue.sendParent = (...args)=>{\n        actions.push(sendParent(...args));\n    };\n    enqueue.spawnChild = (...args)=>{\n        actions.push((0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.P)(...args));\n    };\n    enqueue.stopChild = (...args)=>{\n        actions.push((0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(...args));\n    };\n    enqueue.emit = (...args)=>{\n        actions.push(emit(...args));\n    };\n    collect({\n        context: args.context,\n        event: args.event,\n        enqueue,\n        check: (guard)=>(0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(guard, snapshot.context, args.event, snapshot),\n        self: actorScope.self,\n        system: actorScope.system\n    }, actionParams);\n    return [\n        snapshot,\n        undefined,\n        actions\n    ];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */ function enqueueActions(collect) {\n    function enqueueActions(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    enqueueActions.type = \"xstate.enqueueActions\";\n    enqueueActions.collect = collect;\n    enqueueActions.resolve = resolveEnqueueActions;\n    return enqueueActions;\n}\nfunction resolveLog(_, snapshot, actionArgs, actionParams, { value, label }) {\n    return [\n        snapshot,\n        {\n            value: typeof value === \"function\" ? value(actionArgs, actionParams) : value,\n            label\n        },\n        undefined\n    ];\n}\nfunction executeLog({ logger }, { value, label }) {\n    if (label) {\n        logger(label, value);\n    } else {\n        logger(value);\n    }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */ function log(value = ({ context, event })=>({\n        context,\n        event\n    }), label) {\n    function log(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    log.type = \"xstate.log\";\n    log.value = value;\n    log.label = label;\n    log.resolve = resolveLog;\n    log.execute = executeLog;\n    return log;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvbG9nLTVhN2I1NTI4LmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK1M7QUFFL1MsU0FBU3dCLGNBQWNDLFVBQVUsRUFBRSxFQUNqQ0MsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsRUFBRUMsS0FBSyxFQUFFQyxlQUFlO0lBQ3ZCLE1BQU1DLFFBQVEsQ0FBQ0MsS0FBS0M7UUFDbEIsSUFBSSxPQUFPRCxRQUFRLFVBQVU7WUFDM0IsTUFBTUUsUUFBUTlCLHFFQUFzQkEsQ0FBQ3VCLFNBQVNLO1lBQzlDLElBQUksQ0FBQ0UsT0FBTztnQkFDVixNQUFNLElBQUlDLE1BQU0sQ0FBQyxhQUFhLEVBQUVILElBQUksOEJBQThCLEVBQUVMLFFBQVFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkY7WUFDQSxNQUFNQyxXQUFXL0IscUVBQVdBLENBQUM0QixPQUFPO2dCQUNsQ0UsSUFBSUgsU0FBU0c7Z0JBQ2JFLFFBQVFaLFdBQVdhLElBQUk7Z0JBQ3ZCQyxjQUFjUCxTQUFTTztnQkFDdkJDLE9BQU8sT0FBT1IsU0FBU1EsVUFBVSxhQUFhUixRQUFRUSxLQUFLLENBQUM7b0JBQzFEYjtvQkFDQUM7b0JBQ0FVLE1BQU1iLFdBQVdhLElBQUk7Z0JBQ3ZCLEtBQUtOLFNBQVNRO2dCQUNkVDtnQkFDQVUsVUFBVVQsU0FBU1M7WUFDckI7WUFDQVosZUFBZSxDQUFDTyxTQUFTRCxFQUFFLENBQUMsR0FBR0M7WUFDL0IsT0FBT0E7UUFDVCxPQUFPO1lBQ0wsTUFBTUEsV0FBVy9CLHFFQUFXQSxDQUFDMEIsS0FBSztnQkFDaENJLElBQUlILFNBQVNHO2dCQUNiRSxRQUFRWixXQUFXYSxJQUFJO2dCQUN2QkMsY0FBY1AsU0FBU087Z0JBQ3ZCQyxPQUFPUixTQUFTUTtnQkFDaEJUO2dCQUNBVSxVQUFVVCxTQUFTUztZQUNyQjtZQUNBLE9BQU9MO1FBQ1Q7SUFDRjtJQUNBLE9BQU8sQ0FBQ0wsS0FB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Q1pHLElBQUl4RCxPQUFPLEdBQUdtRDtJQUNkSyxJQUFJaEQsT0FBTyxHQUFHOEM7SUFDZCxPQUFPRTtBQUNUO0FBRW9JIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxpcGxpOS1wYXJhbm9ybWFsLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L2xvZy01YTdiNTUyOC5kZXZlbG9wbWVudC5lc20uanM/NTEzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUIGFzIFByb2Nlc3NpbmdTdGF0dXMsIHogYXMgcmVzb2x2ZVJlZmVyZW5jZWRBY3RvciwgQSBhcyBjcmVhdGVBY3RvciwgVSBhcyBjbG9uZU1hY2hpbmVTbmFwc2hvdCwgViBhcyBleGVjdXRpbmdDdXN0b21BY3Rpb24sIFcgYXMgWFNUQVRFX0VSUk9SLCBZIGFzIGNyZWF0ZUVycm9yQWN0b3JFdmVudCwgZSBhcyBldmFsdWF0ZUd1YXJkLCBNIGFzIGNhbmNlbCwgTyBhcyByYWlzZSwgUCBhcyBzcGF3bkNoaWxkLCBSIGFzIHN0b3BDaGlsZCB9IGZyb20gJy4vcmFpc2UtNTk1NDk3NzEuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlU3Bhd25lcihhY3RvclNjb3BlLCB7XG4gIG1hY2hpbmUsXG4gIGNvbnRleHRcbn0sIGV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pIHtcbiAgY29uc3Qgc3Bhd24gPSAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsb2dpYyA9IHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKTtcbiAgICAgIGlmICghbG9naWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3RvciBsb2dpYyAnJHtzcmN9JyBub3QgaW1wbGVtZW50ZWQgaW4gbWFjaGluZSAnJHttYWNoaW5lLmlkfSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3IobG9naWMsIHtcbiAgICAgICAgaWQ6IG9wdGlvbnM/LmlkLFxuICAgICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgICAgc3luY1NuYXBzaG90OiBvcHRpb25zPy5zeW5jU25hcHNob3QsXG4gICAgICAgIGlucHV0OiB0eXBlb2Ygb3B0aW9ucz8uaW5wdXQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmlucHV0KHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZlxuICAgICAgICB9KSA6IG9wdGlvbnM/LmlucHV0LFxuICAgICAgICBzcmMsXG4gICAgICAgIHN5c3RlbUlkOiBvcHRpb25zPy5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgICByZXR1cm4gYWN0b3JSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3Ioc3JjLCB7XG4gICAgICAgIGlkOiBvcHRpb25zPy5pZCxcbiAgICAgICAgcGFyZW50OiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogb3B0aW9ucz8uc3luY1NuYXBzaG90LFxuICAgICAgICBpbnB1dDogb3B0aW9ucz8uaW5wdXQsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IG9wdGlvbnM/LnN5c3RlbUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RvclJlZjtcbiAgICB9XG4gIH07XG4gIHJldHVybiAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYWN0b3JSZWYgPSBzcGF3bihzcmMsIG9wdGlvbnMpOyAvLyBUT0RPOiBmaXggdHlwZXNcbiAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhY3RvclJlZi5zdGFydCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3RvclJlZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzc2lnbihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGFzc2lnbm1lbnRcbn0pIHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIHVuZGVmaW5lZCBgY29udGV4dGAuIEVuc3VyZSB0aGF0IGBjb250ZXh0YCBpcyBkZWZpbmVkIGluIHRoZSBtYWNoaW5lIGNvbmZpZy4nKTtcbiAgfVxuICBjb25zdCBzcGF3bmVkQ2hpbGRyZW4gPSB7fTtcbiAgY29uc3QgYXNzaWduQXJncyA9IHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGV2ZW50OiBhY3Rpb25BcmdzLmV2ZW50LFxuICAgIHNwYXduOiBjcmVhdGVTcGF3bmVyKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhY3Rpb25BcmdzLmV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH07XG4gIGxldCBwYXJ0aWFsVXBkYXRlID0ge307XG4gIGlmICh0eXBlb2YgYXNzaWdubWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhcnRpYWxVcGRhdGUgPSBhc3NpZ25tZW50KGFzc2lnbkFyZ3MsIGFjdGlvblBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXNzaWdubWVudCkpIHtcbiAgICAgIGNvbnN0IHByb3BBc3NpZ25tZW50ID0gYXNzaWdubWVudFtrZXldO1xuICAgICAgcGFydGlhbFVwZGF0ZVtrZXldID0gdHlwZW9mIHByb3BBc3NpZ25tZW50ID09PSAnZnVuY3Rpb24nID8gcHJvcEFzc2lnbm1lbnQoYXNzaWduQXJncywgYWN0aW9uUGFyYW1zKSA6IHByb3BBc3NpZ25tZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCB1cGRhdGVkQ29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHNuYXBzaG90LmNvbnRleHQsIHBhcnRpYWxVcGRhdGUpO1xuICByZXR1cm4gW2Nsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgY29udGV4dDogdXBkYXRlZENvbnRleHQsXG4gICAgY2hpbGRyZW46IE9iamVjdC5rZXlzKHNwYXduZWRDaGlsZHJlbikubGVuZ3RoID8ge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICAuLi5zcGF3bmVkQ2hpbGRyZW5cbiAgICB9IDogc25hcHNob3QuY2hpbGRyZW5cbiAgfSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBtYWNoaW5lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGFzc2lnbiB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgY291bnRNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGNvbnRleHQ6IHtcbiAqICAgICBjb3VudDogMCxcbiAqICAgICBtZXNzYWdlOiAnJ1xuICogICB9LFxuICogICBvbjoge1xuICogICAgIGluYzoge1xuICogICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAqICAgICAgICAgY291bnQ6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5jb3VudCArIDFcbiAqICAgICAgIH0pXG4gKiAgICAgfSxcbiAqICAgICB1cGRhdGVNZXNzYWdlOiB7XG4gKiAgICAgICBhY3Rpb25zOiBhc3NpZ24oKHsgY29udGV4dCwgZXZlbnQgfSkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UudHJpbSgpXG4gKiAgICAgICAgIH07XG4gKiAgICAgICB9KVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXNzaWdubWVudCBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0aWFsIGNvbnRleHQgdG8gdXBkYXRlLCBvclxuICogICBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0aWFsIGNvbnRleHQgdG9cbiAqICAgdXBkYXRlLlxuICovXG5mdW5jdGlvbiBhc3NpZ24oYXNzaWdubWVudCkge1xuICBpZiAoZXhlY3V0aW5nQ3VzdG9tQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gYWN0aW9ucyBzaG91bGQgbm90IGNhbGwgYGFzc2lnbigpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBhc3NpZ24oX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGFzc2lnbi50eXBlID0gJ3hzdGF0ZS5hc3NpZ24nO1xuICBhc3NpZ24uYXNzaWdubWVudCA9IGFzc2lnbm1lbnQ7XG4gIGFzc2lnbi5yZXNvbHZlID0gcmVzb2x2ZUFzc2lnbjtcbiAgcmV0dXJuIGFzc2lnbjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUVtaXQoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBldmVudDogZXZlbnRPckV4cHJcbn0pIHtcbiAgY29uc3QgcmVzb2x2ZWRFdmVudCA9IHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3JFeHByKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBldmVudE9yRXhwcjtcbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIGV2ZW50OiByZXNvbHZlZEV2ZW50XG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlRW1pdChhY3RvclNjb3BlLCB7XG4gIGV2ZW50XG59KSB7XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4gYWN0b3JTY29wZS5lbWl0KGV2ZW50KSk7XG59XG4vKipcbiAqIEVtaXRzIGFuIGV2ZW50IHRvIGV2ZW50IGhhbmRsZXJzIHJlZ2lzdGVyZWQgb24gdGhlIGFjdG9yIHZpYSBgYWN0b3Iub24oZXZlbnQsXG4gKiBoYW5kbGVyKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZW1pdCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb246IHtcbiAqICAgICBzb21ldGhpbmc6IHtcbiAqICAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICogICAgICAgICB0eXBlOiAnZW1pdHRlZCcsXG4gKiAgICAgICAgIHNvbWU6ICdkYXRhJ1xuICogICAgICAgfSlcbiAqICAgICB9XG4gKiAgIH1cbiAqICAgLy8gLi4uXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpLnN0YXJ0KCk7XG4gKlxuICogYWN0b3Iub24oJ2VtaXR0ZWQnLCAoZXZlbnQpID0+IHtcbiAqICAgY29uc29sZS5sb2coZXZlbnQpO1xuICogfSk7XG4gKlxuICogYWN0b3Iuc2VuZCh7IHR5cGU6ICdzb21ldGhpbmcnIH0pO1xuICogLy8gbG9nczpcbiAqIC8vIHtcbiAqIC8vICAgdHlwZTogJ2VtaXR0ZWQnLFxuICogLy8gICBzb21lOiAnZGF0YSdcbiAqIC8vIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBlbWl0KC8qKiBUaGUgZXZlbnQgdG8gZW1pdCwgb3IgYW4gZXhwcmVzc2lvbiB0aGF0IHJldHVybnMgYW4gZXZlbnQgdG8gZW1pdC4gKi9cbmV2ZW50T3JFeHByKSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgZW1pdCgpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBlbWl0LnR5cGUgPSAneHN0YXRlLmVtaXQnO1xuICBlbWl0LmV2ZW50ID0gZXZlbnRPckV4cHI7XG4gIGVtaXQucmVzb2x2ZSA9IHJlc29sdmVFbWl0O1xuICBlbWl0LmV4ZWN1dGUgPSBleGVjdXRlRW1pdDtcbiAgcmV0dXJuIGVtaXQ7XG59XG5cbi8vIHRoaXMgaXMgbmVlZGVkIHRvIG1ha2UgSlNEb2MgYEBsaW5rYCB3b3JrIHByb3Blcmx5XG5cbi8qKlxuICogQHJlbWFya3NcbiAqIGBUIHwgdW5rbm93bmAgcmVkdWNlcyB0byBgdW5rbm93bmAgYW5kIHRoYXQgY2FuIGJlIHByb2JsZW1hdGljIHdoZW4gaXQgY29tZXNcbiAqIHRvIGNvbnRleHR1YWwgdHlwaW5nLiBJdCBlc3BlY2lhbGx5IGlzIGEgcHJvYmxlbSB3aGVuIHRoZSB1bmlvbiBoYXMgYVxuICogZnVuY3Rpb24gbWVtYmVyLCBsaWtlIGhlcmU6XG4gKlxuICogYGBgdHNcbiAqIGRlY2xhcmUgZnVuY3Rpb24gdGVzdChcbiAqICAgY2JPclZhbDogKChhcmc6IG51bWJlcikgPT4gdW5rbm93bikgfCB1bmtub3duXG4gKiApOiB2b2lkO1xuICogdGVzdCgoYXJnKSA9PiB7fSk7IC8vIG9vcHMsIGltcGxpY2l0IGFueVxuICogYGBgXG4gKlxuICogVGhpcyB0eXBlIGNhbiBiZSB1c2VkIHRvIGF2b2lkIHRoaXMgcHJvYmxlbS4gVGhpcyB1bmlvbiByZXByZXNlbnRzIHRoZSBzYW1lXG4gKiB2YWx1ZSBzcGFjZSBhcyBgdW5rbm93bmAuXG4gKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yMzE4MiNpc3N1ZWNvbW1lbnQtMzc5MDkxODg3XG5cbi8vIEBUT0RPOiB3ZSBjYW4ndCB1c2UgbmF0aXZlIGBOb0luZmVyYCBhcyB3ZSBuZWVkIHRob3NlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNjEwOTJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzYxMDc3XG4vLyBidXQgZXZlbiB3aXRoIHRob3NlIGZpeGVzIG5hdGl2ZSBOb0luZmVyIHN0aWxsIGRvZXNuJ3Qgd29yayAtIGZ1cnRoZXIgaXNzdWVzIGhhdmUgdG8gYmUgcmVwcm9kdWNlZCBhbmQgZml4ZWRcblxuLyoqIEBkZXByZWNhdGVkIFVzZSB0aGUgYnVpbHQtaW4gYE5vSW5mZXJgIHR5cGUgaW5zdGVhZCAqL1xuXG4vKiogVGhlIGZ1bGwgZGVmaW5pdGlvbiBvZiBhbiBldmVudCwgd2l0aCBhIHN0cmluZyBgdHlwZWAuICovXG5cbi8qKlxuICogVGhlIHN0cmluZyBvciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSB2YWx1ZSByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gKiBzdGF0ZSBub2RlLlxuICpcbiAqIEByZW1hcmtzXG4gKiAtIEZvciBhIGNoaWxkIGF0b21pYyBzdGF0ZSBub2RlLCB0aGlzIGlzIGEgc3RyaW5nLCBlLmcuLCBgXCJwZW5kaW5nXCJgLlxuICogLSBGb3IgY29tcGxleCBzdGF0ZSBub2RlcywgdGhpcyBpcyBhbiBvYmplY3QsIGUuZy4sIGB7IHN1Y2Nlc3M6XG4gKiAgIFwic29tZUNoaWxkU3RhdGVcIiB9YC5cbiAqL1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBBbnlNYWNoaW5lU25hcHNob3RgIGluc3RlYWQgKi9cblxuLy8gVE9ETzogcG9zc2libHkgcmVmYWN0b3IgdGhpcyBzb21laG93LCB1c2UgZXZlbiBhIHNpbXBsZXIgdHlwZSwgYW5kIG1heWJlIGV2ZW4gbWFrZSBgbWFjaGluZS5vcHRpb25zYCBwcml2YXRlIG9yIHNvbWV0aGluZ1xuLyoqIEBpZ25vcmUgKi9cblxubGV0IFNwZWNpYWxUYXJnZXRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChTcGVjaWFsVGFyZ2V0cykge1xuICBTcGVjaWFsVGFyZ2V0c1tcIlBhcmVudFwiXSA9IFwiI19wYXJlbnRcIjtcbiAgU3BlY2lhbFRhcmdldHNbXCJJbnRlcm5hbFwiXSA9IFwiI19pbnRlcm5hbFwiO1xuICByZXR1cm4gU3BlY2lhbFRhcmdldHM7XG59KHt9KTtcblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgQW55QWN0b3JgIGluc3RlYWQuICovXG5cbi8vIEJhc2VkIG9uIFJ4SlMgdHlwZXNcblxuLy8gVE9ETzogaW4gdjYsIHRoaXMgc2hvdWxkIG9ubHkgYWNjZXB0IEFueUFjdG9yTG9naWMsIGxpa2UgQWN0b3JSZWZGcm9tTG9naWNcblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgQWN0b3I8VD5gIGluc3RlYWQuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBsb2dpYyB3aGljaCBjYW4gYmUgdXNlZCBieSBhbiBhY3Rvci5cbiAqXG4gKiBAdGVtcGxhdGUgVFNuYXBzaG90IC0gVGhlIHR5cGUgb2YgdGhlIHNuYXBzaG90LlxuICogQHRlbXBsYXRlIFRFdmVudCAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCBvYmplY3QuXG4gKiBAdGVtcGxhdGUgVElucHV0IC0gVGhlIHR5cGUgb2YgdGhlIGlucHV0LlxuICogQHRlbXBsYXRlIFRTeXN0ZW0gLSBUaGUgdHlwZSBvZiB0aGUgYWN0b3Igc3lzdGVtLlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuXG4vLyBUT0RPOiBjb3ZlciBhbGwgdGhhdCBjYW4gYmUgYWN0dWFsbHkgcmV0dXJuZWRcblxuZnVuY3Rpb24gcmVzb2x2ZVNlbmRUbyhhY3RvclNjb3BlLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIHRvLFxuICBldmVudDogZXZlbnRPckV4cHIsXG4gIGlkLFxuICBkZWxheVxufSwgZXh0cmEpIHtcbiAgY29uc3QgZGVsYXlzTWFwID0gc25hcHNob3QubWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuZGVsYXlzO1xuICBpZiAodHlwZW9mIGV2ZW50T3JFeHByID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgYE9ubHkgZXZlbnQgb2JqZWN0cyBtYXkgYmUgdXNlZCB3aXRoIHNlbmRUbzsgdXNlIHNlbmRUbyh7IHR5cGU6IFwiJHtldmVudE9yRXhwcn1cIiB9KSBpbnN0ZWFkYCk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRFdmVudCA9IHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3JFeHByKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBldmVudE9yRXhwcjtcbiAgbGV0IHJlc29sdmVkRGVsYXk7XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY29uZmlnRGVsYXkgPSBkZWxheXNNYXAgJiYgZGVsYXlzTWFwW2RlbGF5XTtcbiAgICByZXNvbHZlZERlbGF5ID0gdHlwZW9mIGNvbmZpZ0RlbGF5ID09PSAnZnVuY3Rpb24nID8gY29uZmlnRGVsYXkoYXJncywgYWN0aW9uUGFyYW1zKSA6IGNvbmZpZ0RlbGF5O1xuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgZGVsYXkgPT09ICdmdW5jdGlvbicgPyBkZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogZGVsYXk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSB0eXBlb2YgdG8gPT09ICdmdW5jdGlvbicgPyB0byhhcmdzLCBhY3Rpb25QYXJhbXMpIDogdG87XG4gIGxldCB0YXJnZXRBY3RvclJlZjtcbiAgaWYgKHR5cGVvZiByZXNvbHZlZFRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICBpZiAocmVzb2x2ZWRUYXJnZXQgPT09IFNwZWNpYWxUYXJnZXRzLlBhcmVudCkge1xuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBhY3RvclNjb3BlLnNlbGYuX3BhcmVudDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgZWxzZSBpZiAocmVzb2x2ZWRUYXJnZXQgPT09IFNwZWNpYWxUYXJnZXRzLkludGVybmFsKSB7XG4gICAgICB0YXJnZXRBY3RvclJlZiA9IGFjdG9yU2NvcGUuc2VsZjtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkVGFyZ2V0LnN0YXJ0c1dpdGgoJyNfJykpIHtcbiAgICAgIC8vIFNDWE1MIGNvbXBhdGliaWxpdHk6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jU0NYTUxFdmVudFByb2Nlc3NvclxuICAgICAgLy8gI19pbnZva2VpZC4gSWYgdGhlIHRhcmdldCBpcyB0aGUgc3BlY2lhbCB0ZXJtICcjX2ludm9rZWlkJywgd2hlcmUgaW52b2tlaWQgaXMgdGhlIGludm9rZWlkIG9mIGFuIFNDWE1MIHNlc3Npb24gdGhhdCB0aGUgc2VuZGluZyBzZXNzaW9uIGhhcyBjcmVhdGVkIGJ5IDxpbnZva2U+LCB0aGUgUHJvY2Vzc29yIG11c3QgYWRkIHRoZSBldmVudCB0byB0aGUgZXh0ZXJuYWwgcXVldWUgb2YgdGhhdCBzZXNzaW9uLlxuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBzbmFwc2hvdC5jaGlsZHJlbltyZXNvbHZlZFRhcmdldC5zbGljZSgyKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEFjdG9yUmVmID0gZXh0cmEuZGVmZXJyZWRBY3Rvcklkcz8uaW5jbHVkZXMocmVzb2x2ZWRUYXJnZXQpID8gcmVzb2x2ZWRUYXJnZXQgOiBzbmFwc2hvdC5jaGlsZHJlbltyZXNvbHZlZFRhcmdldF07XG4gICAgfVxuICAgIGlmICghdGFyZ2V0QWN0b3JSZWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHNlbmQgZXZlbnQgdG8gYWN0b3IgJyR7cmVzb2x2ZWRUYXJnZXR9JyBmcm9tIG1hY2hpbmUgJyR7c25hcHNob3QubWFjaGluZS5pZH0nLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRBY3RvclJlZiA9IHJlc29sdmVkVGFyZ2V0IHx8IGFjdG9yU2NvcGUuc2VsZjtcbiAgfVxuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgdG86IHRhcmdldEFjdG9yUmVmLFxuICAgIHRhcmdldElkOiB0eXBlb2YgcmVzb2x2ZWRUYXJnZXQgPT09ICdzdHJpbmcnID8gcmVzb2x2ZWRUYXJnZXQgOiB1bmRlZmluZWQsXG4gICAgZXZlbnQ6IHJlc29sdmVkRXZlbnQsXG4gICAgaWQsXG4gICAgZGVsYXk6IHJlc29sdmVkRGVsYXlcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIHJldHJ5UmVzb2x2ZVNlbmRUbyhfLCBzbmFwc2hvdCwgcGFyYW1zKSB7XG4gIGlmICh0eXBlb2YgcGFyYW1zLnRvID09PSAnc3RyaW5nJykge1xuICAgIHBhcmFtcy50byA9IHNuYXBzaG90LmNoaWxkcmVuW3BhcmFtcy50b107XG4gIH1cbn1cbmZ1bmN0aW9uIGV4ZWN1dGVTZW5kVG8oYWN0b3JTY29wZSwgcGFyYW1zKSB7XG4gIC8vIHRoaXMgZm9ybXMgYW4gb3V0Z29pbmcgZXZlbnRzIHF1ZXVlXG4gIC8vIHRoYW5rcyB0byB0aGF0IHRoZSByZWNpcGllbnQgYWN0b3JzIGFyZSBhYmxlIHRvIHJlYWQgdGhlICp1cGRhdGVkKiBzbmFwc2hvdCB2YWx1ZSBvZiB0aGUgc2VuZGVyXG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvLFxuICAgICAgZXZlbnQsXG4gICAgICBkZWxheSxcbiAgICAgIGlkXG4gICAgfSA9IHBhcmFtcztcbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgYWN0b3JTY29wZS5zeXN0ZW0uc2NoZWR1bGVyLnNjaGVkdWxlKGFjdG9yU2NvcGUuc2VsZiwgdG8sIGV2ZW50LCBkZWxheSwgaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RvclNjb3BlLnN5c3RlbS5fcmVsYXkoYWN0b3JTY29wZS5zZWxmLFxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGluIGEgZGVmZXJyZWQgdGFzaywgaXQgc2hvdWxkIGFscmVhZHkgYmUgbXV0YXRlZCBieSByZXRyeVJlc29sdmVTZW5kVG9cbiAgICAvLyBpZiBpdCBpbml0aWFsbHkgc3RhcnRlZCBhcyBhIHN0cmluZ1xuICAgIHRvLCBldmVudC50eXBlID09PSBYU1RBVEVfRVJST1IgPyBjcmVhdGVFcnJvckFjdG9yRXZlbnQoYWN0b3JTY29wZS5zZWxmLmlkLCBldmVudC5kYXRhKSA6IGV2ZW50KTtcbiAgfSk7XG59XG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHRvIGFuIGFjdG9yLlxuICpcbiAqIEBwYXJhbSBhY3RvciBUaGUgYEFjdG9yUmVmYCB0byBzZW5kIHRoZSBldmVudCB0by5cbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZCwgb3IgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byB0aGUgZXZlbnRcbiAqICAgdG8gc2VuZFxuICogQHBhcmFtIG9wdGlvbnMgU2VuZCBhY3Rpb24gb3B0aW9uc1xuICpcbiAqICAgLSBgaWRgIC0gVGhlIHVuaXF1ZSBzZW5kIGV2ZW50IGlkZW50aWZpZXIgKHVzZWQgd2l0aCBgY2FuY2VsKClgKS5cbiAqICAgLSBgZGVsYXlgIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgdGhlIHNlbmRpbmcgb2YgdGhlIGV2ZW50LlxuICovXG5mdW5jdGlvbiBzZW5kVG8odG8sIGV2ZW50T3JFeHByLCBvcHRpb25zKSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgc2VuZFRvKClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbmRUbyhfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgc2VuZFRvLnR5cGUgPSAneHN0YXRlLnNlbmRUbyc7XG4gIHNlbmRUby50byA9IHRvO1xuICBzZW5kVG8uZXZlbnQgPSBldmVudE9yRXhwcjtcbiAgc2VuZFRvLmlkID0gb3B0aW9ucz8uaWQ7XG4gIHNlbmRUby5kZWxheSA9IG9wdGlvbnM/LmRlbGF5O1xuICBzZW5kVG8ucmVzb2x2ZSA9IHJlc29sdmVTZW5kVG87XG4gIHNlbmRUby5yZXRyeVJlc29sdmUgPSByZXRyeVJlc29sdmVTZW5kVG87XG4gIHNlbmRUby5leGVjdXRlID0gZXhlY3V0ZVNlbmRUbztcbiAgcmV0dXJuIHNlbmRUbztcbn1cblxuLyoqXG4gKiBTZW5kcyBhbiBldmVudCB0byB0aGlzIG1hY2hpbmUncyBwYXJlbnQuXG4gKlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kIHRvIHRoZSBwYXJlbnQgbWFjaGluZS5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBzZW5kIGV2ZW50LlxuICovXG5mdW5jdGlvbiBzZW5kUGFyZW50KGV2ZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBzZW5kVG8oU3BlY2lhbFRhcmdldHMuUGFyZW50LCBldmVudCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEZvcndhcmRzIChzZW5kcykgYW4gZXZlbnQgdG8gdGhlIGB0YXJnZXRgIGFjdG9yLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBhY3RvciB0byBmb3J3YXJkIHRoZSBldmVudCB0by5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBzZW5kIGFjdGlvbiBjcmVhdG9yLlxuICovXG5mdW5jdGlvbiBmb3J3YXJkVG8odGFyZ2V0LCBvcHRpb25zKSB7XG4gIGlmICgoIXRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNvbnN0IG9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRhcmdldCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiBvcmlnaW5hbFRhcmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG9yaWdpbmFsVGFyZ2V0KC4uLmFyZ3MpIDogb3JpZ2luYWxUYXJnZXQ7XG4gICAgICBpZiAoIXJlc29sdmVkVGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGZvcndhcmQgZXZlbnQgdG8gdW5kZWZpbmVkIGFjdG9yLiBUaGlzIHJpc2tzIGFuIGluZmluaXRlIGxvb3AgaW4gdGhlIHNlbmRlci5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlZFRhcmdldDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZW5kVG8odGFyZ2V0LCAoe1xuICAgIGV2ZW50XG4gIH0pID0+IGV2ZW50LCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUVucXVldWVBY3Rpb25zKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgY29sbGVjdFxufSkge1xuICBjb25zdCBhY3Rpb25zID0gW107XG4gIGNvbnN0IGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGFjdGlvbikge1xuICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBlbnF1ZXVlLmFzc2lnbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKGFzc2lnbiguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuY2FuY2VsID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goY2FuY2VsKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5yYWlzZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gZm9yIHNvbWUgcmVhc29uIGl0IGZhaWxzIHRvIGluZmVyIGBURGVsYXlgIGZyb20gYC4uLmFyZ3NgIGhlcmUgYW5kIHBpY2tzIGl0cyBkZWZhdWx0IChgbmV2ZXJgKVxuICAgIC8vIHRoZW4gaXQgZmFpbHMgdG8gdHlwZWNoZWNrIHRoYXQgYmVjYXVzZSBgLi4uYXJnc2AgdXNlIGBzdHJpbmdgIGluIHBsYWNlIG9mIGBURGVsYXlgXG4gICAgYWN0aW9ucy5wdXNoKHJhaXNlKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zZW5kVG8gPSAoLi4uYXJncykgPT4ge1xuICAgIC8vIGZvciBzb21lIHJlYXNvbiBpdCBmYWlscyB0byBpbmZlciBgVERlbGF5YCBmcm9tIGAuLi5hcmdzYCBoZXJlIGFuZCBwaWNrcyBpdHMgZGVmYXVsdCAoYG5ldmVyYClcbiAgICAvLyB0aGVuIGl0IGZhaWxzIHRvIHR5cGVjaGVjayB0aGF0IGJlY2F1c2UgYC4uLmFyZ3NgIHVzZSBgc3RyaW5nYCBpbiBwbGFjZSBvZiBgVERlbGF5XG4gICAgYWN0aW9ucy5wdXNoKHNlbmRUbyguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuc2VuZFBhcmVudCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHNlbmRQYXJlbnQoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnNwYXduQ2hpbGQgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChzcGF3bkNoaWxkKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zdG9wQ2hpbGQgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChzdG9wQ2hpbGQoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLmVtaXQgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChlbWl0KC4uLmFyZ3MpKTtcbiAgfTtcbiAgY29sbGVjdCh7XG4gICAgY29udGV4dDogYXJncy5jb250ZXh0LFxuICAgIGV2ZW50OiBhcmdzLmV2ZW50LFxuICAgIGVucXVldWUsXG4gICAgY2hlY2s6IGd1YXJkID0+IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIHNuYXBzaG90LmNvbnRleHQsIGFyZ3MuZXZlbnQsIHNuYXBzaG90KSxcbiAgICBzZWxmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgc3lzdGVtOiBhY3RvclNjb3BlLnN5c3RlbVxuICB9LCBhY3Rpb25QYXJhbXMpO1xuICByZXR1cm4gW3NuYXBzaG90LCB1bmRlZmluZWQsIGFjdGlvbnNdO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFjdGlvbiBvYmplY3QgdGhhdCB3aWxsIGV4ZWN1dGUgYWN0aW9ucyB0aGF0IGFyZSBxdWV1ZWQgYnkgdGhlXG4gKiBgZW5xdWV1ZShhY3Rpb24pYCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBlbnF1ZXVlQWN0aW9ucyB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICBlbnRyeTogZW5xdWV1ZUFjdGlvbnMoKHsgZW5xdWV1ZSwgY2hlY2sgfSkgPT4ge1xuICogICAgIGVucXVldWUuYXNzaWduKHsgY291bnQ6IDAgfSk7XG4gKlxuICogICAgIGlmIChjaGVjaygnc29tZUd1YXJkJykpIHtcbiAqICAgICAgIGVucXVldWUuYXNzaWduKHsgY291bnQ6IDEgfSk7XG4gKiAgICAgfVxuICpcbiAqICAgICBlbnF1ZXVlKCdzb21lQWN0aW9uJyk7XG4gKiAgIH0pXG4gKiB9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlQWN0aW9ucyhjb2xsZWN0KSB7XG4gIGZ1bmN0aW9uIGVucXVldWVBY3Rpb25zKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBlbnF1ZXVlQWN0aW9ucy50eXBlID0gJ3hzdGF0ZS5lbnF1ZXVlQWN0aW9ucyc7XG4gIGVucXVldWVBY3Rpb25zLmNvbGxlY3QgPSBjb2xsZWN0O1xuICBlbnF1ZXVlQWN0aW9ucy5yZXNvbHZlID0gcmVzb2x2ZUVucXVldWVBY3Rpb25zO1xuICByZXR1cm4gZW5xdWV1ZUFjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVMb2coXywgc25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywge1xuICB2YWx1ZSxcbiAgbGFiZWxcbn0pIHtcbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIHZhbHVlOiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMpIDogdmFsdWUsXG4gICAgbGFiZWxcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVMb2coe1xuICBsb2dnZXJcbn0sIHtcbiAgdmFsdWUsXG4gIGxhYmVsXG59KSB7XG4gIGlmIChsYWJlbCkge1xuICAgIGxvZ2dlcihsYWJlbCwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlcih2YWx1ZSk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIGV4cHIgVGhlIGV4cHJlc3Npb24gZnVuY3Rpb24gdG8gZXZhbHVhdGUgd2hpY2ggd2lsbCBiZSBsb2dnZWQuIFRha2VzXG4gKiAgIGluIDIgYXJndW1lbnRzOlxuICpcbiAqICAgLSBgY3R4YCAtIHRoZSBjdXJyZW50IHN0YXRlIGNvbnRleHRcbiAqICAgLSBgZXZlbnRgIC0gdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICpcbiAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgdG8gZ2l2ZSB0byB0aGUgbG9nZ2VkIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIGxvZyh2YWx1ZSA9ICh7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59KSA9PiAoe1xuICBjb250ZXh0LFxuICBldmVudFxufSksIGxhYmVsKSB7XG4gIGZ1bmN0aW9uIGxvZyhfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgbG9nLnR5cGUgPSAneHN0YXRlLmxvZyc7XG4gIGxvZy52YWx1ZSA9IHZhbHVlO1xuICBsb2cubGFiZWwgPSBsYWJlbDtcbiAgbG9nLnJlc29sdmUgPSByZXNvbHZlTG9nO1xuICBsb2cuZXhlY3V0ZSA9IGV4ZWN1dGVMb2c7XG4gIHJldHVybiBsb2c7XG59XG5cbmV4cG9ydCB7IFNwZWNpYWxUYXJnZXRzIGFzIFMsIGFzc2lnbiBhcyBhLCBlbnF1ZXVlQWN0aW9ucyBhcyBiLCBzZW5kVG8gYXMgYywgZW1pdCBhcyBlLCBmb3J3YXJkVG8gYXMgZiwgbG9nIGFzIGwsIHNlbmRQYXJlbnQgYXMgcyB9O1xuIl0sIm5hbWVzIjpbIlQiLCJQcm9jZXNzaW5nU3RhdHVzIiwieiIsInJlc29sdmVSZWZlcmVuY2VkQWN0b3IiLCJBIiwiY3JlYXRlQWN0b3IiLCJVIiwiY2xvbmVNYWNoaW5lU25hcHNob3QiLCJWIiwiZXhlY3V0aW5nQ3VzdG9tQWN0aW9uIiwiVyIsIlhTVEFURV9FUlJPUiIsIlkiLCJjcmVhdGVFcnJvckFjdG9yRXZlbnQiLCJlIiwiZXZhbHVhdGVHdWFyZCIsIk0iLCJjYW5jZWwiLCJPIiwicmFpc2UiLCJQIiwic3Bhd25DaGlsZCIsIlIiLCJzdG9wQ2hpbGQiLCJjcmVhdGVTcGF3bmVyIiwiYWN0b3JTY29wZSIsIm1hY2hpbmUiLCJjb250ZXh0IiwiZXZlbnQiLCJzcGF3bmVkQ2hpbGRyZW4iLCJzcGF3biIsInNyYyIsIm9wdGlvbnMiLCJsb2dpYyIsIkVycm9yIiwiaWQiLCJhY3RvclJlZiIsInBhcmVudCIsInNlbGYiLCJzeW5jU25hcHNob3QiLCJpbnB1dCIsInN5c3RlbUlkIiwiZGVmZXIiLCJfcHJvY2Vzc2luZ1N0YXR1cyIsIlN0b3BwZWQiLCJzdGFydCIsInJlc29sdmVBc3NpZ24iLCJzbmFwc2hvdCIsImFjdGlvbkFyZ3MiLCJhY3Rpb25QYXJhbXMiLCJhc3NpZ25tZW50IiwiYXNzaWduQXJncyIsInN5c3RlbSIsInBhcnRpYWxVcGRhdGUiLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwicHJvcEFzc2lnbm1lbnQiLCJ1cGRhdGVkQ29udGV4dCIsImFzc2lnbiIsImNoaWxkcmVuIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiY29uc29sZSIsIndhcm4iLCJfYXJncyIsIl9wYXJhbXMiLCJ0eXBlIiwicmVzb2x2ZSIsInJlc29sdmVFbWl0IiwiXyIsImFyZ3MiLCJldmVudE9yRXhwciIsInJlc29sdmVkRXZlbnQiLCJleGVjdXRlRW1pdCIsImVtaXQiLCJleGVjdXRlIiwiU3BlY2lhbFRhcmdldHMiLCJyZXNvbHZlU2VuZFRvIiwidG8iLCJkZWxheSIsImV4dHJhIiwiZGVsYXlzTWFwIiwiaW1wbGVtZW50YXRpb25zIiwiZGVsYXlzIiwicmVzb2x2ZWREZWxheSIsImNvbmZpZ0RlbGF5IiwicmVzb2x2ZWRUYXJnZXQiLCJ0YXJnZXRBY3RvclJlZiIsIlBhcmVudCIsIl9wYXJlbnQiLCJJbnRlcm5hbCIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImRlZmVycmVkQWN0b3JJZHMiLCJpbmNsdWRlcyIsInRhcmdldElkIiwicmV0cnlSZXNvbHZlU2VuZFRvIiwicGFyYW1zIiwiZXhlY3V0ZVNlbmRUbyIsInNjaGVkdWxlciIsInNjaGVkdWxlIiwiX3JlbGF5IiwiZGF0YSIsInNlbmRUbyIsInJldHJ5UmVzb2x2ZSIsInNlbmRQYXJlbnQiLCJmb3J3YXJkVG8iLCJ0YXJnZXQiLCJvcmlnaW5hbFRhcmdldCIsInJlc29sdmVFbnF1ZXVlQWN0aW9ucyIsImNvbGxlY3QiLCJhY3Rpb25zIiwiZW5xdWV1ZSIsImFjdGlvbiIsInB1c2giLCJjaGVjayIsImd1YXJkIiwiZW5xdWV1ZUFjdGlvbnMiLCJyZXNvbHZlTG9nIiwidmFsdWUiLCJsYWJlbCIsImV4ZWN1dGVMb2ciLCJsb2dnZXIiLCJsb2ciLCJTIiwiYSIsImIiLCJjIiwiZiIsImwiLCJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/log-5a7b5528.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/raise-59549771.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dist/raise-59549771.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ $$ACTOR_TYPE),\n/* harmony export */   A: () => (/* binding */ createActor),\n/* harmony export */   B: () => (/* binding */ Actor),\n/* harmony export */   C: () => (/* binding */ interpret),\n/* harmony export */   D: () => (/* binding */ and),\n/* harmony export */   E: () => (/* binding */ not),\n/* harmony export */   F: () => (/* binding */ or),\n/* harmony export */   G: () => (/* binding */ stateIn),\n/* harmony export */   H: () => (/* binding */ isMachineSnapshot),\n/* harmony export */   I: () => (/* binding */ getAllOwnEventDescriptors),\n/* harmony export */   J: () => (/* binding */ matchesState),\n/* harmony export */   K: () => (/* binding */ pathToStateValue),\n/* harmony export */   L: () => (/* binding */ toObserver),\n/* harmony export */   M: () => (/* binding */ cancel),\n/* harmony export */   N: () => (/* binding */ NULL_EVENT),\n/* harmony export */   O: () => (/* binding */ raise),\n/* harmony export */   P: () => (/* binding */ spawnChild),\n/* harmony export */   Q: () => (/* binding */ stop),\n/* harmony export */   R: () => (/* binding */ stopChild),\n/* harmony export */   S: () => (/* binding */ STATE_DELIMITER),\n/* harmony export */   T: () => (/* binding */ ProcessingStatus),\n/* harmony export */   U: () => (/* binding */ cloneMachineSnapshot),\n/* harmony export */   V: () => (/* binding */ executingCustomAction),\n/* harmony export */   W: () => (/* binding */ XSTATE_ERROR),\n/* harmony export */   X: () => (/* binding */ XSTATE_STOP),\n/* harmony export */   Y: () => (/* binding */ createErrorActorEvent),\n/* harmony export */   a: () => (/* binding */ toTransitionConfigArray),\n/* harmony export */   b: () => (/* binding */ formatTransition),\n/* harmony export */   c: () => (/* binding */ createInvokeId),\n/* harmony export */   d: () => (/* binding */ formatInitialTransition),\n/* harmony export */   e: () => (/* binding */ evaluateGuard),\n/* harmony export */   f: () => (/* binding */ formatTransitions),\n/* harmony export */   g: () => (/* binding */ getDelayedTransitions),\n/* harmony export */   h: () => (/* binding */ getCandidates),\n/* harmony export */   i: () => (/* binding */ getAllStateNodes),\n/* harmony export */   j: () => (/* binding */ getStateNodes),\n/* harmony export */   k: () => (/* binding */ createMachineSnapshot),\n/* harmony export */   l: () => (/* binding */ isInFinalState),\n/* harmony export */   m: () => (/* binding */ mapValues),\n/* harmony export */   n: () => (/* binding */ macrostep),\n/* harmony export */   o: () => (/* binding */ transitionNode),\n/* harmony export */   p: () => (/* binding */ resolveActionsAndContext),\n/* harmony export */   q: () => (/* binding */ createInitEvent),\n/* harmony export */   r: () => (/* binding */ resolveStateValue),\n/* harmony export */   s: () => (/* binding */ microstep),\n/* harmony export */   t: () => (/* binding */ toArray),\n/* harmony export */   u: () => (/* binding */ getInitialStateNodes),\n/* harmony export */   v: () => (/* binding */ toStatePath),\n/* harmony export */   w: () => (/* binding */ isStateId),\n/* harmony export */   x: () => (/* binding */ getStateNodeByPath),\n/* harmony export */   y: () => (/* binding */ getPersistedSnapshot),\n/* harmony export */   z: () => (/* binding */ resolveReferencedActor)\n/* harmony export */ });\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\nclass Mailbox {\n    constructor(_process){\n        this._process = _process;\n        this._active = false;\n        this._current = null;\n        this._last = null;\n    }\n    start() {\n        this._active = true;\n        this.flush();\n    }\n    clear() {\n        // we can't set _current to null because we might be currently processing\n        // and enqueue following clear shouldn't start processing the enqueued item immediately\n        if (this._current) {\n            this._current.next = null;\n            this._last = this._current;\n        }\n    }\n    enqueue(event) {\n        const enqueued = {\n            value: event,\n            next: null\n        };\n        if (this._current) {\n            this._last.next = enqueued;\n            this._last = enqueued;\n            return;\n        }\n        this._current = enqueued;\n        this._last = enqueued;\n        if (this._active) {\n            this.flush();\n        }\n    }\n    flush() {\n        while(this._current){\n            // atm the given _process is responsible for implementing proper try/catch handling\n            // we assume here that this won't throw in a way that can affect this mailbox\n            const consumed = this._current;\n            this._process(consumed.value);\n            this._current = consumed.next;\n        }\n        this._last = null;\n    }\n}\nconst STATE_DELIMITER = \".\";\nconst TARGETLESS_KEY = \"\";\nconst NULL_EVENT = \"\";\nconst STATE_IDENTIFIER = \"#\";\nconst WILDCARD = \"*\";\nconst XSTATE_INIT = \"xstate.init\";\nconst XSTATE_ERROR = \"xstate.error\";\nconst XSTATE_STOP = \"xstate.stop\";\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */ function createAfterEvent(delayRef, id) {\n    return {\n        type: `xstate.after.${delayRef}.${id}`\n    };\n}\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */ function createDoneStateEvent(id, output) {\n    return {\n        type: `xstate.done.state.${id}`,\n        output\n    };\n}\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */ function createDoneActorEvent(invokeId, output) {\n    return {\n        type: `xstate.done.actor.${invokeId}`,\n        output,\n        actorId: invokeId\n    };\n}\nfunction createErrorActorEvent(id, error) {\n    return {\n        type: `xstate.error.actor.${id}`,\n        error,\n        actorId: id\n    };\n}\nfunction createInitEvent(input) {\n    return {\n        type: XSTATE_INIT,\n        input\n    };\n}\n/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */ function reportUnhandledError(err) {\n    setTimeout(()=>{\n        throw err;\n    });\n}\nconst symbolObservable = (()=>typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nfunction matchesState(parentStateId, childStateId) {\n    const parentStateValue = toStateValue(parentStateId);\n    const childStateValue = toStateValue(childStateId);\n    if (typeof childStateValue === \"string\") {\n        if (typeof parentStateValue === \"string\") {\n            return childStateValue === parentStateValue;\n        }\n        // Parent more specific than child\n        return false;\n    }\n    if (typeof parentStateValue === \"string\") {\n        return parentStateValue in childStateValue;\n    }\n    return Object.keys(parentStateValue).every((key)=>{\n        if (!(key in childStateValue)) {\n            return false;\n        }\n        return matchesState(parentStateValue[key], childStateValue[key]);\n    });\n}\nfunction toStatePath(stateId) {\n    if (isArray(stateId)) {\n        return stateId;\n    }\n    const result = [];\n    let segment = \"\";\n    for(let i = 0; i < stateId.length; i++){\n        const char = stateId.charCodeAt(i);\n        switch(char){\n            // \\\n            case 92:\n                // consume the next character\n                segment += stateId[i + 1];\n                // and skip over it\n                i++;\n                continue;\n            // .\n            case 46:\n                result.push(segment);\n                segment = \"\";\n                continue;\n        }\n        segment += stateId[i];\n    }\n    result.push(segment);\n    return result;\n}\nfunction toStateValue(stateValue) {\n    if (isMachineSnapshot(stateValue)) {\n        return stateValue.value;\n    }\n    if (typeof stateValue !== \"string\") {\n        return stateValue;\n    }\n    const statePath = toStatePath(stateValue);\n    return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n    if (statePath.length === 1) {\n        return statePath[0];\n    }\n    const value = {};\n    let marker = value;\n    for(let i = 0; i < statePath.length - 1; i++){\n        if (i === statePath.length - 2) {\n            marker[statePath[i]] = statePath[i + 1];\n        } else {\n            const previous = marker;\n            marker = {};\n            previous[statePath[i]] = marker;\n        }\n    }\n    return value;\n}\nfunction mapValues(collection, iteratee) {\n    const result = {};\n    const collectionKeys = Object.keys(collection);\n    for(let i = 0; i < collectionKeys.length; i++){\n        const key = collectionKeys[i];\n        result[key] = iteratee(collection[key], key, collection, i);\n    }\n    return result;\n}\nfunction toArrayStrict(value) {\n    if (isArray(value)) {\n        return value;\n    }\n    return [\n        value\n    ];\n}\nfunction toArray(value) {\n    if (value === undefined) {\n        return [];\n    }\n    return toArrayStrict(value);\n}\nfunction resolveOutput(mapper, context, event, self) {\n    if (typeof mapper === \"function\") {\n        return mapper({\n            context,\n            event,\n            self\n        });\n    }\n    if (!!mapper && typeof mapper === \"object\" && Object.values(mapper).some((val)=>typeof val === \"function\")) {\n        console.warn(`Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(mapper).filter(([, value])=>typeof value === \"function\").map(([key, value])=>`\\n - ${key}: ${value.toString().replace(/\\n\\s*/g, \"\")}`).join(\"\")}`);\n    }\n    return mapper;\n}\nfunction isArray(value) {\n    return Array.isArray(value);\n}\nfunction isErrorActorEvent(event) {\n    return event.type.startsWith(\"xstate.error.actor\");\n}\nfunction toTransitionConfigArray(configLike) {\n    return toArrayStrict(configLike).map((transitionLike)=>{\n        if (typeof transitionLike === \"undefined\" || typeof transitionLike === \"string\") {\n            return {\n                target: transitionLike\n            };\n        }\n        return transitionLike;\n    });\n}\nfunction normalizeTarget(target) {\n    if (target === undefined || target === TARGETLESS_KEY) {\n        return undefined;\n    }\n    return toArray(target);\n}\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n    const isObserver = typeof nextHandler === \"object\";\n    const self = isObserver ? nextHandler : undefined;\n    return {\n        next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n        error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n        complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)\n    };\n}\nfunction createInvokeId(stateNodeId, index) {\n    return `${index}.${stateNodeId}`;\n}\nfunction resolveReferencedActor(machine, src) {\n    const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/);\n    if (!match) {\n        return machine.implementations.actors[src];\n    }\n    const [, indexStr, nodeId] = match;\n    const node = machine.getStateNodeById(nodeId);\n    const invokeConfig = node.config.invoke;\n    return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;\n}\nfunction getAllOwnEventDescriptors(snapshot) {\n    return [\n        ...new Set([\n            ...snapshot._nodes.flatMap((sn)=>sn.ownEvents)\n        ])\n    ];\n}\nfunction createScheduledEventId(actorRef, id) {\n    return `${actorRef.sessionId}.${id}`;\n}\nlet idCounter = 0;\nfunction createSystem(rootActor, options) {\n    const children = new Map();\n    const keyedActors = new Map();\n    const reverseKeyedActors = new WeakMap();\n    const inspectionObservers = new Set();\n    const timerMap = {};\n    const { clock, logger } = options;\n    const scheduler = {\n        schedule: (source, target, event, delay, id = Math.random().toString(36).slice(2))=>{\n            const scheduledEvent = {\n                source,\n                target,\n                event,\n                delay,\n                id,\n                startedAt: Date.now()\n            };\n            const scheduledEventId = createScheduledEventId(source, id);\n            system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n            const timeout = clock.setTimeout(()=>{\n                delete timerMap[scheduledEventId];\n                delete system._snapshot._scheduledEvents[scheduledEventId];\n                system._relay(source, target, event);\n            }, delay);\n            timerMap[scheduledEventId] = timeout;\n        },\n        cancel: (source, id)=>{\n            const scheduledEventId = createScheduledEventId(source, id);\n            const timeout = timerMap[scheduledEventId];\n            delete timerMap[scheduledEventId];\n            delete system._snapshot._scheduledEvents[scheduledEventId];\n            if (timeout !== undefined) {\n                clock.clearTimeout(timeout);\n            }\n        },\n        cancelAll: (actorRef)=>{\n            for(const scheduledEventId in system._snapshot._scheduledEvents){\n                const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];\n                if (scheduledEvent.source === actorRef) {\n                    scheduler.cancel(actorRef, scheduledEvent.id);\n                }\n            }\n        }\n    };\n    const sendInspectionEvent = (event)=>{\n        if (!inspectionObservers.size) {\n            return;\n        }\n        const resolvedInspectionEvent = {\n            ...event,\n            rootId: rootActor.sessionId\n        };\n        inspectionObservers.forEach((observer)=>observer.next?.(resolvedInspectionEvent));\n    };\n    const system = {\n        _snapshot: {\n            _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}\n        },\n        _bookId: ()=>`x:${idCounter++}`,\n        _register: (sessionId, actorRef)=>{\n            children.set(sessionId, actorRef);\n            return sessionId;\n        },\n        _unregister: (actorRef)=>{\n            children.delete(actorRef.sessionId);\n            const systemId = reverseKeyedActors.get(actorRef);\n            if (systemId !== undefined) {\n                keyedActors.delete(systemId);\n                reverseKeyedActors.delete(actorRef);\n            }\n        },\n        get: (systemId)=>{\n            return keyedActors.get(systemId);\n        },\n        _set: (systemId, actorRef)=>{\n            const existing = keyedActors.get(systemId);\n            if (existing && existing !== actorRef) {\n                throw new Error(`Actor with system ID '${systemId}' already exists.`);\n            }\n            keyedActors.set(systemId, actorRef);\n            reverseKeyedActors.set(actorRef, systemId);\n        },\n        inspect: (observerOrFn)=>{\n            const observer = toObserver(observerOrFn);\n            inspectionObservers.add(observer);\n            return {\n                unsubscribe () {\n                    inspectionObservers.delete(observer);\n                }\n            };\n        },\n        _sendInspectionEvent: sendInspectionEvent,\n        _relay: (source, target, event)=>{\n            system._sendInspectionEvent({\n                type: \"@xstate.event\",\n                sourceRef: source,\n                actorRef: target,\n                event\n            });\n            target._send(event);\n        },\n        scheduler,\n        getSnapshot: ()=>{\n            return {\n                _scheduledEvents: {\n                    ...system._snapshot._scheduledEvents\n                }\n            };\n        },\n        start: ()=>{\n            const scheduledEvents = system._snapshot._scheduledEvents;\n            system._snapshot._scheduledEvents = {};\n            for(const scheduledId in scheduledEvents){\n                const { source, target, event, delay, id } = scheduledEvents[scheduledId];\n                scheduler.schedule(source, target, event, delay, id);\n            }\n        },\n        _clock: clock,\n        _logger: logger\n    };\n    return system;\n}\n// those are needed to make JSDoc `@link` work properly\nlet executingCustomAction = false;\nconst $$ACTOR_TYPE = 1;\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nlet ProcessingStatus = /*#__PURE__*/ function(ProcessingStatus) {\n    ProcessingStatus[ProcessingStatus[\"NotStarted\"] = 0] = \"NotStarted\";\n    ProcessingStatus[ProcessingStatus[\"Running\"] = 1] = \"Running\";\n    ProcessingStatus[ProcessingStatus[\"Stopped\"] = 2] = \"Stopped\";\n    return ProcessingStatus;\n}({});\nconst defaultOptions = {\n    clock: {\n        setTimeout: (fn, ms)=>{\n            return setTimeout(fn, ms);\n        },\n        clearTimeout: (id)=>{\n            return clearTimeout(id);\n        }\n    },\n    logger: console.log.bind(console),\n    devTools: false\n};\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */ class Actor {\n    /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */ constructor(logic, options){\n        this.logic = logic;\n        /** The current internal state of the actor. */ this._snapshot = void 0;\n        /**\n     * The clock that is responsible for setting and clearing timeouts, such as\n     * delayed events and transitions.\n     */ this.clock = void 0;\n        this.options = void 0;\n        /** The unique identifier for this actor relative to its parent. */ this.id = void 0;\n        this.mailbox = new Mailbox(this._process.bind(this));\n        this.observers = new Set();\n        this.eventListeners = new Map();\n        this.logger = void 0;\n        /** @internal */ this._processingStatus = ProcessingStatus.NotStarted;\n        // Actor Ref\n        this._parent = void 0;\n        /** @internal */ this._syncSnapshot = void 0;\n        this.ref = void 0;\n        // TODO: add typings for system\n        this._actorScope = void 0;\n        this._systemId = void 0;\n        /** The globally unique process ID for this invocation. */ this.sessionId = void 0;\n        /** The system to which this actor belongs. */ this.system = void 0;\n        this._doneEvent = void 0;\n        this.src = void 0;\n        // array of functions to defer\n        this._deferred = [];\n        const resolvedOptions = {\n            ...defaultOptions,\n            ...options\n        };\n        const { clock, logger, parent, syncSnapshot, id, systemId, inspect } = resolvedOptions;\n        this.system = parent ? parent.system : createSystem(this, {\n            clock,\n            logger\n        });\n        if (inspect && !parent) {\n            // Always inspect at the system-level\n            this.system.inspect(toObserver(inspect));\n        }\n        this.sessionId = this.system._bookId();\n        this.id = id ?? this.sessionId;\n        this.logger = options?.logger ?? this.system._logger;\n        this.clock = options?.clock ?? this.system._clock;\n        this._parent = parent;\n        this._syncSnapshot = syncSnapshot;\n        this.options = resolvedOptions;\n        this.src = resolvedOptions.src ?? logic;\n        this.ref = this;\n        this._actorScope = {\n            self: this,\n            id: this.id,\n            sessionId: this.sessionId,\n            logger: this.logger,\n            defer: (fn)=>{\n                this._deferred.push(fn);\n            },\n            system: this.system,\n            stopChild: (child)=>{\n                if (child._parent !== this) {\n                    throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);\n                }\n                child._stop();\n            },\n            emit: (emittedEvent)=>{\n                const listeners = this.eventListeners.get(emittedEvent.type);\n                const wildcardListener = this.eventListeners.get(\"*\");\n                if (!listeners && !wildcardListener) {\n                    return;\n                }\n                const allListeners = [\n                    ...listeners ? listeners.values() : [],\n                    ...wildcardListener ? wildcardListener.values() : []\n                ];\n                for (const handler of allListeners){\n                    handler(emittedEvent);\n                }\n            },\n            actionExecutor: (action)=>{\n                const exec = ()=>{\n                    this._actorScope.system._sendInspectionEvent({\n                        type: \"@xstate.action\",\n                        actorRef: this,\n                        action: {\n                            type: action.type,\n                            params: action.params\n                        }\n                    });\n                    if (!action.exec) {\n                        return;\n                    }\n                    const saveExecutingCustomAction = executingCustomAction;\n                    try {\n                        executingCustomAction = true;\n                        action.exec(action.info, action.params);\n                    } finally{\n                        executingCustomAction = saveExecutingCustomAction;\n                    }\n                };\n                if (this._processingStatus === ProcessingStatus.Running) {\n                    exec();\n                } else {\n                    this._deferred.push(exec);\n                }\n            }\n        };\n        // Ensure that the send method is bound to this Actor instance\n        // if destructured\n        this.send = this.send.bind(this);\n        this.system._sendInspectionEvent({\n            type: \"@xstate.actor\",\n            actorRef: this\n        });\n        if (systemId) {\n            this._systemId = systemId;\n            this.system._set(systemId, this);\n        }\n        this._initState(options?.snapshot ?? options?.state);\n        if (systemId && this._snapshot.status !== \"active\") {\n            this.system._unregister(this);\n        }\n    }\n    _initState(persistedState) {\n        try {\n            this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n        } catch (err) {\n            // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n            // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n            // so right now this is a lie of sorts\n            this._snapshot = {\n                status: \"error\",\n                output: undefined,\n                error: err\n            };\n        }\n    }\n    update(snapshot, event) {\n        // Update state\n        this._snapshot = snapshot;\n        // Execute deferred effects\n        let deferredFn;\n        while(deferredFn = this._deferred.shift()){\n            try {\n                deferredFn();\n            } catch (err) {\n                // this error can only be caught when executing *initial* actions\n                // it's the only time when we call actions provided by the user through those deferreds\n                // when the actor is already running we always execute them synchronously while transitioning\n                // no \"builtin deferred\" should actually throw an error since they are either safe\n                // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n                this._deferred.length = 0;\n                this._snapshot = {\n                    ...snapshot,\n                    status: \"error\",\n                    error: err\n                };\n            }\n        }\n        switch(this._snapshot.status){\n            case \"active\":\n                for (const observer of this.observers){\n                    try {\n                        observer.next?.(snapshot);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                }\n                break;\n            case \"done\":\n                // next observers are meant to be notified about done snapshots\n                // this can be seen as something that is different from how observable work\n                // but with observables `complete` callback is called without any arguments\n                // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n                // and the completion event as something that is separate,\n                // something that merely follows emitting that done snapshot\n                for (const observer of this.observers){\n                    try {\n                        observer.next?.(snapshot);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                }\n                this._stopProcedure();\n                this._complete();\n                this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);\n                if (this._parent) {\n                    this.system._relay(this, this._parent, this._doneEvent);\n                }\n                break;\n            case \"error\":\n                this._error(this._snapshot.error);\n                break;\n        }\n        this.system._sendInspectionEvent({\n            type: \"@xstate.snapshot\",\n            actorRef: this,\n            event,\n            snapshot\n        });\n    }\n    /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */ subscribe(nextListenerOrObserver, errorListener, completeListener) {\n        const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);\n        if (this._processingStatus !== ProcessingStatus.Stopped) {\n            this.observers.add(observer);\n        } else {\n            switch(this._snapshot.status){\n                case \"done\":\n                    try {\n                        observer.complete?.();\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                    break;\n                case \"error\":\n                    {\n                        const err = this._snapshot.error;\n                        if (!observer.error) {\n                            reportUnhandledError(err);\n                        } else {\n                            try {\n                                observer.error(err);\n                            } catch (err) {\n                                reportUnhandledError(err);\n                            }\n                        }\n                        break;\n                    }\n            }\n        }\n        return {\n            unsubscribe: ()=>{\n                this.observers.delete(observer);\n            }\n        };\n    }\n    on(type, handler) {\n        let listeners = this.eventListeners.get(type);\n        if (!listeners) {\n            listeners = new Set();\n            this.eventListeners.set(type, listeners);\n        }\n        const wrappedHandler = handler.bind(undefined);\n        listeners.add(wrappedHandler);\n        return {\n            unsubscribe: ()=>{\n                listeners.delete(wrappedHandler);\n            }\n        };\n    }\n    /** Starts the Actor from the initial state */ start() {\n        if (this._processingStatus === ProcessingStatus.Running) {\n            // Do not restart the service if it is already started\n            return this;\n        }\n        if (this._syncSnapshot) {\n            this.subscribe({\n                next: (snapshot)=>{\n                    if (snapshot.status === \"active\") {\n                        this.system._relay(this, this._parent, {\n                            type: `xstate.snapshot.${this.id}`,\n                            snapshot\n                        });\n                    }\n                },\n                error: ()=>{}\n            });\n        }\n        this.system._register(this.sessionId, this);\n        if (this._systemId) {\n            this.system._set(this._systemId, this);\n        }\n        this._processingStatus = ProcessingStatus.Running;\n        // TODO: this isn't correct when rehydrating\n        const initEvent = createInitEvent(this.options.input);\n        this.system._sendInspectionEvent({\n            type: \"@xstate.event\",\n            sourceRef: this._parent,\n            actorRef: this,\n            event: initEvent\n        });\n        const status = this._snapshot.status;\n        switch(status){\n            case \"done\":\n                // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n                // we still need to complete observers, flush deferreds etc\n                this.update(this._snapshot, initEvent);\n                // TODO: rethink cleanup of observers, mailbox, etc\n                return this;\n            case \"error\":\n                this._error(this._snapshot.error);\n                return this;\n        }\n        if (!this._parent) {\n            this.system.start();\n        }\n        if (this.logic.start) {\n            try {\n                this.logic.start(this._snapshot, this._actorScope);\n            } catch (err) {\n                this._snapshot = {\n                    ...this._snapshot,\n                    status: \"error\",\n                    error: err\n                };\n                this._error(err);\n                return this;\n            }\n        }\n        // TODO: this notifies all subscribers but usually this is redundant\n        // there is no real change happening here\n        // we need to rethink if this needs to be refactored\n        this.update(this._snapshot, initEvent);\n        if (this.options.devTools) {\n            this.attachDevTools();\n        }\n        this.mailbox.start();\n        return this;\n    }\n    _process(event) {\n        let nextState;\n        let caughtError;\n        try {\n            nextState = this.logic.transition(this._snapshot, event, this._actorScope);\n        } catch (err) {\n            // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n            caughtError = {\n                err\n            };\n        }\n        if (caughtError) {\n            const { err } = caughtError;\n            this._snapshot = {\n                ...this._snapshot,\n                status: \"error\",\n                error: err\n            };\n            this._error(err);\n            return;\n        }\n        this.update(nextState, event);\n        if (event.type === XSTATE_STOP) {\n            this._stopProcedure();\n            this._complete();\n        }\n    }\n    _stop() {\n        if (this._processingStatus === ProcessingStatus.Stopped) {\n            return this;\n        }\n        this.mailbox.clear();\n        if (this._processingStatus === ProcessingStatus.NotStarted) {\n            this._processingStatus = ProcessingStatus.Stopped;\n            return this;\n        }\n        this.mailbox.enqueue({\n            type: XSTATE_STOP\n        });\n        return this;\n    }\n    /** Stops the Actor and unsubscribe all listeners. */ stop() {\n        if (this._parent) {\n            throw new Error(\"A non-root actor cannot be stopped directly.\");\n        }\n        return this._stop();\n    }\n    _complete() {\n        for (const observer of this.observers){\n            try {\n                observer.complete?.();\n            } catch (err) {\n                reportUnhandledError(err);\n            }\n        }\n        this.observers.clear();\n    }\n    _reportError(err) {\n        if (!this.observers.size) {\n            if (!this._parent) {\n                reportUnhandledError(err);\n            }\n            return;\n        }\n        let reportError = false;\n        for (const observer of this.observers){\n            const errorListener = observer.error;\n            reportError ||= !errorListener;\n            try {\n                errorListener?.(err);\n            } catch (err2) {\n                reportUnhandledError(err2);\n            }\n        }\n        this.observers.clear();\n        if (reportError) {\n            reportUnhandledError(err);\n        }\n    }\n    _error(err) {\n        this._stopProcedure();\n        this._reportError(err);\n        if (this._parent) {\n            this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));\n        }\n    }\n    // TODO: atm children don't belong entirely to the actor so\n    // in a way - it's not even super aware of them\n    // so we can't stop them from here but we really should!\n    // right now, they are being stopped within the machine's transition\n    // but that could throw and leave us with \"orphaned\" active actors\n    _stopProcedure() {\n        if (this._processingStatus !== ProcessingStatus.Running) {\n            // Actor already stopped; do nothing\n            return this;\n        }\n        // Cancel all delayed events\n        this.system.scheduler.cancelAll(this);\n        // TODO: mailbox.reset\n        this.mailbox.clear();\n        // TODO: after `stop` we must prepare ourselves for receiving events again\n        // events sent *after* stop signal must be queued\n        // it seems like this should be the common behavior for all of our consumers\n        // so perhaps this should be unified somehow for all of them\n        this.mailbox = new Mailbox(this._process.bind(this));\n        this._processingStatus = ProcessingStatus.Stopped;\n        this.system._unregister(this);\n        return this;\n    }\n    /** @internal */ _send(event) {\n        if (this._processingStatus === ProcessingStatus.Stopped) {\n            // do nothing\n            {\n                const eventString = JSON.stringify(event);\n                console.warn(`Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`);\n            }\n            return;\n        }\n        this.mailbox.enqueue(event);\n    }\n    /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */ send(event) {\n        if (typeof event === \"string\") {\n            throw new Error(`Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`);\n        }\n        this.system._relay(undefined, this, event);\n    }\n    attachDevTools() {\n        const { devTools } = this.options;\n        if (devTools) {\n            const resolvedDevToolsAdapter = typeof devTools === \"function\" ? devTools : _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.devToolsAdapter;\n            resolvedDevToolsAdapter(this);\n        }\n    }\n    toJSON() {\n        return {\n            xstate$$type: $$ACTOR_TYPE,\n            id: this.id\n        };\n    }\n    /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */ getPersistedSnapshot(options) {\n        return this.logic.getPersistedSnapshot(this._snapshot, options);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n    /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */ getSnapshot() {\n        if (!this._snapshot) {\n            throw new Error(`Snapshot can't be read while the actor initializes itself`);\n        }\n        return this._snapshot;\n    }\n}\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */ function createActor(logic, ...[options]) {\n    return new Actor(logic, options);\n}\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */ const interpret = createActor;\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */ function resolveCancel(_, snapshot, actionArgs, actionParams, { sendId }) {\n    const resolvedSendId = typeof sendId === \"function\" ? sendId(actionArgs, actionParams) : sendId;\n    return [\n        snapshot,\n        {\n            sendId: resolvedSendId\n        },\n        undefined\n    ];\n}\nfunction executeCancel(actorScope, params) {\n    actorScope.defer(()=>{\n        actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n    });\n}\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */ function cancel(sendId) {\n    function cancel(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    cancel.type = \"xstate.cancel\";\n    cancel.sendId = sendId;\n    cancel.resolve = resolveCancel;\n    cancel.execute = executeCancel;\n    return cancel;\n}\nfunction resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, { id, systemId, src, input, syncSnapshot }) {\n    const logic = typeof src === \"string\" ? resolveReferencedActor(snapshot.machine, src) : src;\n    const resolvedId = typeof id === \"function\" ? id(actionArgs) : id;\n    let actorRef;\n    let resolvedInput = undefined;\n    if (logic) {\n        resolvedInput = typeof input === \"function\" ? input({\n            context: snapshot.context,\n            event: actionArgs.event,\n            self: actorScope.self\n        }) : input;\n        actorRef = createActor(logic, {\n            id: resolvedId,\n            src,\n            parent: actorScope.self,\n            syncSnapshot,\n            systemId,\n            input: resolvedInput\n        });\n    }\n    if (!actorRef) {\n        console.warn(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n        `Actor type '${src}' not found in machine '${actorScope.id}'.`);\n    }\n    return [\n        cloneMachineSnapshot(snapshot, {\n            children: {\n                ...snapshot.children,\n                [resolvedId]: actorRef\n            }\n        }),\n        {\n            id,\n            systemId,\n            actorRef,\n            src,\n            input: resolvedInput\n        },\n        undefined\n    ];\n}\nfunction executeSpawn(actorScope, { actorRef }) {\n    if (!actorRef) {\n        return;\n    }\n    actorScope.defer(()=>{\n        if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n            return;\n        }\n        actorRef.start();\n    });\n}\nfunction spawnChild(...[src, { id, systemId, input, syncSnapshot = false } = {}]) {\n    function spawnChild1(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    spawnChild1.type = \"xstate.spawnChild\";\n    spawnChild1.id = id;\n    spawnChild1.systemId = systemId;\n    spawnChild1.src = src;\n    spawnChild1.input = input;\n    spawnChild1.syncSnapshot = syncSnapshot;\n    spawnChild1.resolve = resolveSpawn;\n    spawnChild1.execute = executeSpawn;\n    return spawnChild1;\n}\nfunction resolveStop(_, snapshot, args, actionParams, { actorRef }) {\n    const actorRefOrString = typeof actorRef === \"function\" ? actorRef(args, actionParams) : actorRef;\n    const resolvedActorRef = typeof actorRefOrString === \"string\" ? snapshot.children[actorRefOrString] : actorRefOrString;\n    let children = snapshot.children;\n    if (resolvedActorRef) {\n        children = {\n            ...children\n        };\n        delete children[resolvedActorRef.id];\n    }\n    return [\n        cloneMachineSnapshot(snapshot, {\n            children\n        }),\n        resolvedActorRef,\n        undefined\n    ];\n}\nfunction executeStop(actorScope, actorRef) {\n    if (!actorRef) {\n        return;\n    }\n    // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n    // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n    // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n    actorScope.system._unregister(actorRef);\n    // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n    // this can happen, for example, when the invoking state is being exited immediately by an always transition\n    if (actorRef._processingStatus !== ProcessingStatus.Running) {\n        actorScope.stopChild(actorRef);\n        return;\n    }\n    // stopping a child enqueues a stop event in the child actor's mailbox\n    // we need for all of the already enqueued events to be processed before we stop the child\n    // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n    // and we don't want to ignore those events\n    actorScope.defer(()=>{\n        actorScope.stopChild(actorRef);\n    });\n}\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */ function stopChild(actorRef) {\n    function stop(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    stop.type = \"xstate.stopChild\";\n    stop.actorRef = actorRef;\n    stop.resolve = resolveStop;\n    stop.execute = executeStop;\n    return stop;\n}\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */ const stop = stopChild;\nfunction checkStateIn(snapshot, _, { stateValue }) {\n    if (typeof stateValue === \"string\" && isStateId(stateValue)) {\n        const target = snapshot.machine.getStateNodeById(stateValue);\n        return snapshot._nodes.some((sn)=>sn === target);\n    }\n    return snapshot.matches(stateValue);\n}\nfunction stateIn(stateValue) {\n    function stateIn() {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    stateIn.check = checkStateIn;\n    stateIn.stateValue = stateValue;\n    return stateIn;\n}\nfunction checkNot(snapshot, { context, event }, { guards }) {\n    return !evaluateGuard(guards[0], context, event, snapshot);\n}\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */ function not(guard) {\n    function not(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    not.check = checkNot;\n    not.guards = [\n        guard\n    ];\n    return not;\n}\nfunction checkAnd(snapshot, { context, event }, { guards }) {\n    return guards.every((guard)=>evaluateGuard(guard, context, event, snapshot));\n}\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */ function and(guards) {\n    function and(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    and.check = checkAnd;\n    and.guards = guards;\n    return and;\n}\nfunction checkOr(snapshot, { context, event }, { guards }) {\n    return guards.some((guard)=>evaluateGuard(guard, context, event, snapshot));\n}\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */ function or(guards) {\n    function or(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    or.check = checkOr;\n    or.guards = guards;\n    return or;\n}\n// TODO: throw on cycles (depth check should be enough)\nfunction evaluateGuard(guard, context, event, snapshot) {\n    const { machine } = snapshot;\n    const isInline = typeof guard === \"function\";\n    const resolved = isInline ? guard : machine.implementations.guards[typeof guard === \"string\" ? guard : guard.type];\n    if (!isInline && !resolved) {\n        throw new Error(`Guard '${typeof guard === \"string\" ? guard : guard.type}' is not implemented.'.`);\n    }\n    if (typeof resolved !== \"function\") {\n        return evaluateGuard(resolved, context, event, snapshot);\n    }\n    const guardArgs = {\n        context,\n        event\n    };\n    const guardParams = isInline || typeof guard === \"string\" ? undefined : \"params\" in guard ? typeof guard.params === \"function\" ? guard.params({\n        context,\n        event\n    }) : guard.params : undefined;\n    if (!(\"check\" in resolved)) {\n        // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n        // inline guards expect `TExpressionGuard` to be set to `undefined`\n        // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n        return resolved(guardArgs, guardParams);\n    }\n    const builtinGuard = resolved;\n    return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params\n    );\n}\nconst isAtomicStateNode = (stateNode)=>stateNode.type === \"atomic\" || stateNode.type === \"final\";\nfunction getChildren(stateNode) {\n    return Object.values(stateNode.states).filter((sn)=>sn.type !== \"history\");\n}\nfunction getProperAncestors(stateNode, toStateNode) {\n    const ancestors = [];\n    if (toStateNode === stateNode) {\n        return ancestors;\n    }\n    // add all ancestors\n    let m = stateNode.parent;\n    while(m && m !== toStateNode){\n        ancestors.push(m);\n        m = m.parent;\n    }\n    return ancestors;\n}\nfunction getAllStateNodes(stateNodes) {\n    const nodeSet = new Set(stateNodes);\n    const adjList = getAdjList(nodeSet);\n    // add descendants\n    for (const s of nodeSet){\n        // if previously active, add existing child nodes\n        if (s.type === \"compound\" && (!adjList.get(s) || !adjList.get(s).length)) {\n            getInitialStateNodesWithTheirAncestors(s).forEach((sn)=>nodeSet.add(sn));\n        } else {\n            if (s.type === \"parallel\") {\n                for (const child of getChildren(s)){\n                    if (child.type === \"history\") {\n                        continue;\n                    }\n                    if (!nodeSet.has(child)) {\n                        const initialStates = getInitialStateNodesWithTheirAncestors(child);\n                        for (const initialStateNode of initialStates){\n                            nodeSet.add(initialStateNode);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // add all ancestors\n    for (const s of nodeSet){\n        let m = s.parent;\n        while(m){\n            nodeSet.add(m);\n            m = m.parent;\n        }\n    }\n    return nodeSet;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n    const childStateNodes = adjList.get(baseNode);\n    if (!childStateNodes) {\n        return {}; // todo: fix?\n    }\n    if (baseNode.type === \"compound\") {\n        const childStateNode = childStateNodes[0];\n        if (childStateNode) {\n            if (isAtomicStateNode(childStateNode)) {\n                return childStateNode.key;\n            }\n        } else {\n            return {};\n        }\n    }\n    const stateValue = {};\n    for (const childStateNode of childStateNodes){\n        stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n    }\n    return stateValue;\n}\nfunction getAdjList(stateNodes) {\n    const adjList = new Map();\n    for (const s of stateNodes){\n        if (!adjList.has(s)) {\n            adjList.set(s, []);\n        }\n        if (s.parent) {\n            if (!adjList.has(s.parent)) {\n                adjList.set(s.parent, []);\n            }\n            adjList.get(s.parent).push(s);\n        }\n    }\n    return adjList;\n}\nfunction getStateValue(rootNode, stateNodes) {\n    const config = getAllStateNodes(stateNodes);\n    return getValueFromAdj(rootNode, getAdjList(config));\n}\nfunction isInFinalState(stateNodeSet, stateNode) {\n    if (stateNode.type === \"compound\") {\n        return getChildren(stateNode).some((s)=>s.type === \"final\" && stateNodeSet.has(s));\n    }\n    if (stateNode.type === \"parallel\") {\n        return getChildren(stateNode).every((sn)=>isInFinalState(stateNodeSet, sn));\n    }\n    return stateNode.type === \"final\";\n}\nconst isStateId = (str)=>str[0] === STATE_IDENTIFIER;\nfunction getCandidates(stateNode, receivedEventType) {\n    const candidates = stateNode.transitions.get(receivedEventType) || [\n        ...stateNode.transitions.keys()\n    ].filter((eventDescriptor)=>{\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (eventDescriptor === WILDCARD) {\n            return true;\n        }\n        if (!eventDescriptor.endsWith(\".*\")) {\n            return false;\n        }\n        if (/.*\\*.+/.test(eventDescriptor)) {\n            console.warn(`Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${eventDescriptor}\" event.`);\n        }\n        const partialEventTokens = eventDescriptor.split(\".\");\n        const eventTokens = receivedEventType.split(\".\");\n        for(let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++){\n            const partialEventToken = partialEventTokens[tokenIndex];\n            const eventToken = eventTokens[tokenIndex];\n            if (partialEventToken === \"*\") {\n                const isLastToken = tokenIndex === partialEventTokens.length - 1;\n                if (!isLastToken) {\n                    console.warn(`Infix wildcards in transition events are not allowed. Check the \"${eventDescriptor}\" transition.`);\n                }\n                return isLastToken;\n            }\n            if (partialEventToken !== eventToken) {\n                return false;\n            }\n        }\n        return true;\n    }).sort((a, b)=>b.length - a.length).flatMap((key)=>stateNode.transitions.get(key));\n    return candidates;\n}\n/** All delayed transitions from the config. */ function getDelayedTransitions(stateNode) {\n    const afterConfig = stateNode.config.after;\n    if (!afterConfig) {\n        return [];\n    }\n    const mutateEntryExit = (delay)=>{\n        const afterEvent = createAfterEvent(delay, stateNode.id);\n        const eventType = afterEvent.type;\n        stateNode.entry.push(raise(afterEvent, {\n            id: eventType,\n            delay\n        }));\n        stateNode.exit.push(cancel(eventType));\n        return eventType;\n    };\n    const delayedTransitions = Object.keys(afterConfig).flatMap((delay)=>{\n        const configTransition = afterConfig[delay];\n        const resolvedTransition = typeof configTransition === \"string\" ? {\n            target: configTransition\n        } : configTransition;\n        const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n        const eventType = mutateEntryExit(resolvedDelay);\n        return toArray(resolvedTransition).map((transition)=>({\n                ...transition,\n                event: eventType,\n                delay: resolvedDelay\n            }));\n    });\n    return delayedTransitions.map((delayedTransition)=>{\n        const { delay } = delayedTransition;\n        return {\n            ...formatTransition(stateNode, delayedTransition.event, delayedTransition),\n            delay\n        };\n    });\n}\nfunction formatTransition(stateNode, descriptor, transitionConfig) {\n    const normalizedTarget = normalizeTarget(transitionConfig.target);\n    const reenter = transitionConfig.reenter ?? false;\n    const target = resolveTarget(stateNode, normalizedTarget);\n    // TODO: should this be part of a lint rule instead?\n    if (transitionConfig.cond) {\n        throw new Error(`State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`);\n    }\n    const transition = {\n        ...transitionConfig,\n        actions: toArray(transitionConfig.actions),\n        guard: transitionConfig.guard,\n        target,\n        source: stateNode,\n        reenter,\n        eventType: descriptor,\n        toJSON: ()=>({\n                ...transition,\n                source: `#${stateNode.id}`,\n                target: target ? target.map((t)=>`#${t.id}`) : undefined\n            })\n    };\n    return transition;\n}\nfunction formatTransitions(stateNode) {\n    const transitions = new Map();\n    if (stateNode.config.on) {\n        for (const descriptor of Object.keys(stateNode.config.on)){\n            if (descriptor === NULL_EVENT) {\n                throw new Error('Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.');\n            }\n            const transitionsConfig = stateNode.config.on[descriptor];\n            transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n    }\n    if (stateNode.config.onDone) {\n        const descriptor = `xstate.done.state.${stateNode.id}`;\n        transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));\n    }\n    for (const invokeDef of stateNode.invoke){\n        if (invokeDef.onDone) {\n            const descriptor = `xstate.done.actor.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n        if (invokeDef.onError) {\n            const descriptor = `xstate.error.actor.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n        if (invokeDef.onSnapshot) {\n            const descriptor = `xstate.snapshot.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n    }\n    for (const delayedTransition of stateNode.after){\n        let existing = transitions.get(delayedTransition.eventType);\n        if (!existing) {\n            existing = [];\n            transitions.set(delayedTransition.eventType, existing);\n        }\n        existing.push(delayedTransition);\n    }\n    return transitions;\n}\nfunction formatInitialTransition(stateNode, _target) {\n    const resolvedTarget = typeof _target === \"string\" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;\n    if (!resolvedTarget && _target) {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n        `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`);\n    }\n    const transition = {\n        source: stateNode,\n        actions: !_target || typeof _target === \"string\" ? [] : toArray(_target.actions),\n        eventType: null,\n        reenter: false,\n        target: resolvedTarget ? [\n            resolvedTarget\n        ] : [],\n        toJSON: ()=>({\n                ...transition,\n                source: `#${stateNode.id}`,\n                target: resolvedTarget ? [\n                    `#${resolvedTarget.id}`\n                ] : []\n            })\n    };\n    return transition;\n}\nfunction resolveTarget(stateNode, targets) {\n    if (targets === undefined) {\n        // an undefined target signals that the state node should not transition from that state when receiving that event\n        return undefined;\n    }\n    return targets.map((target)=>{\n        if (typeof target !== \"string\") {\n            return target;\n        }\n        if (isStateId(target)) {\n            return stateNode.machine.getStateNodeById(target);\n        }\n        const isInternalTarget = target[0] === STATE_DELIMITER;\n        // If internal target is defined on machine,\n        // do not include machine key on target\n        if (isInternalTarget && !stateNode.parent) {\n            return getStateNodeByPath(stateNode, target.slice(1));\n        }\n        const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n        if (stateNode.parent) {\n            try {\n                const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);\n                return targetStateNode;\n            } catch (err) {\n                throw new Error(`Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`);\n            }\n        } else {\n            throw new Error(`Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`);\n        }\n    });\n}\nfunction resolveHistoryDefaultTransition(stateNode) {\n    const normalizedTarget = normalizeTarget(stateNode.config.target);\n    if (!normalizedTarget) {\n        return stateNode.parent.initial;\n    }\n    return {\n        target: normalizedTarget.map((t)=>typeof t === \"string\" ? getStateNodeByPath(stateNode.parent, t) : t)\n    };\n}\nfunction isHistoryNode(stateNode) {\n    return stateNode.type === \"history\";\n}\nfunction getInitialStateNodesWithTheirAncestors(stateNode) {\n    const states = getInitialStateNodes(stateNode);\n    for (const initialState of states){\n        for (const ancestor of getProperAncestors(initialState, stateNode)){\n            states.add(ancestor);\n        }\n    }\n    return states;\n}\nfunction getInitialStateNodes(stateNode) {\n    const set = new Set();\n    function iter(descStateNode) {\n        if (set.has(descStateNode)) {\n            return;\n        }\n        set.add(descStateNode);\n        if (descStateNode.type === \"compound\") {\n            iter(descStateNode.initial.target[0]);\n        } else if (descStateNode.type === \"parallel\") {\n            for (const child of getChildren(descStateNode)){\n                iter(child);\n            }\n        }\n    }\n    iter(stateNode);\n    return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */ function getStateNode(stateNode, stateKey) {\n    if (isStateId(stateKey)) {\n        return stateNode.machine.getStateNodeById(stateKey);\n    }\n    if (!stateNode.states) {\n        throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);\n    }\n    const result = stateNode.states[stateKey];\n    if (!result) {\n        throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);\n    }\n    return result;\n}\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */ function getStateNodeByPath(stateNode, statePath) {\n    if (typeof statePath === \"string\" && isStateId(statePath)) {\n        try {\n            return stateNode.machine.getStateNodeById(statePath);\n        } catch  {\n        // try individual paths\n        // throw e;\n        }\n    }\n    const arrayStatePath = toStatePath(statePath).slice();\n    let currentStateNode = stateNode;\n    while(arrayStatePath.length){\n        const key = arrayStatePath.shift();\n        if (!key.length) {\n            break;\n        }\n        currentStateNode = getStateNode(currentStateNode, key);\n    }\n    return currentStateNode;\n}\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */ function getStateNodes(stateNode, stateValue) {\n    if (typeof stateValue === \"string\") {\n        const childStateNode = stateNode.states[stateValue];\n        if (!childStateNode) {\n            throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);\n        }\n        return [\n            stateNode,\n            childStateNode\n        ];\n    }\n    const childStateKeys = Object.keys(stateValue);\n    const childStateNodes = childStateKeys.map((subStateKey)=>getStateNode(stateNode, subStateKey)).filter(Boolean);\n    return [\n        stateNode.machine.root,\n        stateNode\n    ].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey)=>{\n        const subStateNode = getStateNode(stateNode, subStateKey);\n        if (!subStateNode) {\n            return allSubStateNodes;\n        }\n        const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);\n        return allSubStateNodes.concat(subStateNodes);\n    }, []));\n}\nfunction transitionAtomicNode(stateNode, stateValue, snapshot, event) {\n    const childStateNode = getStateNode(stateNode, stateValue);\n    const next = childStateNode.next(snapshot, event);\n    if (!next || !next.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return next;\n}\nfunction transitionCompoundNode(stateNode, stateValue, snapshot, event) {\n    const subStateKeys = Object.keys(stateValue);\n    const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n    const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);\n    if (!next || !next.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return next;\n}\nfunction transitionParallelNode(stateNode, stateValue, snapshot, event) {\n    const allInnerTransitions = [];\n    for (const subStateKey of Object.keys(stateValue)){\n        const subStateValue = stateValue[subStateKey];\n        if (!subStateValue) {\n            continue;\n        }\n        const subStateNode = getStateNode(stateNode, subStateKey);\n        const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);\n        if (innerTransitions) {\n            allInnerTransitions.push(...innerTransitions);\n        }\n    }\n    if (!allInnerTransitions.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return allInnerTransitions;\n}\nfunction transitionNode(stateNode, stateValue, snapshot, event) {\n    // leaf node\n    if (typeof stateValue === \"string\") {\n        return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n    }\n    // compound node\n    if (Object.keys(stateValue).length === 1) {\n        return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n    }\n    // parallel node\n    return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\nfunction getHistoryNodes(stateNode) {\n    return Object.keys(stateNode.states).map((key)=>stateNode.states[key]).filter((sn)=>sn.type === \"history\");\n}\nfunction isDescendant(childStateNode, parentStateNode) {\n    let marker = childStateNode;\n    while(marker.parent && marker.parent !== parentStateNode){\n        marker = marker.parent;\n    }\n    return marker.parent === parentStateNode;\n}\nfunction hasIntersection(s1, s2) {\n    const set1 = new Set(s1);\n    const set2 = new Set(s2);\n    for (const item of set1){\n        if (set2.has(item)) {\n            return true;\n        }\n    }\n    for (const item of set2){\n        if (set1.has(item)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {\n    const filteredTransitions = new Set();\n    for (const t1 of enabledTransitions){\n        let t1Preempted = false;\n        const transitionsToRemove = new Set();\n        for (const t2 of filteredTransitions){\n            if (hasIntersection(computeExitSet([\n                t1\n            ], stateNodeSet, historyValue), computeExitSet([\n                t2\n            ], stateNodeSet, historyValue))) {\n                if (isDescendant(t1.source, t2.source)) {\n                    transitionsToRemove.add(t2);\n                } else {\n                    t1Preempted = true;\n                    break;\n                }\n            }\n        }\n        if (!t1Preempted) {\n            for (const t3 of transitionsToRemove){\n                filteredTransitions.delete(t3);\n            }\n            filteredTransitions.add(t1);\n        }\n    }\n    return Array.from(filteredTransitions);\n}\nfunction findLeastCommonAncestor(stateNodes) {\n    const [head, ...tail] = stateNodes;\n    for (const ancestor of getProperAncestors(head, undefined)){\n        if (tail.every((sn)=>isDescendant(sn, ancestor))) {\n            return ancestor;\n        }\n    }\n}\nfunction getEffectiveTargetStates(transition, historyValue) {\n    if (!transition.target) {\n        return [];\n    }\n    const targets = new Set();\n    for (const targetNode of transition.target){\n        if (isHistoryNode(targetNode)) {\n            if (historyValue[targetNode.id]) {\n                for (const node of historyValue[targetNode.id]){\n                    targets.add(node);\n                }\n            } else {\n                for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)){\n                    targets.add(node);\n                }\n            }\n        } else {\n            targets.add(targetNode);\n        }\n    }\n    return [\n        ...targets\n    ];\n}\nfunction getTransitionDomain(transition, historyValue) {\n    const targetStates = getEffectiveTargetStates(transition, historyValue);\n    if (!targetStates) {\n        return;\n    }\n    if (!transition.reenter && targetStates.every((target)=>target === transition.source || isDescendant(target, transition.source))) {\n        return transition.source;\n    }\n    const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n    if (lca) {\n        return lca;\n    }\n    // at this point we know that it's a root transition since LCA couldn't be found\n    if (transition.reenter) {\n        return;\n    }\n    return transition.source.machine.root;\n}\nfunction computeExitSet(transitions, stateNodeSet, historyValue) {\n    const statesToExit = new Set();\n    for (const t of transitions){\n        if (t.target?.length) {\n            const domain = getTransitionDomain(t, historyValue);\n            if (t.reenter && t.source === domain) {\n                statesToExit.add(domain);\n            }\n            for (const stateNode of stateNodeSet){\n                if (isDescendant(stateNode, domain)) {\n                    statesToExit.add(stateNode);\n                }\n            }\n        }\n    }\n    return [\n        ...statesToExit\n    ];\n}\nfunction areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {\n    if (prevStateNodes.length !== nextStateNodeSet.size) {\n        return false;\n    }\n    for (const node of prevStateNodes){\n        if (!nextStateNodeSet.has(node)) {\n            return false;\n        }\n    }\n    return true;\n}\n/** https://www.w3.org/TR/scxml/#microstepProcedure */ function microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {\n    if (!transitions.length) {\n        return currentSnapshot;\n    }\n    const mutStateNodeSet = new Set(currentSnapshot._nodes);\n    let historyValue = currentSnapshot.historyValue;\n    const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);\n    let nextState = currentSnapshot;\n    // Exit states\n    if (!isInitial) {\n        [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);\n    }\n    // Execute transition content\n    nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap((t)=>t.actions), internalQueue, undefined);\n    // Enter states\n    nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);\n    const nextStateNodes = [\n        ...mutStateNodeSet\n    ];\n    if (nextState.status === \"done\") {\n        nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b)=>b.order - a.order).flatMap((state)=>state.exit), internalQueue, undefined);\n    }\n    // eslint-disable-next-line no-useless-catch\n    try {\n        if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {\n            return nextState;\n        }\n        return cloneMachineSnapshot(nextState, {\n            _nodes: nextStateNodes,\n            historyValue\n        });\n    } catch (e) {\n        // TODO: Refactor this once proper error handling is implemented.\n        // See https://github.com/statelyai/rfcs/pull/4\n        throw e;\n    }\n}\nfunction getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {\n    if (rootNode.output === undefined) {\n        return;\n    }\n    const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);\n    return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);\n}\nfunction enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {\n    let nextSnapshot = currentSnapshot;\n    const statesToEnter = new Set();\n    // those are states that were directly targeted or indirectly targeted by the explicit target\n    // in other words, those are states for which initial actions should be executed\n    // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n    const statesForDefaultEntry = new Set();\n    computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);\n    // In the initial state, the root state node is \"entered\".\n    if (isInitial) {\n        statesForDefaultEntry.add(currentSnapshot.machine.root);\n    }\n    const completedNodes = new Set();\n    for (const stateNodeToEnter of [\n        ...statesToEnter\n    ].sort((a, b)=>a.order - b.order)){\n        mutStateNodeSet.add(stateNodeToEnter);\n        const actions = [];\n        // Add entry actions\n        actions.push(...stateNodeToEnter.entry);\n        for (const invokeDef of stateNodeToEnter.invoke){\n            actions.push(spawnChild(invokeDef.src, {\n                ...invokeDef,\n                syncSnapshot: !!invokeDef.onSnapshot\n            }));\n        }\n        if (statesForDefaultEntry.has(stateNodeToEnter)) {\n            const initialActions = stateNodeToEnter.initial.actions;\n            actions.push(...initialActions);\n        }\n        nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef)=>invokeDef.id));\n        if (stateNodeToEnter.type === \"final\") {\n            const parent = stateNodeToEnter.parent;\n            let ancestorMarker = parent?.type === \"parallel\" ? parent : parent?.parent;\n            let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n            if (parent?.type === \"compound\") {\n                internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));\n            }\n            while(ancestorMarker?.type === \"parallel\" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)){\n                completedNodes.add(ancestorMarker);\n                internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n                rootCompletionNode = ancestorMarker;\n                ancestorMarker = ancestorMarker.parent;\n            }\n            if (ancestorMarker) {\n                continue;\n            }\n            nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n                status: \"done\",\n                output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)\n            });\n        }\n    }\n    return nextSnapshot;\n}\nfunction computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {\n    for (const t of transitions){\n        const domain = getTransitionDomain(t, historyValue);\n        for (const s of t.target || []){\n            if (!isHistoryNode(s) && // if the target is different than the source then it will *definitely* be entered\n            (t.source !== s || // we know that the domain can't lie within the source\n            // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n            t.source !== domain || // reentering transitions always enter the target, even if it's the source itself\n            t.reenter)) {\n                statesToEnter.add(s);\n                statesForDefaultEntry.add(s);\n            }\n            addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n        }\n        const targetStates = getEffectiveTargetStates(t, historyValue);\n        for (const s of targetStates){\n            const ancestors = getProperAncestors(s, domain);\n            if (domain?.type === \"parallel\") {\n                ancestors.push(domain);\n            }\n            addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);\n        }\n    }\n}\nfunction addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {\n    if (isHistoryNode(stateNode)) {\n        if (historyValue[stateNode.id]) {\n            const historyStateNodes = historyValue[stateNode.id];\n            for (const s of historyStateNodes){\n                statesToEnter.add(s);\n                addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n            }\n            for (const s of historyStateNodes){\n                addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n            }\n        } else {\n            const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);\n            for (const s of historyDefaultTransition.target){\n                statesToEnter.add(s);\n                if (historyDefaultTransition === stateNode.parent?.initial) {\n                    statesForDefaultEntry.add(stateNode.parent);\n                }\n                addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n            }\n            for (const s of historyDefaultTransition.target){\n                addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n            }\n        }\n    } else {\n        if (stateNode.type === \"compound\") {\n            const [initialState] = stateNode.initial.target;\n            if (!isHistoryNode(initialState)) {\n                statesToEnter.add(initialState);\n                statesForDefaultEntry.add(initialState);\n            }\n            addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);\n            addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);\n        } else {\n            if (stateNode.type === \"parallel\") {\n                for (const child of getChildren(stateNode).filter((sn)=>!isHistoryNode(sn))){\n                    if (![\n                        ...statesToEnter\n                    ].some((s)=>isDescendant(s, child))) {\n                        if (!isHistoryNode(child)) {\n                            statesToEnter.add(child);\n                            statesForDefaultEntry.add(child);\n                        }\n                        addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {\n    for (const anc of ancestors){\n        if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n            statesToEnter.add(anc);\n        }\n        if (anc.type === \"parallel\") {\n            for (const child of getChildren(anc).filter((sn)=>!isHistoryNode(sn))){\n                if (![\n                    ...statesToEnter\n                ].some((s)=>isDescendant(s, child))) {\n                    statesToEnter.add(child);\n                    addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n                }\n            }\n        }\n    }\n}\nfunction addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {\n    addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));\n}\nfunction exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {\n    let nextSnapshot = currentSnapshot;\n    const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);\n    statesToExit.sort((a, b)=>b.order - a.order);\n    let changedHistory;\n    // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n    for (const exitStateNode of statesToExit){\n        for (const historyNode of getHistoryNodes(exitStateNode)){\n            let predicate;\n            if (historyNode.history === \"deep\") {\n                predicate = (sn)=>isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n            } else {\n                predicate = (sn)=>{\n                    return sn.parent === exitStateNode;\n                };\n            }\n            changedHistory ??= {\n                ...historyValue\n            };\n            changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);\n        }\n    }\n    for (const s of statesToExit){\n        nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [\n            ...s.exit,\n            ...s.invoke.map((def)=>stopChild(def.id))\n        ], internalQueue, undefined);\n        mutStateNodeSet.delete(s);\n    }\n    return [\n        nextSnapshot,\n        changedHistory || historyValue\n    ];\n}\nfunction getAction(machine, actionType) {\n    return machine.implementations.actions[actionType];\n}\nfunction resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {\n    const { machine } = currentSnapshot;\n    let intermediateSnapshot = currentSnapshot;\n    for (const action of actions){\n        const isInline = typeof action === \"function\";\n        const resolvedAction = isInline ? action : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n        getAction(machine, typeof action === \"string\" ? action : action.type);\n        const actionArgs = {\n            context: intermediateSnapshot.context,\n            event,\n            self: actorScope.self,\n            system: actorScope.system\n        };\n        const actionParams = isInline || typeof action === \"string\" ? undefined : \"params\" in action ? typeof action.params === \"function\" ? action.params({\n            context: intermediateSnapshot.context,\n            event\n        }) : action.params : undefined;\n        if (!resolvedAction || !(\"resolve\" in resolvedAction)) {\n            actorScope.actionExecutor({\n                type: typeof action === \"string\" ? action : typeof action === \"object\" ? action.type : action.name || \"(anonymous)\",\n                info: actionArgs,\n                params: actionParams,\n                exec: resolvedAction\n            });\n            continue;\n        }\n        const builtinAction = resolvedAction;\n        const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction, // this holds all params\n        extra);\n        intermediateSnapshot = nextState;\n        if (\"retryResolve\" in builtinAction) {\n            retries?.push([\n                builtinAction,\n                params\n            ]);\n        }\n        if (\"execute\" in builtinAction) {\n            actorScope.actionExecutor({\n                type: builtinAction.type,\n                info: actionArgs,\n                params,\n                exec: builtinAction.execute.bind(null, actorScope, params)\n            });\n        }\n        if (actions) {\n            intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);\n        }\n    }\n    return intermediateSnapshot;\n}\nfunction resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {\n    const retries = deferredActorIds ? [] : undefined;\n    const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {\n        internalQueue,\n        deferredActorIds\n    }, retries);\n    retries?.forEach(([builtinAction, params])=>{\n        builtinAction.retryResolve(actorScope, nextState, params);\n    });\n    return nextState;\n}\nfunction macrostep(snapshot, event, actorScope, internalQueue) {\n    if (event.type === WILDCARD) {\n        throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n    }\n    let nextSnapshot = snapshot;\n    const microstates = [];\n    function addMicrostate(microstate, event, transitions) {\n        actorScope.system._sendInspectionEvent({\n            type: \"@xstate.microstep\",\n            actorRef: actorScope.self,\n            event,\n            snapshot: microstate,\n            _transitions: transitions\n        });\n        microstates.push(microstate);\n    }\n    // Handle stop event\n    if (event.type === XSTATE_STOP) {\n        nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {\n            status: \"stopped\"\n        });\n        addMicrostate(nextSnapshot, event, []);\n        return {\n            snapshot: nextSnapshot,\n            microstates\n        };\n    }\n    let nextEvent = event;\n    // Assume the state is at rest (no raised events)\n    // Determine the next state based on the next microstep\n    if (nextEvent.type !== XSTATE_INIT) {\n        const currentEvent = nextEvent;\n        const isErr = isErrorActorEvent(currentEvent);\n        const transitions = selectTransitions(currentEvent, nextSnapshot);\n        if (isErr && !transitions.length) {\n            // TODO: we should likely only allow transitions selected by very explicit descriptors\n            // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n            // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n            nextSnapshot = cloneMachineSnapshot(snapshot, {\n                status: \"error\",\n                error: currentEvent.error\n            });\n            addMicrostate(nextSnapshot, currentEvent, []);\n            return {\n                snapshot: nextSnapshot,\n                microstates\n            };\n        }\n        nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false, // isInitial\n        internalQueue);\n        addMicrostate(nextSnapshot, currentEvent, transitions);\n    }\n    let shouldSelectEventlessTransitions = true;\n    while(nextSnapshot.status === \"active\"){\n        let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];\n        // eventless transitions should always be selected after selecting *regular* transitions\n        // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n        const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n        if (!enabledTransitions.length) {\n            if (!internalQueue.length) {\n                break;\n            }\n            nextEvent = internalQueue.shift();\n            enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n        }\n        nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);\n        shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n        addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n    }\n    if (nextSnapshot.status !== \"active\") {\n        stopChildren(nextSnapshot, nextEvent, actorScope);\n    }\n    return {\n        snapshot: nextSnapshot,\n        microstates\n    };\n}\nfunction stopChildren(nextState, event, actorScope) {\n    return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map((child)=>stopChild(child)), [], undefined);\n}\nfunction selectTransitions(event, nextState) {\n    return nextState.machine.getTransitionData(nextState, event);\n}\nfunction selectEventlessTransitions(nextState, event) {\n    const enabledTransitionSet = new Set();\n    const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n    for (const stateNode of atomicStates){\n        loop: for (const s of [\n            stateNode\n        ].concat(getProperAncestors(stateNode, undefined))){\n            if (!s.always) {\n                continue;\n            }\n            for (const transition of s.always){\n                if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {\n                    enabledTransitionSet.add(transition);\n                    break loop;\n                }\n            }\n        }\n    }\n    return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);\n}\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */ function resolveStateValue(rootNode, stateValue) {\n    const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n    return getStateValue(rootNode, [\n        ...allStateNodes\n    ]);\n}\nfunction isMachineSnapshot(value) {\n    return !!value && typeof value === \"object\" && \"machine\" in value && \"value\" in value;\n}\nconst machineSnapshotMatches = function matches(testValue) {\n    return matchesState(testValue, this.value);\n};\nconst machineSnapshotHasTag = function hasTag(tag) {\n    return this.tags.has(tag);\n};\nconst machineSnapshotCan = function can(event) {\n    if (!this.machine) {\n        console.warn(`state.can(...) used outside of a machine-created State object; this will always return false.`);\n    }\n    const transitionData = this.machine.getTransitionData(this, event);\n    return !!transitionData?.length && // Check that at least one transition is not forbidden\n    transitionData.some((t)=>t.target !== undefined || t.actions.length);\n};\nconst machineSnapshotToJSON = function toJSON() {\n    const { _nodes: nodes, tags, machine, getMeta, toJSON, can, hasTag, matches, ...jsonValues } = this;\n    return {\n        ...jsonValues,\n        tags: Array.from(tags)\n    };\n};\nconst machineSnapshotGetMeta = function getMeta() {\n    return this._nodes.reduce((acc, stateNode)=>{\n        if (stateNode.meta !== undefined) {\n            acc[stateNode.id] = stateNode.meta;\n        }\n        return acc;\n    }, {});\n};\nfunction createMachineSnapshot(config, machine) {\n    return {\n        status: config.status,\n        output: config.output,\n        error: config.error,\n        machine,\n        context: config.context,\n        _nodes: config._nodes,\n        value: getStateValue(machine.root, config._nodes),\n        tags: new Set(config._nodes.flatMap((sn)=>sn.tags)),\n        children: config.children,\n        historyValue: config.historyValue || {},\n        matches: machineSnapshotMatches,\n        hasTag: machineSnapshotHasTag,\n        can: machineSnapshotCan,\n        getMeta: machineSnapshotGetMeta,\n        toJSON: machineSnapshotToJSON\n    };\n}\nfunction cloneMachineSnapshot(snapshot, config = {}) {\n    return createMachineSnapshot({\n        ...snapshot,\n        ...config\n    }, snapshot.machine);\n}\nfunction serializeHistoryValue(historyValue) {\n    if (typeof historyValue !== \"object\" || historyValue === null) {\n        return {};\n    }\n    const result = {};\n    for(const key in historyValue){\n        const value = historyValue[key];\n        if (Array.isArray(value)) {\n            result[key] = value.map((item)=>({\n                    id: item.id\n                }));\n        }\n    }\n    return result;\n}\nfunction getPersistedSnapshot(snapshot, options) {\n    const { _nodes: nodes, tags, machine, children, context, can, hasTag, matches, getMeta, toJSON, ...jsonValues } = snapshot;\n    const childrenJson = {};\n    for(const id in children){\n        const child = children[id];\n        if (typeof child.src !== \"string\" && (!options || !(\"__unsafeAllowInlineActors\" in options))) {\n            throw new Error(\"An inline child actor cannot be persisted.\");\n        }\n        childrenJson[id] = {\n            snapshot: child.getPersistedSnapshot(options),\n            src: child.src,\n            systemId: child._systemId,\n            syncSnapshot: child._syncSnapshot\n        };\n    }\n    const persisted = {\n        ...jsonValues,\n        context: persistContext(context),\n        children: childrenJson,\n        historyValue: serializeHistoryValue(jsonValues.historyValue)\n    };\n    return persisted;\n}\nfunction persistContext(contextPart) {\n    let copy;\n    for(const key in contextPart){\n        const value = contextPart[key];\n        if (value && typeof value === \"object\") {\n            if (\"sessionId\" in value && \"send\" in value && \"ref\" in value) {\n                copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n                    ...contextPart\n                };\n                copy[key] = {\n                    xstate$$type: $$ACTOR_TYPE,\n                    id: value.id\n                };\n            } else {\n                const result = persistContext(value);\n                if (result !== value) {\n                    copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n                        ...contextPart\n                    };\n                    copy[key] = result;\n                }\n            }\n        }\n    }\n    return copy ?? contextPart;\n}\nfunction resolveRaise(_, snapshot, args, actionParams, { event: eventOrExpr, id, delay }, { internalQueue }) {\n    const delaysMap = snapshot.machine.implementations.delays;\n    if (typeof eventOrExpr === \"string\") {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`);\n    }\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    let resolvedDelay;\n    if (typeof delay === \"string\") {\n        const configDelay = delaysMap && delaysMap[delay];\n        resolvedDelay = typeof configDelay === \"function\" ? configDelay(args, actionParams) : configDelay;\n    } else {\n        resolvedDelay = typeof delay === \"function\" ? delay(args, actionParams) : delay;\n    }\n    if (typeof resolvedDelay !== \"number\") {\n        internalQueue.push(resolvedEvent);\n    }\n    return [\n        snapshot,\n        {\n            event: resolvedEvent,\n            id,\n            delay: resolvedDelay\n        },\n        undefined\n    ];\n}\nfunction executeRaise(actorScope, params) {\n    const { event, delay, id } = params;\n    if (typeof delay === \"number\") {\n        actorScope.defer(()=>{\n            const self = actorScope.self;\n            actorScope.system.scheduler.schedule(self, self, event, delay, id);\n        });\n        return;\n    }\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */ function raise(eventOrExpr, options) {\n    if (executingCustomAction) {\n        console.warn(\"Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function raise(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    raise.type = \"xstate.raise\";\n    raise.event = eventOrExpr;\n    raise.id = options?.id;\n    raise.delay = options?.delay;\n    raise.resolve = resolveRaise;\n    raise.execute = executeRaise;\n    return raise;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtNTk1NDk3NzEuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRFO0FBRTVFLE1BQU1DO0lBQ0pDLFlBQVlDLFFBQVEsQ0FBRTtRQUNwQixJQUFJLENBQUNBLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNmO0lBQ0FDLFFBQVE7UUFDTixJQUFJLENBQUNILE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0ksS0FBSztJQUNaO0lBQ0FDLFFBQVE7UUFDTix5RUFBeUU7UUFDekUsdUZBQXVGO1FBQ3ZGLElBQUksSUFBSSxDQUFDSixRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDQSxRQUFRLENBQUNLLElBQUksR0FBRztZQUNyQixJQUFJLENBQUNKLEtBQUssR0FBRyxJQUFJLENBQUNELFFBQVE7UUFDNUI7SUFDRjtJQUNBTSxRQUFRQyxLQUFLLEVBQUU7UUFDYixNQUFNQyxXQUFXO1lBQ2ZDLE9BQU9GO1lBQ1BGLE1BQU07UUFDUjtRQUNBLElBQUksSUFBSSxDQUFDTCxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDQyxLQUFLLENBQUNJLElBQUksR0FBR0c7WUFDbEIsSUFBSSxDQUFDUCxLQUFLLEdBQUdPO1lBQ2I7UUFDRjtRQUNBLElBQUksQ0FBQ1IsUUFBUSxHQUFHUTtRQUNoQixJQUFJLENBQUNQLEtBQUssR0FBR087UUFDYixJQUFJLElBQUksQ0FBQ1QsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQ0ksS0FBSztRQUNaO0lBQ0Y7SUFDQUEsUUFBUTtRQUNOLE1BQU8sSUFBSSxDQUFDSCxRQUFRLENBQUU7WUFDcEIsbUZBQW1GO1lBQ25GLDZFQUE2RTtZQUM3RSxN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LE1BQU0wTCxXQUFXLEVBQUVsYSxPQUFPO0lBQ2pDLElBQUkwRCx1QkFBdUI7UUFDekI5RyxRQUFRQyxJQUFJLENBQUM7SUFDZjtJQUNBLFNBQVMyUixNQUFNdEYsS0FBSyxFQUFFQyxPQUFPO1FBQzNCO1lBQ0UsTUFBTSxJQUFJdEcsTUFBTSxDQUFDLGdDQUFnQyxDQUFDO1FBQ3BEO0lBQ0Y7SUFDQTJMLE1BQU1wVixJQUFJLEdBQUc7SUFDYm9WLE1BQU1uVyxLQUFLLEdBQUc2aEI7SUFDZDFMLE1BQU1yVixFQUFFLEdBQUc2RyxTQUFTN0c7SUFDcEJxVixNQUFNM04sS0FBSyxHQUFHYixTQUFTYTtJQUN2QjJOLE1BQU1wRixPQUFPLEdBQUc2UTtJQUNoQnpMLE1BQU1uRixPQUFPLEdBQUdrUjtJQUNoQixPQUFPL0w7QUFDVDtBQUVrakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGlwbGk5LXBhcmFub3JtYWwvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtNTk1NDk3NzEuZGV2ZWxvcG1lbnQuZXNtLmpzPzJlZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGV2VG9vbHNBZGFwdGVyIH0gZnJvbSAnLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG5jbGFzcyBNYWlsYm94IHtcbiAgY29uc3RydWN0b3IoX3Byb2Nlc3MpIHtcbiAgICB0aGlzLl9wcm9jZXNzID0gX3Byb2Nlc3M7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgLy8gd2UgY2FuJ3Qgc2V0IF9jdXJyZW50IHRvIG51bGwgYmVjYXVzZSB3ZSBtaWdodCBiZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgIC8vIGFuZCBlbnF1ZXVlIGZvbGxvd2luZyBjbGVhciBzaG91bGRuJ3Qgc3RhcnQgcHJvY2Vzc2luZyB0aGUgZW5xdWV1ZWQgaXRlbSBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50Lm5leHQgPSBudWxsO1xuICAgICAgdGhpcy5fbGFzdCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgfVxuICB9XG4gIGVucXVldWUoZXZlbnQpIHtcbiAgICBjb25zdCBlbnF1ZXVlZCA9IHtcbiAgICAgIHZhbHVlOiBldmVudCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9sYXN0Lm5leHQgPSBlbnF1ZXVlZDtcbiAgICAgIHRoaXMuX2xhc3QgPSBlbnF1ZXVlZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudCA9IGVucXVldWVkO1xuICAgIHRoaXMuX2xhc3QgPSBlbnF1ZXVlZDtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG4gIGZsdXNoKCkge1xuICAgIHdoaWxlICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICAvLyBhdG0gdGhlIGdpdmVuIF9wcm9jZXNzIGlzIHJlc3BvbnNpYmxlIGZvciBpbXBsZW1lbnRpbmcgcHJvcGVyIHRyeS9jYXRjaCBoYW5kbGluZ1xuICAgICAgLy8gd2UgYXNzdW1lIGhlcmUgdGhhdCB0aGlzIHdvbid0IHRocm93IGluIGEgd2F5IHRoYXQgY2FuIGFmZmVjdCB0aGlzIG1haWxib3hcbiAgICAgIGNvbnN0IGNvbnN1bWVkID0gdGhpcy5fY3VycmVudDtcbiAgICAgIHRoaXMuX3Byb2Nlc3MoY29uc3VtZWQudmFsdWUpO1xuICAgICAgdGhpcy5fY3VycmVudCA9IGNvbnN1bWVkLm5leHQ7XG4gICAgfVxuICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICB9XG59XG5cbmNvbnN0IFNUQVRFX0RFTElNSVRFUiA9ICcuJztcbmNvbnN0IFRBUkdFVExFU1NfS0VZID0gJyc7XG5jb25zdCBOVUxMX0VWRU5UID0gJyc7XG5jb25zdCBTVEFURV9JREVOVElGSUVSID0gJyMnO1xuY29uc3QgV0lMRENBUkQgPSAnKic7XG5jb25zdCBYU1RBVEVfSU5JVCA9ICd4c3RhdGUuaW5pdCc7XG5jb25zdCBYU1RBVEVfRVJST1IgPSAneHN0YXRlLmVycm9yJztcbmNvbnN0IFhTVEFURV9TVE9QID0gJ3hzdGF0ZS5zdG9wJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyBhbiBpbXBsaWNpdCBldmVudCB0aGF0IGlzIHNlbnQgYWZ0ZXIgdGhlXG4gKiBzcGVjaWZpZWQgYGRlbGF5YC5cbiAqXG4gKiBAcGFyYW0gZGVsYXlSZWYgVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGlkIFRoZSBzdGF0ZSBub2RlIElEIHdoZXJlIHRoaXMgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVBZnRlckV2ZW50KGRlbGF5UmVmLCBpZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGB4c3RhdGUuYWZ0ZXIuJHtkZWxheVJlZn0uJHtpZH1gXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBldmVudCB0aGF0IHJlcHJlc2VudHMgdGhhdCBhIGZpbmFsIHN0YXRlIG5vZGUgaGFzIGJlZW4gcmVhY2hlZCBpblxuICogdGhlIHBhcmVudCBzdGF0ZSBub2RlLlxuICpcbiAqIEBwYXJhbSBpZCBUaGUgZmluYWwgc3RhdGUgbm9kZSdzIHBhcmVudCBzdGF0ZSBub2RlIGBpZGBcbiAqIEBwYXJhbSBvdXRwdXQgVGhlIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBldmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVEb25lU3RhdGVFdmVudChpZCwgb3V0cHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5kb25lLnN0YXRlLiR7aWR9YCxcbiAgICBvdXRwdXRcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyB0aGF0IGFuIGludm9rZWQgc2VydmljZSBoYXMgdGVybWluYXRlZC5cbiAqXG4gKiBBbiBpbnZva2VkIHNlcnZpY2UgaXMgdGVybWluYXRlZCB3aGVuIGl0IGhhcyByZWFjaGVkIGEgdG9wLWxldmVsIGZpbmFsIHN0YXRlXG4gKiBub2RlLCBidXQgbm90IHdoZW4gaXQgaXMgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIGludm9rZUlkIFRoZSBpbnZva2VkIHNlcnZpY2UgSURcbiAqIEBwYXJhbSBvdXRwdXQgVGhlIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBldmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVEb25lQWN0b3JFdmVudChpbnZva2VJZCwgb3V0cHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5kb25lLmFjdG9yLiR7aW52b2tlSWR9YCxcbiAgICBvdXRwdXQsXG4gICAgYWN0b3JJZDogaW52b2tlSWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yQWN0b3JFdmVudChpZCwgZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmVycm9yLmFjdG9yLiR7aWR9YCxcbiAgICBlcnJvcixcbiAgICBhY3RvcklkOiBpZFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5pdEV2ZW50KGlucHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogWFNUQVRFX0lOSVQsXG4gICAgaW5wdXRcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW4gYSBzZXBhcmF0ZVxuICogbWFjcm90YXNrLiBJdCBhbGxvd3MgdGhvc2UgZXJyb3JzIHRvIGJlIGRldGVjdGVkIGJ5IGdsb2JhbCBlcnJvciBoYW5kbGVycyBhbmRcbiAqIHJlcG9ydGVkIHRvIGJ1ZyB0cmFja2luZyBzZXJ2aWNlcyB3aXRob3V0IGludGVycnVwdGluZyBvdXIgb3duIHN0YWNrIG9mXG4gKiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIGVyciBFcnJvciB0byBiZSB0aHJvd25cbiAqL1xuZnVuY3Rpb24gcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGUgPSAoKCkgPT4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCAnQEBvYnNlcnZhYmxlJykoKTtcblxuZnVuY3Rpb24gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlSWQsIGNoaWxkU3RhdGVJZCkge1xuICBjb25zdCBwYXJlbnRTdGF0ZVZhbHVlID0gdG9TdGF0ZVZhbHVlKHBhcmVudFN0YXRlSWQpO1xuICBjb25zdCBjaGlsZFN0YXRlVmFsdWUgPSB0b1N0YXRlVmFsdWUoY2hpbGRTdGF0ZUlkKTtcbiAgaWYgKHR5cGVvZiBjaGlsZFN0YXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJlbnRTdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNoaWxkU3RhdGVWYWx1ZSA9PT0gcGFyZW50U3RhdGVWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBQYXJlbnQgbW9yZSBzcGVjaWZpYyB0aGFuIGNoaWxkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcGFyZW50U3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyZW50U3RhdGVWYWx1ZSBpbiBjaGlsZFN0YXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmVudFN0YXRlVmFsdWUpLmV2ZXJ5KGtleSA9PiB7XG4gICAgaWYgKCEoa2V5IGluIGNoaWxkU3RhdGVWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXNTdGF0ZShwYXJlbnRTdGF0ZVZhbHVlW2tleV0sIGNoaWxkU3RhdGVWYWx1ZVtrZXldKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0b1N0YXRlUGF0aChzdGF0ZUlkKSB7XG4gIGlmIChpc0FycmF5KHN0YXRlSWQpKSB7XG4gICAgcmV0dXJuIHN0YXRlSWQ7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBzZWdtZW50ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVJZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdGF0ZUlkLmNoYXJDb2RlQXQoaSk7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAvLyBcXFxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgc2VnbWVudCArPSBzdGF0ZUlkW2kgKyAxXTtcbiAgICAgICAgLy8gYW5kIHNraXAgb3ZlciBpdFxuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gLlxuICAgICAgY2FzZSA0NjpcbiAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIHNlZ21lbnQgPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNlZ21lbnQgKz0gc3RhdGVJZFtpXTtcbiAgfVxuICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVWYWx1ZShzdGF0ZVZhbHVlKSB7XG4gIGlmIChpc01hY2hpbmVTbmFwc2hvdChzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlLnZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgfVxuICBjb25zdCBzdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVZhbHVlKTtcbiAgcmV0dXJuIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKTtcbn1cbmZ1bmN0aW9uIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKSB7XG4gIGlmIChzdGF0ZVBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHN0YXRlUGF0aFswXTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHt9O1xuICBsZXQgbWFya2VyID0gdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChpID09PSBzdGF0ZVBhdGgubGVuZ3RoIC0gMikge1xuICAgICAgbWFya2VyW3N0YXRlUGF0aFtpXV0gPSBzdGF0ZVBhdGhbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IG1hcmtlcjtcbiAgICAgIG1hcmtlciA9IHt9O1xuICAgICAgcHJldmlvdXNbc3RhdGVQYXRoW2ldXSA9IG1hcmtlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBjb2xsZWN0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gY29sbGVjdGlvbktleXNbaV07XG4gICAgcmVzdWx0W2tleV0gPSBpdGVyYXRlZShjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbiwgaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlTdHJpY3QodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdG9BcnJheVN0cmljdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlT3V0cHV0KG1hcHBlciwgY29udGV4dCwgZXZlbnQsIHNlbGYpIHtcbiAgaWYgKHR5cGVvZiBtYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWFwcGVyKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGZcbiAgICB9KTtcbiAgfVxuICBpZiAoISFtYXBwZXIgJiYgdHlwZW9mIG1hcHBlciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnZhbHVlcyhtYXBwZXIpLnNvbWUodmFsID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc29sZS53YXJuKGBEeW5hbWljYWxseSBtYXBwaW5nIHZhbHVlcyB0byBpbmRpdmlkdWFsIHByb3BlcnRpZXMgaXMgZGVwcmVjYXRlZC4gVXNlIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWFwcGVkIG9iamVjdCBpbnN0ZWFkLlxcbkZvdW5kIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBwb3NzaWJseSBtYXBwaW5nIGZ1bmN0aW9uczogJHtPYmplY3QuZW50cmllcyhtYXBwZXIpLmZpbHRlcigoWywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgXFxuIC0gJHtrZXl9OiAke3ZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxuXFxzKi9nLCAnJyl9YCkuam9pbignJyl9YCk7XG4gIH1cbiAgcmV0dXJuIG1hcHBlcjtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNFcnJvckFjdG9yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgneHN0YXRlLmVycm9yLmFjdG9yJyk7XG59XG5mdW5jdGlvbiB0b1RyYW5zaXRpb25Db25maWdBcnJheShjb25maWdMaWtlKSB7XG4gIHJldHVybiB0b0FycmF5U3RyaWN0KGNvbmZpZ0xpa2UpLm1hcCh0cmFuc2l0aW9uTGlrZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uTGlrZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHRyYW5zaXRpb25MaWtlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB0cmFuc2l0aW9uTGlrZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MaWtlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gVEFSR0VUTEVTU19LRVkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0b0FycmF5KHRhcmdldCk7XG59XG5mdW5jdGlvbiB0b09ic2VydmVyKG5leHRIYW5kbGVyLCBlcnJvckhhbmRsZXIsIGNvbXBsZXRpb25IYW5kbGVyKSB7XG4gIGNvbnN0IGlzT2JzZXJ2ZXIgPSB0eXBlb2YgbmV4dEhhbmRsZXIgPT09ICdvYmplY3QnO1xuICBjb25zdCBzZWxmID0gaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIG5leHQ6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIubmV4dCA6IG5leHRIYW5kbGVyKT8uYmluZChzZWxmKSxcbiAgICBlcnJvcjogKGlzT2JzZXJ2ZXIgPyBuZXh0SGFuZGxlci5lcnJvciA6IGVycm9ySGFuZGxlcik/LmJpbmQoc2VsZiksXG4gICAgY29tcGxldGU6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIuY29tcGxldGUgOiBjb21wbGV0aW9uSGFuZGxlcik/LmJpbmQoc2VsZilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludm9rZUlkKHN0YXRlTm9kZUlkLCBpbmRleCkge1xuICByZXR1cm4gYCR7aW5kZXh9LiR7c3RhdGVOb2RlSWR9YDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKSB7XG4gIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKC9eeHN0YXRlXFwuaW52b2tlXFwuKFxcZCspXFwuKC4qKS8pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmFjdG9yc1tzcmNdO1xuICB9XG4gIGNvbnN0IFssIGluZGV4U3RyLCBub2RlSWRdID0gbWF0Y2g7XG4gIGNvbnN0IG5vZGUgPSBtYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQobm9kZUlkKTtcbiAgY29uc3QgaW52b2tlQ29uZmlnID0gbm9kZS5jb25maWcuaW52b2tlO1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW52b2tlQ29uZmlnKSA/IGludm9rZUNvbmZpZ1tpbmRleFN0cl0gOiBpbnZva2VDb25maWcpLnNyYztcbn1cbmZ1bmN0aW9uIGdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMoc25hcHNob3QpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KFsuLi5zbmFwc2hvdC5fbm9kZXMuZmxhdE1hcChzbiA9PiBzbi5vd25FdmVudHMpXSldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY2hlZHVsZWRFdmVudElkKGFjdG9yUmVmLCBpZCkge1xuICByZXR1cm4gYCR7YWN0b3JSZWYuc2Vzc2lvbklkfS4ke2lkfWA7XG59XG5sZXQgaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZVN5c3RlbShyb290QWN0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGtleWVkQWN0b3JzID0gbmV3IE1hcCgpO1xuICBjb25zdCByZXZlcnNlS2V5ZWRBY3RvcnMgPSBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBpbnNwZWN0aW9uT2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICBjb25zdCB0aW1lck1hcCA9IHt9O1xuICBjb25zdCB7XG4gICAgY2xvY2ssXG4gICAgbG9nZ2VyXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzY2hlZHVsZXIgPSB7XG4gICAgc2NoZWR1bGU6IChzb3VyY2UsIHRhcmdldCwgZXZlbnQsIGRlbGF5LCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpKSA9PiB7XG4gICAgICBjb25zdCBzY2hlZHVsZWRFdmVudCA9IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBkZWxheSxcbiAgICAgICAgaWQsXG4gICAgICAgIHN0YXJ0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgPSBjcmVhdGVTY2hlZHVsZWRFdmVudElkKHNvdXJjZSwgaWQpO1xuICAgICAgc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdID0gc2NoZWR1bGVkRXZlbnQ7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gY2xvY2suc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aW1lck1hcFtzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgICAgZGVsZXRlIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzb3VyY2UsIHRhcmdldCwgZXZlbnQpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgICAgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF0gPSB0aW1lb3V0O1xuICAgIH0sXG4gICAgY2FuY2VsOiAoc291cmNlLCBpZCkgPT4ge1xuICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnRJZCA9IGNyZWF0ZVNjaGVkdWxlZEV2ZW50SWQoc291cmNlLCBpZCk7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICBkZWxldGUgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICBkZWxldGUgc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgaWYgKHRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbG9jay5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWxBbGw6IGFjdG9yUmVmID0+IHtcbiAgICAgIGZvciAoY29uc3Qgc2NoZWR1bGVkRXZlbnRJZCBpbiBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnQgPSBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIGlmIChzY2hlZHVsZWRFdmVudC5zb3VyY2UgPT09IGFjdG9yUmVmKSB7XG4gICAgICAgICAgc2NoZWR1bGVyLmNhbmNlbChhY3RvclJlZiwgc2NoZWR1bGVkRXZlbnQuaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzZW5kSW5zcGVjdGlvbkV2ZW50ID0gZXZlbnQgPT4ge1xuICAgIGlmICghaW5zcGVjdGlvbk9ic2VydmVycy5zaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5zcGVjdGlvbkV2ZW50ID0ge1xuICAgICAgLi4uZXZlbnQsXG4gICAgICByb290SWQ6IHJvb3RBY3Rvci5zZXNzaW9uSWRcbiAgICB9O1xuICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiBvYnNlcnZlci5uZXh0Py4ocmVzb2x2ZWRJbnNwZWN0aW9uRXZlbnQpKTtcbiAgfTtcbiAgY29uc3Qgc3lzdGVtID0ge1xuICAgIF9zbmFwc2hvdDoge1xuICAgICAgX3NjaGVkdWxlZEV2ZW50czogKG9wdGlvbnM/LnNuYXBzaG90ICYmIG9wdGlvbnMuc25hcHNob3Quc2NoZWR1bGVyKSA/PyB7fVxuICAgIH0sXG4gICAgX2Jvb2tJZDogKCkgPT4gYHg6JHtpZENvdW50ZXIrK31gLFxuICAgIF9yZWdpc3RlcjogKHNlc3Npb25JZCwgYWN0b3JSZWYpID0+IHtcbiAgICAgIGNoaWxkcmVuLnNldChzZXNzaW9uSWQsIGFjdG9yUmVmKTtcbiAgICAgIHJldHVybiBzZXNzaW9uSWQ7XG4gICAgfSxcbiAgICBfdW5yZWdpc3RlcjogYWN0b3JSZWYgPT4ge1xuICAgICAgY2hpbGRyZW4uZGVsZXRlKGFjdG9yUmVmLnNlc3Npb25JZCk7XG4gICAgICBjb25zdCBzeXN0ZW1JZCA9IHJldmVyc2VLZXllZEFjdG9ycy5nZXQoYWN0b3JSZWYpO1xuICAgICAgaWYgKHN5c3RlbUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5ZWRBY3RvcnMuZGVsZXRlKHN5c3RlbUlkKTtcbiAgICAgICAgcmV2ZXJzZUtleWVkQWN0b3JzLmRlbGV0ZShhY3RvclJlZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IHN5c3RlbUlkID0+IHtcbiAgICAgIHJldHVybiBrZXllZEFjdG9ycy5nZXQoc3lzdGVtSWQpO1xuICAgIH0sXG4gICAgX3NldDogKHN5c3RlbUlkLCBhY3RvclJlZikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBrZXllZEFjdG9ycy5nZXQoc3lzdGVtSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nICE9PSBhY3RvclJlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdG9yIHdpdGggc3lzdGVtIElEICcke3N5c3RlbUlkfScgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICB9XG4gICAgICBrZXllZEFjdG9ycy5zZXQoc3lzdGVtSWQsIGFjdG9yUmVmKTtcbiAgICAgIHJldmVyc2VLZXllZEFjdG9ycy5zZXQoYWN0b3JSZWYsIHN5c3RlbUlkKTtcbiAgICB9LFxuICAgIGluc3BlY3Q6IG9ic2VydmVyT3JGbiA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIob2JzZXJ2ZXJPckZuKTtcbiAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIF9zZW5kSW5zcGVjdGlvbkV2ZW50OiBzZW5kSW5zcGVjdGlvbkV2ZW50LFxuICAgIF9yZWxheTogKHNvdXJjZSwgdGFyZ2V0LCBldmVudCkgPT4ge1xuICAgICAgc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgICAgdHlwZTogJ0B4c3RhdGUuZXZlbnQnLFxuICAgICAgICBzb3VyY2VSZWY6IHNvdXJjZSxcbiAgICAgICAgYWN0b3JSZWY6IHRhcmdldCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0Ll9zZW5kKGV2ZW50KTtcbiAgICB9LFxuICAgIHNjaGVkdWxlcixcbiAgICBnZXRTbmFwc2hvdDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3NjaGVkdWxlZEV2ZW50czoge1xuICAgICAgICAgIC4uLnN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhcnQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50cyA9IHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cztcbiAgICAgIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBzY2hlZHVsZWRJZCBpbiBzY2hlZHVsZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IHNjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRJZF07XG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZShzb3VyY2UsIHRhcmdldCwgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2xvY2s6IGNsb2NrLFxuICAgIF9sb2dnZXI6IGxvZ2dlclxuICB9O1xuICByZXR1cm4gc3lzdGVtO1xufVxuXG4vLyB0aG9zZSBhcmUgbmVlZGVkIHRvIG1ha2UgSlNEb2MgYEBsaW5rYCB3b3JrIHByb3Blcmx5XG5cbmxldCBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSBmYWxzZTtcbmNvbnN0ICQkQUNUT1JfVFlQRSA9IDE7XG5cbi8vIHRob3NlIHZhbHVlcyBhcmUgY3VycmVudGx5IHVzZWQgYnkgQHhzdGF0ZS9yZWFjdCBkaXJlY3RseSBzbyBpdCdzIGltcG9ydGFudCB0byBrZWVwIHRoZSBhc3NpZ25lZCB2YWx1ZXMgaW4gc3luY1xubGV0IFByb2Nlc3NpbmdTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFByb2Nlc3NpbmdTdGF0dXMpIHtcbiAgUHJvY2Vzc2luZ1N0YXR1c1tQcm9jZXNzaW5nU3RhdHVzW1wiTm90U3RhcnRlZFwiXSA9IDBdID0gXCJOb3RTdGFydGVkXCI7XG4gIFByb2Nlc3NpbmdTdGF0dXNbUHJvY2Vzc2luZ1N0YXR1c1tcIlJ1bm5pbmdcIl0gPSAxXSA9IFwiUnVubmluZ1wiO1xuICBQcm9jZXNzaW5nU3RhdHVzW1Byb2Nlc3NpbmdTdGF0dXNbXCJTdG9wcGVkXCJdID0gMl0gPSBcIlN0b3BwZWRcIjtcbiAgcmV0dXJuIFByb2Nlc3NpbmdTdGF0dXM7XG59KHt9KTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjbG9jazoge1xuICAgIHNldFRpbWVvdXQ6IChmbiwgbXMpID0+IHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gICAgfSxcbiAgICBjbGVhclRpbWVvdXQ6IGlkID0+IHtcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH1cbiAgfSxcbiAgbG9nZ2VyOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICBkZXZUb29sczogZmFsc2Vcbn07XG5cbi8qKlxuICogQW4gQWN0b3IgaXMgYSBydW5uaW5nIHByb2Nlc3MgdGhhdCBjYW4gcmVjZWl2ZSBldmVudHMsIHNlbmQgZXZlbnRzIGFuZCBjaGFuZ2VcbiAqIGl0cyBiZWhhdmlvciBiYXNlZCBvbiB0aGUgZXZlbnRzIGl0IHJlY2VpdmVzLCB3aGljaCBjYW4gY2F1c2UgZWZmZWN0cyBvdXRzaWRlXG4gKiBvZiB0aGUgYWN0b3IuIFdoZW4geW91IHJ1biBhIHN0YXRlIG1hY2hpbmUsIGl0IGJlY29tZXMgYW4gYWN0b3IuXG4gKi9cbmNsYXNzIEFjdG9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYWN0b3IgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBsb2dpYyB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLFxuICAgKiBpZiBhbnkuXG4gICAqXG4gICAqIEBwYXJhbSBsb2dpYyBUaGUgbG9naWMgdG8gY3JlYXRlIGFuIGFjdG9yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgQWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IobG9naWMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2ljID0gbG9naWM7XG4gICAgLyoqIFRoZSBjdXJyZW50IGludGVybmFsIHN0YXRlIG9mIHRoZSBhY3Rvci4gKi9cbiAgICB0aGlzLl9zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xvY2sgdGhhdCBpcyByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbmQgY2xlYXJpbmcgdGltZW91dHMsIHN1Y2ggYXNcbiAgICAgKiBkZWxheWVkIGV2ZW50cyBhbmQgdHJhbnNpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5jbG9jayA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3RvciByZWxhdGl2ZSB0byBpdHMgcGFyZW50LiAqL1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5tYWlsYm94ID0gbmV3IE1haWxib3godGhpcy5fcHJvY2Vzcy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5Ob3RTdGFydGVkO1xuICAgIC8vIEFjdG9yIFJlZlxuICAgIHRoaXMuX3BhcmVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3luY1NuYXBzaG90ID0gdm9pZCAwO1xuICAgIHRoaXMucmVmID0gdm9pZCAwO1xuICAgIC8vIFRPRE86IGFkZCB0eXBpbmdzIGZvciBzeXN0ZW1cbiAgICB0aGlzLl9hY3RvclNjb3BlID0gdm9pZCAwO1xuICAgIHRoaXMuX3N5c3RlbUlkID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZ2xvYmFsbHkgdW5pcXVlIHByb2Nlc3MgSUQgZm9yIHRoaXMgaW52b2NhdGlvbi4gKi9cbiAgICB0aGlzLnNlc3Npb25JZCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHN5c3RlbSB0byB3aGljaCB0aGlzIGFjdG9yIGJlbG9uZ3MuICovXG4gICAgdGhpcy5zeXN0ZW0gPSB2b2lkIDA7XG4gICAgdGhpcy5fZG9uZUV2ZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuc3JjID0gdm9pZCAwO1xuICAgIC8vIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBkZWZlclxuICAgIHRoaXMuX2RlZmVycmVkID0gW107XG4gICAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxvZ2dlcixcbiAgICAgIHBhcmVudCxcbiAgICAgIHN5bmNTbmFwc2hvdCxcbiAgICAgIGlkLFxuICAgICAgc3lzdGVtSWQsXG4gICAgICBpbnNwZWN0XG4gICAgfSA9IHJlc29sdmVkT3B0aW9ucztcbiAgICB0aGlzLnN5c3RlbSA9IHBhcmVudCA/IHBhcmVudC5zeXN0ZW0gOiBjcmVhdGVTeXN0ZW0odGhpcywge1xuICAgICAgY2xvY2ssXG4gICAgICBsb2dnZXJcbiAgICB9KTtcbiAgICBpZiAoaW5zcGVjdCAmJiAhcGFyZW50KSB7XG4gICAgICAvLyBBbHdheXMgaW5zcGVjdCBhdCB0aGUgc3lzdGVtLWxldmVsXG4gICAgICB0aGlzLnN5c3RlbS5pbnNwZWN0KHRvT2JzZXJ2ZXIoaW5zcGVjdCkpO1xuICAgIH1cbiAgICB0aGlzLnNlc3Npb25JZCA9IHRoaXMuc3lzdGVtLl9ib29rSWQoKTtcbiAgICB0aGlzLmlkID0gaWQgPz8gdGhpcy5zZXNzaW9uSWQ7XG4gICAgdGhpcy5sb2dnZXIgPSBvcHRpb25zPy5sb2dnZXIgPz8gdGhpcy5zeXN0ZW0uX2xvZ2dlcjtcbiAgICB0aGlzLmNsb2NrID0gb3B0aW9ucz8uY2xvY2sgPz8gdGhpcy5zeXN0ZW0uX2Nsb2NrO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9zeW5jU25hcHNob3QgPSBzeW5jU25hcHNob3Q7XG4gICAgdGhpcy5vcHRpb25zID0gcmVzb2x2ZWRPcHRpb25zO1xuICAgIHRoaXMuc3JjID0gcmVzb2x2ZWRPcHRpb25zLnNyYyA/PyBsb2dpYztcbiAgICB0aGlzLnJlZiA9IHRoaXM7XG4gICAgdGhpcy5fYWN0b3JTY29wZSA9IHtcbiAgICAgIHNlbGY6IHRoaXMsXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgZGVmZXI6IGZuID0+IHtcbiAgICAgICAgdGhpcy5fZGVmZXJyZWQucHVzaChmbik7XG4gICAgICB9LFxuICAgICAgc3lzdGVtOiB0aGlzLnN5c3RlbSxcbiAgICAgIHN0b3BDaGlsZDogY2hpbGQgPT4ge1xuICAgICAgICBpZiAoY2hpbGQuX3BhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN0b3AgY2hpbGQgYWN0b3IgJHtjaGlsZC5pZH0gb2YgJHt0aGlzLmlkfSBiZWNhdXNlIGl0IGlzIG5vdCBhIGNoaWxkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuX3N0b3AoKTtcbiAgICAgIH0sXG4gICAgICBlbWl0OiBlbWl0dGVkRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChlbWl0dGVkRXZlbnQudHlwZSk7XG4gICAgICAgIGNvbnN0IHdpbGRjYXJkTGlzdGVuZXIgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldCgnKicpO1xuICAgICAgICBpZiAoIWxpc3RlbmVycyAmJiAhd2lsZGNhcmRMaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxMaXN0ZW5lcnMgPSBbLi4uKGxpc3RlbmVycyA/IGxpc3RlbmVycy52YWx1ZXMoKSA6IFtdKSwgLi4uKHdpbGRjYXJkTGlzdGVuZXIgPyB3aWxkY2FyZExpc3RlbmVyLnZhbHVlcygpIDogW10pXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGFsbExpc3RlbmVycykge1xuICAgICAgICAgIGhhbmRsZXIoZW1pdHRlZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjdGlvbkV4ZWN1dG9yOiBhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBleGVjID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2FjdG9yU2NvcGUuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6ICdAeHN0YXRlLmFjdGlvbicsXG4gICAgICAgICAgICBhY3RvclJlZjogdGhpcyxcbiAgICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgICB0eXBlOiBhY3Rpb24udHlwZSxcbiAgICAgICAgICAgICAgcGFyYW1zOiBhY3Rpb24ucGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFhY3Rpb24uZXhlYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzYXZlRXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gZXhlY3V0aW5nQ3VzdG9tQWN0aW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgYWN0aW9uLmV4ZWMoYWN0aW9uLmluZm8sIGFjdGlvbi5wYXJhbXMpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSBzYXZlRXhlY3V0aW5nQ3VzdG9tQWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZykge1xuICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kZWZlcnJlZC5wdXNoKGV4ZWMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBzZW5kIG1ldGhvZCBpcyBib3VuZCB0byB0aGlzIEFjdG9yIGluc3RhbmNlXG4gICAgLy8gaWYgZGVzdHJ1Y3R1cmVkXG4gICAgdGhpcy5zZW5kID0gdGhpcy5zZW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgdHlwZTogJ0B4c3RhdGUuYWN0b3InLFxuICAgICAgYWN0b3JSZWY6IHRoaXNcbiAgICB9KTtcbiAgICBpZiAoc3lzdGVtSWQpIHtcbiAgICAgIHRoaXMuX3N5c3RlbUlkID0gc3lzdGVtSWQ7XG4gICAgICB0aGlzLnN5c3RlbS5fc2V0KHN5c3RlbUlkLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdFN0YXRlKG9wdGlvbnM/LnNuYXBzaG90ID8/IG9wdGlvbnM/LnN0YXRlKTtcbiAgICBpZiAoc3lzdGVtSWQgJiYgdGhpcy5fc25hcHNob3Quc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgdGhpcy5zeXN0ZW0uX3VucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIF9pbml0U3RhdGUocGVyc2lzdGVkU3RhdGUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc25hcHNob3QgPSBwZXJzaXN0ZWRTdGF0ZSA/IHRoaXMubG9naWMucmVzdG9yZVNuYXBzaG90ID8gdGhpcy5sb2dpYy5yZXN0b3JlU25hcHNob3QocGVyc2lzdGVkU3RhdGUsIHRoaXMuX2FjdG9yU2NvcGUpIDogcGVyc2lzdGVkU3RhdGUgOiB0aGlzLmxvZ2ljLmdldEluaXRpYWxTbmFwc2hvdCh0aGlzLl9hY3RvclNjb3BlLCB0aGlzLm9wdGlvbnM/LmlucHV0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGlmIHdlIGdldCBoZXJlIHRoZW4gaXQgbWVhbnMgdGhhdCB3ZSBhc3NpZ24gYSB2YWx1ZSB0byB0aGlzLl9zbmFwc2hvdCB0aGF0IGlzIG5vdCBvZiB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAvLyB3ZSBjYW4ndCBnZXQgdGhlIHRydWUgYFRTbmFwc2hvdCAmIHsgc3RhdHVzOiAnZXJyb3InOyB9YCwgaXQncyBpbXBvc3NpYmxlXG4gICAgICAvLyBzbyByaWdodCBub3cgdGhpcyBpcyBhIGxpZSBvZiBzb3J0c1xuICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHVwZGF0ZShzbmFwc2hvdCwgZXZlbnQpIHtcbiAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICB0aGlzLl9zbmFwc2hvdCA9IHNuYXBzaG90O1xuXG4gICAgLy8gRXhlY3V0ZSBkZWZlcnJlZCBlZmZlY3RzXG4gICAgbGV0IGRlZmVycmVkRm47XG4gICAgd2hpbGUgKGRlZmVycmVkRm4gPSB0aGlzLl9kZWZlcnJlZC5zaGlmdCgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWZlcnJlZEZuKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gdGhpcyBlcnJvciBjYW4gb25seSBiZSBjYXVnaHQgd2hlbiBleGVjdXRpbmcgKmluaXRpYWwqIGFjdGlvbnNcbiAgICAgICAgLy8gaXQncyB0aGUgb25seSB0aW1lIHdoZW4gd2UgY2FsbCBhY3Rpb25zIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIHRocm91Z2ggdGhvc2UgZGVmZXJyZWRzXG4gICAgICAgIC8vIHdoZW4gdGhlIGFjdG9yIGlzIGFscmVhZHkgcnVubmluZyB3ZSBhbHdheXMgZXhlY3V0ZSB0aGVtIHN5bmNocm9ub3VzbHkgd2hpbGUgdHJhbnNpdGlvbmluZ1xuICAgICAgICAvLyBubyBcImJ1aWx0aW4gZGVmZXJyZWRcIiBzaG91bGQgYWN0dWFsbHkgdGhyb3cgYW4gZXJyb3Igc2luY2UgdGhleSBhcmUgZWl0aGVyIHNhZmVcbiAgICAgICAgLy8gb3IgdGhlIGNvbnRyb2wgZmxvdyBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgbWFpbGJveCBhbmQgZXJyb3JzIHNob3VsZCBiZSBjYXVnaHQgYnkgdGhlIGBfcHJvY2Vzc2AgdXNlZCBieSB0aGUgbWFpbGJveFxuICAgICAgICB0aGlzLl9kZWZlcnJlZC5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHtcbiAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuX3NuYXBzaG90LnN0YXR1cykge1xuICAgICAgY2FzZSAnYWN0aXZlJzpcbiAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4oc25hcHNob3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgLy8gbmV4dCBvYnNlcnZlcnMgYXJlIG1lYW50IHRvIGJlIG5vdGlmaWVkIGFib3V0IGRvbmUgc25hcHNob3RzXG4gICAgICAgIC8vIHRoaXMgY2FuIGJlIHNlZW4gYXMgc29tZXRoaW5nIHRoYXQgaXMgZGlmZmVyZW50IGZyb20gaG93IG9ic2VydmFibGUgd29ya1xuICAgICAgICAvLyBidXQgd2l0aCBvYnNlcnZhYmxlcyBgY29tcGxldGVgIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRob3V0IGFueSBhcmd1bWVudHNcbiAgICAgICAgLy8gaXQncyBtb3JlIGVyZ29ub21pYyBmb3IgWFN0YXRlIHRvIHRyZWF0IGEgZG9uZSBzbmFwc2hvdCBhcyBhIFwibmV4dFwiIHZhbHVlXG4gICAgICAgIC8vIGFuZCB0aGUgY29tcGxldGlvbiBldmVudCBhcyBzb21ldGhpbmcgdGhhdCBpcyBzZXBhcmF0ZSxcbiAgICAgICAgLy8gc29tZXRoaW5nIHRoYXQgbWVyZWx5IGZvbGxvd3MgZW1pdHRpbmcgdGhhdCBkb25lIHNuYXBzaG90XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3BQcm9jZWR1cmUoKTtcbiAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5fZG9uZUV2ZW50ID0gY3JlYXRlRG9uZUFjdG9yRXZlbnQodGhpcy5pZCwgdGhpcy5fc25hcHNob3Qub3V0cHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgIHRoaXMuc3lzdGVtLl9yZWxheSh0aGlzLCB0aGlzLl9wYXJlbnQsIHRoaXMuX2RvbmVFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHRoaXMuX2Vycm9yKHRoaXMuX3NuYXBzaG90LmVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgIHR5cGU6ICdAeHN0YXRlLnNuYXBzaG90JyxcbiAgICAgIGFjdG9yUmVmOiB0aGlzLFxuICAgICAgZXZlbnQsXG4gICAgICBzbmFwc2hvdFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBhbiBvYnNlcnZlciB0byBhbiBhY3RvcuKAmXMgc25hcHNob3QgdmFsdWVzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgb2JzZXJ2ZXIgd2lsbCByZWNlaXZlIHRoZSBhY3RvcuKAmXMgc25hcHNob3QgdmFsdWUgd2hlbiBpdCBpcyBlbWl0dGVkLlxuICAgKiBUaGUgb2JzZXJ2ZXIgY2FuIGJlOlxuICAgKlxuICAgKiAtIEEgcGxhaW4gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbGF0ZXN0IHNuYXBzaG90LCBvclxuICAgKiAtIEFuIG9ic2VydmVyIG9iamVjdCB3aG9zZSBgLm5leHQoc25hcHNob3QpYCBtZXRob2QgcmVjZWl2ZXMgdGhlIGxhdGVzdFxuICAgKiAgIHNuYXBzaG90XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIE9ic2VydmVyIGFzIGEgcGxhaW4gZnVuY3Rpb25cbiAgICogY29uc3Qgc3Vic2NyaXB0aW9uID0gYWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBPYnNlcnZlciBhcyBhbiBvYmplY3RcbiAgICogY29uc3Qgc3Vic2NyaXB0aW9uID0gYWN0b3Iuc3Vic2NyaWJlKHtcbiAgICogICBuZXh0KHNuYXBzaG90KSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gICAqICAgfSxcbiAgICogICBlcnJvcihlcnIpIHtcbiAgICogICAgIC8vIC4uLlxuICAgKiAgIH0sXG4gICAqICAgY29tcGxldGUoKSB7XG4gICAqICAgICAvLyAuLi5cbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHJldHVybiB2YWx1ZSBvZiBgYWN0b3Iuc3Vic2NyaWJlKG9ic2VydmVyKWAgaXMgYSBzdWJzY3JpcHRpb24gb2JqZWN0XG4gICAqIHRoYXQgaGFzIGFuIGAudW5zdWJzY3JpYmUoKWAgbWV0aG9kLiBZb3UgY2FuIGNhbGxcbiAgICogYHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpYCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2ZXI6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAgICogICAvLyAuLi5cbiAgICogfSk7XG4gICAqXG4gICAqIC8vIFVuc3Vic2NyaWJlIHRoZSBvYnNlcnZlclxuICAgKiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFdoZW4gdGhlIGFjdG9yIGlzIHN0b3BwZWQsIGFsbCBvZiBpdHMgb2JzZXJ2ZXJzIHdpbGwgYXV0b21hdGljYWxseSBiZVxuICAgKiB1bnN1YnNjcmliZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvYnNlcnZlciAtIEVpdGhlciBhIHBsYWluIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdFxuICAgKiAgIHNuYXBzaG90LCBvciBhbiBvYnNlcnZlciBvYmplY3Qgd2hvc2UgYC5uZXh0KHNuYXBzaG90KWAgbWV0aG9kIHJlY2VpdmVzXG4gICAqICAgdGhlIGxhdGVzdCBzbmFwc2hvdFxuICAgKi9cblxuICBzdWJzY3JpYmUobmV4dExpc3RlbmVyT3JPYnNlcnZlciwgZXJyb3JMaXN0ZW5lciwgY29tcGxldGVMaXN0ZW5lcikge1xuICAgIGNvbnN0IG9ic2VydmVyID0gdG9PYnNlcnZlcihuZXh0TGlzdGVuZXJPck9ic2VydmVyLCBlcnJvckxpc3RlbmVyLCBjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyAhPT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICB0aGlzLm9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3NuYXBzaG90LnN0YXR1cykge1xuICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9zbmFwc2hvdC5lcnJvcjtcbiAgICAgICAgICAgIGlmICghb2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQodHlwZSk7XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2V0KHR5cGUsIGxpc3RlbmVycyk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRIYW5kbGVyID0gaGFuZGxlci5iaW5kKHVuZGVmaW5lZCk7XG4gICAgbGlzdGVuZXJzLmFkZCh3cmFwcGVkSGFuZGxlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVycy5kZWxldGUod3JhcHBlZEhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiogU3RhcnRzIHRoZSBBY3RvciBmcm9tIHRoZSBpbml0aWFsIHN0YXRlICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgIC8vIERvIG5vdCByZXN0YXJ0IHRoZSBzZXJ2aWNlIGlmIGl0IGlzIGFscmVhZHkgc3RhcnRlZFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zeW5jU25hcHNob3QpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xuICAgICAgICAgIGlmIChzbmFwc2hvdC5zdGF0dXMgPT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICB0aGlzLnN5c3RlbS5fcmVsYXkodGhpcywgdGhpcy5fcGFyZW50LCB7XG4gICAgICAgICAgICAgIHR5cGU6IGB4c3RhdGUuc25hcHNob3QuJHt0aGlzLmlkfWAsXG4gICAgICAgICAgICAgIHNuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiAoKSA9PiB7fVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtLl9yZWdpc3Rlcih0aGlzLnNlc3Npb25JZCwgdGhpcyk7XG4gICAgaWYgKHRoaXMuX3N5c3RlbUlkKSB7XG4gICAgICB0aGlzLnN5c3RlbS5fc2V0KHRoaXMuX3N5c3RlbUlkLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZztcblxuICAgIC8vIFRPRE86IHRoaXMgaXNuJ3QgY29ycmVjdCB3aGVuIHJlaHlkcmF0aW5nXG4gICAgY29uc3QgaW5pdEV2ZW50ID0gY3JlYXRlSW5pdEV2ZW50KHRoaXMub3B0aW9ucy5pbnB1dCk7XG4gICAgdGhpcy5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgdHlwZTogJ0B4c3RhdGUuZXZlbnQnLFxuICAgICAgc291cmNlUmVmOiB0aGlzLl9wYXJlbnQsXG4gICAgICBhY3RvclJlZjogdGhpcyxcbiAgICAgIGV2ZW50OiBpbml0RXZlbnRcbiAgICB9KTtcbiAgICBjb25zdCBzdGF0dXMgPSB0aGlzLl9zbmFwc2hvdC5zdGF0dXM7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAvLyBhIHN0YXRlIG1hY2hpbmUgY2FuIGJlIFwiZG9uZVwiIHVwb24gaW5pdGlhbGl6YXRpb24gKGl0IGNvdWxkIHJlYWNoIGEgZmluYWwgc3RhdGUgdXNpbmcgaW5pdGlhbCBtaWNyb3N0ZXBzKVxuICAgICAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIGNvbXBsZXRlIG9ic2VydmVycywgZmx1c2ggZGVmZXJyZWRzIGV0Y1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLl9zbmFwc2hvdCwgaW5pdEV2ZW50KTtcbiAgICAgICAgLy8gVE9ETzogcmV0aGluayBjbGVhbnVwIG9mIG9ic2VydmVycywgbWFpbGJveCwgZXRjXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB0aGlzLl9lcnJvcih0aGlzLl9zbmFwc2hvdC5lcnJvcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xuICAgICAgdGhpcy5zeXN0ZW0uc3RhcnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9naWMuc3RhcnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9naWMuc3RhcnQodGhpcy5fc25hcHNob3QsIHRoaXMuX2FjdG9yU2NvcGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICAgIC4uLnRoaXMuX3NuYXBzaG90LFxuICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgbm90aWZpZXMgYWxsIHN1YnNjcmliZXJzIGJ1dCB1c3VhbGx5IHRoaXMgaXMgcmVkdW5kYW50XG4gICAgLy8gdGhlcmUgaXMgbm8gcmVhbCBjaGFuZ2UgaGFwcGVuaW5nIGhlcmVcbiAgICAvLyB3ZSBuZWVkIHRvIHJldGhpbmsgaWYgdGhpcyBuZWVkcyB0byBiZSByZWZhY3RvcmVkXG4gICAgdGhpcy51cGRhdGUodGhpcy5fc25hcHNob3QsIGluaXRFdmVudCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZXZUb29scykge1xuICAgICAgdGhpcy5hdHRhY2hEZXZUb29scygpO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guc3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfcHJvY2VzcyhldmVudCkge1xuICAgIGxldCBuZXh0U3RhdGU7XG4gICAgbGV0IGNhdWdodEVycm9yO1xuICAgIHRyeSB7XG4gICAgICBuZXh0U3RhdGUgPSB0aGlzLmxvZ2ljLnRyYW5zaXRpb24odGhpcy5fc25hcHNob3QsIGV2ZW50LCB0aGlzLl9hY3RvclNjb3BlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHdlIHdyYXAgaXQgaW4gYSBib3ggc28gd2UgY2FuIHJldGhyb3cgaXQgbGF0ZXIgZXZlbiBpZiBmYWxzeSB2YWx1ZSBnZXRzIGNhdWdodCBoZXJlXG4gICAgICBjYXVnaHRFcnJvciA9IHtcbiAgICAgICAgZXJyXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXJyXG4gICAgICB9ID0gY2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLl9zbmFwc2hvdCA9IHtcbiAgICAgICAgLi4udGhpcy5fc25hcHNob3QsXG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfTtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKG5leHRTdGF0ZSwgZXZlbnQpO1xuICAgIGlmIChldmVudC50eXBlID09PSBYU1RBVEVfU1RPUCkge1xuICAgICAgdGhpcy5fc3RvcFByb2NlZHVyZSgpO1xuICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbiAgX3N0b3AoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5jbGVhcigpO1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLk5vdFN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LmVucXVldWUoe1xuICAgICAgdHlwZTogWFNUQVRFX1NUT1BcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBTdG9wcyB0aGUgQWN0b3IgYW5kIHVuc3Vic2NyaWJlIGFsbCBsaXN0ZW5lcnMuICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG5vbi1yb290IGFjdG9yIGNhbm5vdCBiZSBzdG9wcGVkIGRpcmVjdGx5LicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RvcCgpO1xuICB9XG4gIF9jb21wbGV0ZSgpIHtcbiAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnMuY2xlYXIoKTtcbiAgfVxuICBfcmVwb3J0RXJyb3IoZXJyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5zaXplKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmVwb3J0RXJyb3IgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICBjb25zdCBlcnJvckxpc3RlbmVyID0gb2JzZXJ2ZXIuZXJyb3I7XG4gICAgICByZXBvcnRFcnJvciB8fD0gIWVycm9yTGlzdGVuZXI7XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckxpc3RlbmVyPy4oZXJyKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgaWYgKHJlcG9ydEVycm9yKSB7XG4gICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICBfZXJyb3IoZXJyKSB7XG4gICAgdGhpcy5fc3RvcFByb2NlZHVyZSgpO1xuICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycik7XG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHRoaXMsIHRoaXMuX3BhcmVudCwgY3JlYXRlRXJyb3JBY3RvckV2ZW50KHRoaXMuaWQsIGVycikpO1xuICAgIH1cbiAgfVxuICAvLyBUT0RPOiBhdG0gY2hpbGRyZW4gZG9uJ3QgYmVsb25nIGVudGlyZWx5IHRvIHRoZSBhY3RvciBzb1xuICAvLyBpbiBhIHdheSAtIGl0J3Mgbm90IGV2ZW4gc3VwZXIgYXdhcmUgb2YgdGhlbVxuICAvLyBzbyB3ZSBjYW4ndCBzdG9wIHRoZW0gZnJvbSBoZXJlIGJ1dCB3ZSByZWFsbHkgc2hvdWxkIVxuICAvLyByaWdodCBub3csIHRoZXkgYXJlIGJlaW5nIHN0b3BwZWQgd2l0aGluIHRoZSBtYWNoaW5lJ3MgdHJhbnNpdGlvblxuICAvLyBidXQgdGhhdCBjb3VsZCB0aHJvdyBhbmQgbGVhdmUgdXMgd2l0aCBcIm9ycGhhbmVkXCIgYWN0aXZlIGFjdG9yc1xuICBfc3RvcFByb2NlZHVyZSgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyAhPT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAvLyBBY3RvciBhbHJlYWR5IHN0b3BwZWQ7IGRvIG5vdGhpbmdcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIENhbmNlbCBhbGwgZGVsYXllZCBldmVudHNcbiAgICB0aGlzLnN5c3RlbS5zY2hlZHVsZXIuY2FuY2VsQWxsKHRoaXMpO1xuXG4gICAgLy8gVE9ETzogbWFpbGJveC5yZXNldFxuICAgIHRoaXMubWFpbGJveC5jbGVhcigpO1xuICAgIC8vIFRPRE86IGFmdGVyIGBzdG9wYCB3ZSBtdXN0IHByZXBhcmUgb3Vyc2VsdmVzIGZvciByZWNlaXZpbmcgZXZlbnRzIGFnYWluXG4gICAgLy8gZXZlbnRzIHNlbnQgKmFmdGVyKiBzdG9wIHNpZ25hbCBtdXN0IGJlIHF1ZXVlZFxuICAgIC8vIGl0IHNlZW1zIGxpa2UgdGhpcyBzaG91bGQgYmUgdGhlIGNvbW1vbiBiZWhhdmlvciBmb3IgYWxsIG9mIG91ciBjb25zdW1lcnNcbiAgICAvLyBzbyBwZXJoYXBzIHRoaXMgc2hvdWxkIGJlIHVuaWZpZWQgc29tZWhvdyBmb3IgYWxsIG9mIHRoZW1cbiAgICB0aGlzLm1haWxib3ggPSBuZXcgTWFpbGJveCh0aGlzLl9wcm9jZXNzLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQ7XG4gICAgdGhpcy5zeXN0ZW0uX3VucmVnaXN0ZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9zZW5kKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAge1xuICAgICAgICBjb25zdCBldmVudFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV2ZW50KTtcbiAgICAgICAgY29uc29sZS53YXJuKGBFdmVudCBcIiR7ZXZlbnQudHlwZX1cIiB3YXMgc2VudCB0byBzdG9wcGVkIGFjdG9yIFwiJHt0aGlzLmlkfSAoJHt0aGlzLnNlc3Npb25JZH0pXCIuIFRoaXMgYWN0b3IgaGFzIGFscmVhZHkgcmVhY2hlZCBpdHMgZmluYWwgc3RhdGUsIGFuZCB3aWxsIG5vdCB0cmFuc2l0aW9uLlxcbkV2ZW50OiAke2V2ZW50U3RyaW5nfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guZW5xdWV1ZShldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIHJ1bm5pbmcgQWN0b3IgdG8gdHJpZ2dlciBhIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZFxuICAgKi9cbiAgc2VuZChldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgZXZlbnQgb2JqZWN0cyBtYXkgYmUgc2VudCB0byBhY3RvcnM7IHVzZSAuc2VuZCh7IHR5cGU6IFwiJHtldmVudH1cIiB9KSBpbnN0ZWFkYCk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtLl9yZWxheSh1bmRlZmluZWQsIHRoaXMsIGV2ZW50KTtcbiAgfVxuICBhdHRhY2hEZXZUb29scygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZXZUb29sc1xuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGRldlRvb2xzKSB7XG4gICAgICBjb25zdCByZXNvbHZlZERldlRvb2xzQWRhcHRlciA9IHR5cGVvZiBkZXZUb29scyA9PT0gJ2Z1bmN0aW9uJyA/IGRldlRvb2xzIDogZGV2VG9vbHNBZGFwdGVyO1xuICAgICAgcmVzb2x2ZWREZXZUb29sc0FkYXB0ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeHN0YXRlJCR0eXBlOiAkJEFDVE9SX1RZUEUsXG4gICAgICBpZDogdGhpcy5pZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogT2J0YWluIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgYWN0b3IsIHdoaWNoIGNhbiBiZSBwZXJzaXN0ZWQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBpbnRlcm5hbCBzdGF0ZSBjYW4gYmUgcGVyc2lzdGVkIGZyb20gYW55IGFjdG9yLCBub3Qgb25seSBtYWNoaW5lcy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBwZXJzaXN0ZWQgc3RhdGUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBzbmFwc2hvdCBmcm9tXG4gICAqIHtAbGluayBBY3Rvci5nZXRTbmFwc2hvdH0uIFBlcnNpc3RlZCBzdGF0ZSByZXByZXNlbnRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZlxuICAgKiB0aGUgYWN0b3IsIHdoaWxlIHNuYXBzaG90cyByZXByZXNlbnQgdGhlIGFjdG9yJ3MgbGFzdCBlbWl0dGVkIHZhbHVlLlxuICAgKlxuICAgKiBDYW4gYmUgcmVzdG9yZWQgd2l0aCB7QGxpbmsgQWN0b3JPcHRpb25zLnN0YXRlfVxuICAgKiBAc2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL3BlcnNpc3RlbmNlXG4gICAqL1xuXG4gIGdldFBlcnNpc3RlZFNuYXBzaG90KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dpYy5nZXRQZXJzaXN0ZWRTbmFwc2hvdCh0aGlzLl9zbmFwc2hvdCwgb3B0aW9ucyk7XG4gIH1cbiAgW3N5bWJvbE9ic2VydmFibGVdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYW4gYWN0b3LigJlzIHNuYXBzaG90IHN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBzbmFwc2hvdCByZXByZXNlbnQgYW4gYWN0b3IncyBsYXN0IGVtaXR0ZWQgdmFsdWUuXG4gICAqXG4gICAqIFdoZW4gYW4gYWN0b3IgcmVjZWl2ZXMgYW4gZXZlbnQsIGl0cyBpbnRlcm5hbCBzdGF0ZSBtYXkgY2hhbmdlLiBBbiBhY3RvclxuICAgKiBtYXkgZW1pdCBhIHNuYXBzaG90IHdoZW4gYSBzdGF0ZSB0cmFuc2l0aW9uIG9jY3Vycy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHNvbWUgYWN0b3JzLCBzdWNoIGFzIGNhbGxiYWNrIGFjdG9ycyBnZW5lcmF0ZWQgd2l0aFxuICAgKiBgZnJvbUNhbGxiYWNrYCwgd2lsbCBub3QgZW1pdCBzbmFwc2hvdHMuXG4gICAqIEBzZWUge0BsaW5rIEFjdG9yLnN1YnNjcmliZX0gdG8gc3Vic2NyaWJlIHRvIGFuIGFjdG9y4oCZcyBzbmFwc2hvdCB2YWx1ZXMuXG4gICAqIEBzZWUge0BsaW5rIEFjdG9yLmdldFBlcnNpc3RlZFNuYXBzaG90fSB0byBwZXJzaXN0IHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBhbiBhY3RvciAod2hpY2ggaXMgbW9yZSB0aGFuIGp1c3QgYSBzbmFwc2hvdCkuXG4gICAqL1xuICBnZXRTbmFwc2hvdCgpIHtcbiAgICBpZiAoIXRoaXMuX3NuYXBzaG90KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXBzaG90IGNhbid0IGJlIHJlYWQgd2hpbGUgdGhlIGFjdG9yIGluaXRpYWxpemVzIGl0c2VsZmApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc25hcHNob3Q7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhY3RvciBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFjdG9yIGxvZ2ljIHdpdGggdGhlIHByb3ZpZGVkXG4gKiBvcHRpb25zLCBpZiBhbnkuXG4gKlxuICogQHJlbWFya3NcbiAqIFdoZW4geW91IGNyZWF0ZSBhbiBhY3RvciBmcm9tIGFjdG9yIGxvZ2ljIHZpYSBgY3JlYXRlQWN0b3IobG9naWMpYCwgeW91XG4gKiBpbXBsaWNpdGx5IGNyZWF0ZSBhbiBhY3RvciBzeXN0ZW0gd2hlcmUgdGhlIGNyZWF0ZWQgYWN0b3IgaXMgdGhlIHJvb3QgYWN0b3IuXG4gKiBBbnkgYWN0b3JzIHNwYXduZWQgZnJvbSB0aGlzIHJvb3QgYWN0b3IgYW5kIGl0cyBkZXNjZW5kYW50cyBhcmUgcGFydCBvZiB0aGF0XG4gKiBhY3RvciBzeXN0ZW0uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVBY3RvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBzb21lQWN0b3JMb2dpYyB9IGZyb20gJy4vc29tZUFjdG9yTG9naWMudHMnO1xuICpcbiAqIC8vIENyZWF0aW5nIHRoZSBhY3Rvciwgd2hpY2ggaW1wbGljaXRseSBjcmVhdGVzIGFuIGFjdG9yIHN5c3RlbSB3aXRoIGl0c2VsZiBhcyB0aGUgcm9vdCBhY3RvclxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihzb21lQWN0b3JMb2dpYyk7XG4gKlxuICogYWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqXG4gKiAvLyBBY3RvcnMgbXVzdCBiZSBzdGFydGVkIGJ5IGNhbGxpbmcgYGFjdG9yLnN0YXJ0KClgLCB3aGljaCB3aWxsIGFsc28gc3RhcnQgdGhlIGFjdG9yIHN5c3RlbS5cbiAqIGFjdG9yLnN0YXJ0KCk7XG4gKlxuICogLy8gQWN0b3JzIGNhbiByZWNlaXZlIGV2ZW50c1xuICogYWN0b3Iuc2VuZCh7IHR5cGU6ICdzb21lRXZlbnQnIH0pO1xuICpcbiAqIC8vIFlvdSBjYW4gc3RvcCByb290IGFjdG9ycyBieSBjYWxsaW5nIGBhY3Rvci5zdG9wKClgLCB3aGljaCB3aWxsIGFsc28gc3RvcCB0aGUgYWN0b3Igc3lzdGVtIGFuZCBhbGwgYWN0b3JzIGluIHRoYXQgc3lzdGVtLlxuICogYWN0b3Iuc3RvcCgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGxvZ2ljIC0gVGhlIGFjdG9yIGxvZ2ljIHRvIGNyZWF0ZSBhbiBhY3RvciBmcm9tLiBGb3IgYSBzdGF0ZSBtYWNoaW5lXG4gKiAgIGFjdG9yIGxvZ2ljIGNyZWF0b3IsIHNlZSB7QGxpbmsgY3JlYXRlTWFjaGluZX0uIE90aGVyIGFjdG9yIGxvZ2ljIGNyZWF0b3JzXG4gKiAgIGluY2x1ZGUge0BsaW5rIGZyb21DYWxsYmFja30sIHtAbGluayBmcm9tRXZlbnRPYnNlcnZhYmxlfSxcbiAqICAge0BsaW5rIGZyb21PYnNlcnZhYmxlfSwge0BsaW5rIGZyb21Qcm9taXNlfSwgYW5kIHtAbGluayBmcm9tVHJhbnNpdGlvbn0uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFjdG9yIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWN0b3IobG9naWMsIC4uLltvcHRpb25zXSkge1xuICByZXR1cm4gbmV3IEFjdG9yKGxvZ2ljLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEludGVycHJldGVyIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbWFjaGluZSB3aXRoIHRoZSBwcm92aWRlZFxuICogb3B0aW9ucywgaWYgYW55LlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgY3JlYXRlQWN0b3JgIGluc3RlYWRcbiAqIEBhbGlhc1xuICovXG5jb25zdCBpbnRlcnByZXQgPSBjcmVhdGVBY3RvcjtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYEFjdG9yYCBpbnN0ZWFkLlxuICogQGFsaWFzXG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUNhbmNlbChfLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIHNlbmRJZFxufSkge1xuICBjb25zdCByZXNvbHZlZFNlbmRJZCA9IHR5cGVvZiBzZW5kSWQgPT09ICdmdW5jdGlvbicgPyBzZW5kSWQoYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zKSA6IHNlbmRJZDtcbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIHNlbmRJZDogcmVzb2x2ZWRTZW5kSWRcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVDYW5jZWwoYWN0b3JTY29wZSwgcGFyYW1zKSB7XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGFjdG9yU2NvcGUuc3lzdGVtLnNjaGVkdWxlci5jYW5jZWwoYWN0b3JTY29wZS5zZWxmLCBwYXJhbXMuc2VuZElkKTtcbiAgfSk7XG59XG4vKipcbiAqIENhbmNlbHMgYSBkZWxheWVkIGBzZW5kVG8oLi4uKWAgYWN0aW9uIHRoYXQgaXMgd2FpdGluZyB0byBiZSBleGVjdXRlZC4gVGhlXG4gKiBjYW5jZWxlZCBgc2VuZFRvKC4uLilgIGFjdGlvbiB3aWxsIG5vdCBzZW5kIGl0cyBldmVudCBvciBleGVjdXRlLCB1bmxlc3MgdGhlXG4gKiBgZGVsYXlgIGhhcyBhbHJlYWR5IGVsYXBzZWQgYmVmb3JlIGBjYW5jZWwoLi4uKWAgaXMgY2FsbGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIHNlbmRUbywgY2FuY2VsIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIC8vIC4uLlxuICogICBvbjoge1xuICogICAgIHNlbmRFdmVudDoge1xuICogICAgICAgYWN0aW9uczogc2VuZFRvKFxuICogICAgICAgICAnc29tZS1hY3RvcicsXG4gKiAgICAgICAgIHsgdHlwZTogJ3NvbWVFdmVudCcgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIGlkOiAnc29tZS1pZCcsXG4gKiAgICAgICAgICAgZGVsYXk6IDEwMDBcbiAqICAgICAgICAgfVxuICogICAgICAgKVxuICogICAgIH0sXG4gKiAgICAgY2FuY2VsRXZlbnQ6IHtcbiAqICAgICAgIGFjdGlvbnM6IGNhbmNlbCgnc29tZS1pZCcpXG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZW5kSWQgVGhlIGBpZGAgb2YgdGhlIGBzZW5kVG8oLi4uKWAgYWN0aW9uIHRvIGNhbmNlbC5cbiAqL1xuZnVuY3Rpb24gY2FuY2VsKHNlbmRJZCkge1xuICBmdW5jdGlvbiBjYW5jZWwoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGNhbmNlbC50eXBlID0gJ3hzdGF0ZS5jYW5jZWwnO1xuICBjYW5jZWwuc2VuZElkID0gc2VuZElkO1xuICBjYW5jZWwucmVzb2x2ZSA9IHJlc29sdmVDYW5jZWw7XG4gIGNhbmNlbC5leGVjdXRlID0gZXhlY3V0ZUNhbmNlbDtcbiAgcmV0dXJuIGNhbmNlbDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNwYXduKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhY3Rpb25BcmdzLCBfYWN0aW9uUGFyYW1zLCB7XG4gIGlkLFxuICBzeXN0ZW1JZCxcbiAgc3JjLFxuICBpbnB1dCxcbiAgc3luY1NuYXBzaG90XG59KSB7XG4gIGNvbnN0IGxvZ2ljID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yKHNuYXBzaG90Lm1hY2hpbmUsIHNyYykgOiBzcmM7XG4gIGNvbnN0IHJlc29sdmVkSWQgPSB0eXBlb2YgaWQgPT09ICdmdW5jdGlvbicgPyBpZChhY3Rpb25BcmdzKSA6IGlkO1xuICBsZXQgYWN0b3JSZWY7XG4gIGxldCByZXNvbHZlZElucHV0ID0gdW5kZWZpbmVkO1xuICBpZiAobG9naWMpIHtcbiAgICByZXNvbHZlZElucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID8gaW5wdXQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGV2ZW50OiBhY3Rpb25BcmdzLmV2ZW50LFxuICAgICAgc2VsZjogYWN0b3JTY29wZS5zZWxmXG4gICAgfSkgOiBpbnB1dDtcbiAgICBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7XG4gICAgICBpZDogcmVzb2x2ZWRJZCxcbiAgICAgIHNyYyxcbiAgICAgIHBhcmVudDogYWN0b3JTY29wZS5zZWxmLFxuICAgICAgc3luY1NuYXBzaG90LFxuICAgICAgc3lzdGVtSWQsXG4gICAgICBpbnB1dDogcmVzb2x2ZWRJbnB1dFxuICAgIH0pO1xuICB9XG4gIGlmICghYWN0b3JSZWYpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICBgQWN0b3IgdHlwZSAnJHtzcmN9JyBub3QgZm91bmQgaW4gbWFjaGluZSAnJHthY3RvclNjb3BlLmlkfScuYCk7XG4gIH1cbiAgcmV0dXJuIFtjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgIGNoaWxkcmVuOiB7XG4gICAgICAuLi5zbmFwc2hvdC5jaGlsZHJlbixcbiAgICAgIFtyZXNvbHZlZElkXTogYWN0b3JSZWZcbiAgICB9XG4gIH0pLCB7XG4gICAgaWQsXG4gICAgc3lzdGVtSWQsXG4gICAgYWN0b3JSZWYsXG4gICAgc3JjLFxuICAgIGlucHV0OiByZXNvbHZlZElucHV0XG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlU3Bhd24oYWN0b3JTY29wZSwge1xuICBhY3RvclJlZlxufSkge1xuICBpZiAoIWFjdG9yUmVmKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGlmIChhY3RvclJlZi5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdG9yUmVmLnN0YXJ0KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3Bhd25DaGlsZCguLi5bc3JjLCB7XG4gIGlkLFxuICBzeXN0ZW1JZCxcbiAgaW5wdXQsXG4gIHN5bmNTbmFwc2hvdCA9IGZhbHNlXG59ID0ge31dKSB7XG4gIGZ1bmN0aW9uIHNwYXduQ2hpbGQoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHNwYXduQ2hpbGQudHlwZSA9ICd4c3RhdGUuc3Bhd25DaGlsZCc7XG4gIHNwYXduQ2hpbGQuaWQgPSBpZDtcbiAgc3Bhd25DaGlsZC5zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuICBzcGF3bkNoaWxkLnNyYyA9IHNyYztcbiAgc3Bhd25DaGlsZC5pbnB1dCA9IGlucHV0O1xuICBzcGF3bkNoaWxkLnN5bmNTbmFwc2hvdCA9IHN5bmNTbmFwc2hvdDtcbiAgc3Bhd25DaGlsZC5yZXNvbHZlID0gcmVzb2x2ZVNwYXduO1xuICBzcGF3bkNoaWxkLmV4ZWN1dGUgPSBleGVjdXRlU3Bhd247XG4gIHJldHVybiBzcGF3bkNoaWxkO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU3RvcChfLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGFjdG9yUmVmXG59KSB7XG4gIGNvbnN0IGFjdG9yUmVmT3JTdHJpbmcgPSB0eXBlb2YgYWN0b3JSZWYgPT09ICdmdW5jdGlvbicgPyBhY3RvclJlZihhcmdzLCBhY3Rpb25QYXJhbXMpIDogYWN0b3JSZWY7XG4gIGNvbnN0IHJlc29sdmVkQWN0b3JSZWYgPSB0eXBlb2YgYWN0b3JSZWZPclN0cmluZyA9PT0gJ3N0cmluZycgPyBzbmFwc2hvdC5jaGlsZHJlblthY3RvclJlZk9yU3RyaW5nXSA6IGFjdG9yUmVmT3JTdHJpbmc7XG4gIGxldCBjaGlsZHJlbiA9IHNuYXBzaG90LmNoaWxkcmVuO1xuICBpZiAocmVzb2x2ZWRBY3RvclJlZikge1xuICAgIGNoaWxkcmVuID0ge1xuICAgICAgLi4uY2hpbGRyZW5cbiAgICB9O1xuICAgIGRlbGV0ZSBjaGlsZHJlbltyZXNvbHZlZEFjdG9yUmVmLmlkXTtcbiAgfVxuICByZXR1cm4gW2Nsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgY2hpbGRyZW5cbiAgfSksIHJlc29sdmVkQWN0b3JSZWYsIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlU3RvcChhY3RvclNjb3BlLCBhY3RvclJlZikge1xuICBpZiAoIWFjdG9yUmVmKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gd2UgbmVlZCB0byBlYWdlcmx5IHVucmVnaXN0ZXIgaXQgaGVyZSBzbyBhIG5ldyBhY3RvciB3aXRoIHRoZSBzYW1lIHN5c3RlbUlkIGNhbiBiZSByZWdpc3RlcmVkIGltbWVkaWF0ZWx5XG4gIC8vIHNpbmNlIHdlIGRlZmVyIGFjdHVhbCBzdG9wcGluZyBvZiB0aGUgYWN0b3IgYnV0IHdlIGRvbid0IGRlZmVyIGFjdG9yIGNyZWF0aW9ucyAoYW5kIHdlIGNhbid0IGRvIHRoYXQpXG4gIC8vIHRoaXMgY291bGQgdGhyb3cgb24gYHN5c3RlbUlkYCBjb2xsaXNpb24sIGZvciBleGFtcGxlLCB3aGVuIGRlYWxpbmcgd2l0aCByZWVudGVyaW5nIHRyYW5zaXRpb25zXG4gIGFjdG9yU2NvcGUuc3lzdGVtLl91bnJlZ2lzdGVyKGFjdG9yUmVmKTtcblxuICAvLyB0aGlzIGFsbG93cyB1cyB0byBwcmV2ZW50IGFuIGFjdG9yIGZyb20gYmVpbmcgc3RhcnRlZCBpZiBpdCBnZXRzIHN0b3BwZWQgd2l0aGluIHRoZSBzYW1lIG1hY3Jvc3RlcFxuICAvLyB0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCB3aGVuIHRoZSBpbnZva2luZyBzdGF0ZSBpcyBiZWluZyBleGl0ZWQgaW1tZWRpYXRlbHkgYnkgYW4gYWx3YXlzIHRyYW5zaXRpb25cbiAgaWYgKGFjdG9yUmVmLl9wcm9jZXNzaW5nU3RhdHVzICE9PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICBhY3RvclNjb3BlLnN0b3BDaGlsZChhY3RvclJlZik7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHN0b3BwaW5nIGEgY2hpbGQgZW5xdWV1ZXMgYSBzdG9wIGV2ZW50IGluIHRoZSBjaGlsZCBhY3RvcidzIG1haWxib3hcbiAgLy8gd2UgbmVlZCBmb3IgYWxsIG9mIHRoZSBhbHJlYWR5IGVucXVldWVkIGV2ZW50cyB0byBiZSBwcm9jZXNzZWQgYmVmb3JlIHdlIHN0b3AgdGhlIGNoaWxkXG4gIC8vIHRoZSBwYXJlbnQgaXRzZWxmIG1pZ2h0IHdhbnQgdG8gc2VuZCBzb21lIGV2ZW50cyB0byBhIGNoaWxkIChmb3IgZXhhbXBsZSBmcm9tIGV4aXQgYWN0aW9ucyBvbiB0aGUgaW52b2tpbmcgc3RhdGUpXG4gIC8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIGlnbm9yZSB0aG9zZSBldmVudHNcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgYWN0b3JTY29wZS5zdG9wQ2hpbGQoYWN0b3JSZWYpO1xuICB9KTtcbn1cbi8qKlxuICogU3RvcHMgYSBjaGlsZCBhY3Rvci5cbiAqXG4gKiBAcGFyYW0gYWN0b3JSZWYgVGhlIGFjdG9yIHRvIHN0b3AuXG4gKi9cbmZ1bmN0aW9uIHN0b3BDaGlsZChhY3RvclJlZikge1xuICBmdW5jdGlvbiBzdG9wKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzdG9wLnR5cGUgPSAneHN0YXRlLnN0b3BDaGlsZCc7XG4gIHN0b3AuYWN0b3JSZWYgPSBhY3RvclJlZjtcbiAgc3RvcC5yZXNvbHZlID0gcmVzb2x2ZVN0b3A7XG4gIHN0b3AuZXhlY3V0ZSA9IGV4ZWN1dGVTdG9wO1xuICByZXR1cm4gc3RvcDtcbn1cblxuLyoqXG4gKiBTdG9wcyBhIGNoaWxkIGFjdG9yLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgc3RvcENoaWxkKC4uLilgIGluc3RlYWRcbiAqIEBhbGlhc1xuICovXG5jb25zdCBzdG9wID0gc3RvcENoaWxkO1xuXG5mdW5jdGlvbiBjaGVja1N0YXRlSW4oc25hcHNob3QsIF8sIHtcbiAgc3RhdGVWYWx1ZVxufSkge1xuICBpZiAodHlwZW9mIHN0YXRlVmFsdWUgPT09ICdzdHJpbmcnICYmIGlzU3RhdGVJZChzdGF0ZVZhbHVlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHNuYXBzaG90Lm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChzdGF0ZVZhbHVlKTtcbiAgICByZXR1cm4gc25hcHNob3QuX25vZGVzLnNvbWUoc24gPT4gc24gPT09IHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHNuYXBzaG90Lm1hdGNoZXMoc3RhdGVWYWx1ZSk7XG59XG5mdW5jdGlvbiBzdGF0ZUluKHN0YXRlVmFsdWUpIHtcbiAgZnVuY3Rpb24gc3RhdGVJbigpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHN0YXRlSW4uY2hlY2sgPSBjaGVja1N0YXRlSW47XG4gIHN0YXRlSW4uc3RhdGVWYWx1ZSA9IHN0YXRlVmFsdWU7XG4gIHJldHVybiBzdGF0ZUluO1xufVxuZnVuY3Rpb24gY2hlY2tOb3Qoc25hcHNob3QsIHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0sIHtcbiAgZ3VhcmRzXG59KSB7XG4gIHJldHVybiAhZXZhbHVhdGVHdWFyZChndWFyZHNbMF0sIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCk7XG59XG5cbi8qKlxuICogSGlnaGVyLW9yZGVyIGd1YXJkIHRoYXQgZXZhbHVhdGVzIHRvIGB0cnVlYCBpZiB0aGUgYGd1YXJkYCBwYXNzZWQgdG8gaXRcbiAqIGV2YWx1YXRlcyB0byBgZmFsc2VgLlxuICpcbiAqIEBjYXRlZ29yeSBHdWFyZHNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNldHVwLCBub3QgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBzZXR1cCh7XG4gKiAgIGd1YXJkczoge1xuICogICAgIHNvbWVOYW1lZEd1YXJkOiAoKSA9PiBmYWxzZVxuICogICB9XG4gKiB9KS5jcmVhdGVNYWNoaW5lKHtcbiAqICAgb246IHtcbiAqICAgICBzb21lRXZlbnQ6IHtcbiAqICAgICAgIGd1YXJkOiBub3QoJ3NvbWVOYW1lZEd1YXJkJyksXG4gKiAgICAgICBhY3Rpb25zOiAoKSA9PiB7XG4gKiAgICAgICAgIC8vIHdpbGwgYmUgZXhlY3V0ZWQgaWYgZ3VhcmQgaW4gYG5vdCguLi4pYFxuICogICAgICAgICAvLyBldmFsdWF0ZXMgdG8gYGZhbHNlYFxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGd1YXJkXG4gKi9cbmZ1bmN0aW9uIG5vdChndWFyZCkge1xuICBmdW5jdGlvbiBub3QoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIG5vdC5jaGVjayA9IGNoZWNrTm90O1xuICBub3QuZ3VhcmRzID0gW2d1YXJkXTtcbiAgcmV0dXJuIG5vdDtcbn1cbmZ1bmN0aW9uIGNoZWNrQW5kKHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gZ3VhcmRzLmV2ZXJ5KGd1YXJkID0+IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCkpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgYWxsIGBndWFyZHNgIHBhc3NlZCB0byBpdFxuICogZXZhbHVhdGUgdG8gYHRydWVgLlxuICpcbiAqIEBjYXRlZ29yeSBHdWFyZHNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNldHVwLCBhbmQgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBzZXR1cCh7XG4gKiAgIGd1YXJkczoge1xuICogICAgIHNvbWVOYW1lZEd1YXJkOiAoKSA9PiB0cnVlXG4gKiAgIH1cbiAqIH0pLmNyZWF0ZU1hY2hpbmUoe1xuICogICBvbjoge1xuICogICAgIHNvbWVFdmVudDoge1xuICogICAgICAgZ3VhcmQ6IGFuZChbKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LnZhbHVlID4gMCwgJ3NvbWVOYW1lZEd1YXJkJ10pLFxuICogICAgICAgYWN0aW9uczogKCkgPT4ge1xuICogICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkIGlmIGFsbCBndWFyZHMgaW4gYGFuZCguLi4pYFxuICogICAgICAgICAvLyBldmFsdWF0ZSB0byB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIEEgZ3VhcmQgYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBhbmQoZ3VhcmRzKSB7XG4gIGZ1bmN0aW9uIGFuZChfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgYW5kLmNoZWNrID0gY2hlY2tBbmQ7XG4gIGFuZC5ndWFyZHMgPSBndWFyZHM7XG4gIHJldHVybiBhbmQ7XG59XG5mdW5jdGlvbiBjaGVja09yKHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gZ3VhcmRzLnNvbWUoZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSk7XG59XG5cbi8qKlxuICogSGlnaGVyLW9yZGVyIGd1YXJkIHRoYXQgZXZhbHVhdGVzIHRvIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGBndWFyZHNgIHBhc3NlZCB0b1xuICogaXQgZXZhbHVhdGUgdG8gYHRydWVgLlxuICpcbiAqIEBjYXRlZ29yeSBHdWFyZHNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNldHVwLCBvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IHNldHVwKHtcbiAqICAgZ3VhcmRzOiB7XG4gKiAgICAgc29tZU5hbWVkR3VhcmQ6ICgpID0+IHRydWVcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogb3IoWyh7IGNvbnRleHQgfSkgPT4gY29udGV4dC52YWx1ZSA+IDAsICdzb21lTmFtZWRHdWFyZCddKSxcbiAqICAgICAgIGFjdGlvbnM6ICgpID0+IHtcbiAqICAgICAgICAgLy8gd2lsbCBiZSBleGVjdXRlZCBpZiBhbnkgb2YgdGhlIGd1YXJkcyBpbiBgb3IoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGUgdG8gdHJ1ZVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGd1YXJkIGFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gb3IoZ3VhcmRzKSB7XG4gIGZ1bmN0aW9uIG9yKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBvci5jaGVjayA9IGNoZWNrT3I7XG4gIG9yLmd1YXJkcyA9IGd1YXJkcztcbiAgcmV0dXJuIG9yO1xufVxuXG4vLyBUT0RPOiB0aHJvdyBvbiBjeWNsZXMgKGRlcHRoIGNoZWNrIHNob3VsZCBiZSBlbm91Z2gpXG5mdW5jdGlvbiBldmFsdWF0ZUd1YXJkKGd1YXJkLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpIHtcbiAgY29uc3Qge1xuICAgIG1hY2hpbmVcbiAgfSA9IHNuYXBzaG90O1xuICBjb25zdCBpc0lubGluZSA9IHR5cGVvZiBndWFyZCA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3QgcmVzb2x2ZWQgPSBpc0lubGluZSA/IGd1YXJkIDogbWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuZ3VhcmRzW3R5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IGd1YXJkLnR5cGVdO1xuICBpZiAoIWlzSW5saW5lICYmICFyZXNvbHZlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgR3VhcmQgJyR7dHlwZW9mIGd1YXJkID09PSAnc3RyaW5nJyA/IGd1YXJkIDogZ3VhcmQudHlwZX0nIGlzIG5vdCBpbXBsZW1lbnRlZC4nLmApO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb2x2ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVHdWFyZChyZXNvbHZlZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KTtcbiAgfVxuICBjb25zdCBndWFyZEFyZ3MgPSB7XG4gICAgY29udGV4dCxcbiAgICBldmVudFxuICB9O1xuICBjb25zdCBndWFyZFBhcmFtcyA9IGlzSW5saW5lIHx8IHR5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyB1bmRlZmluZWQgOiAncGFyYW1zJyBpbiBndWFyZCA/IHR5cGVvZiBndWFyZC5wYXJhbXMgPT09ICdmdW5jdGlvbicgPyBndWFyZC5wYXJhbXMoe1xuICAgIGNvbnRleHQsXG4gICAgZXZlbnRcbiAgfSkgOiBndWFyZC5wYXJhbXMgOiB1bmRlZmluZWQ7XG4gIGlmICghKCdjaGVjaycgaW4gcmVzb2x2ZWQpKSB7XG4gICAgLy8gdGhlIGV4aXN0aW5nIHR5cGUgb2YgYC5ndWFyZHNgIGFzc3VtZXMgbm9uLW51bGxhYmxlIGBURXhwcmVzc2lvbkd1YXJkYFxuICAgIC8vIGlubGluZSBndWFyZHMgZXhwZWN0IGBURXhwcmVzc2lvbkd1YXJkYCB0byBiZSBzZXQgdG8gYHVuZGVmaW5lZGBcbiAgICAvLyBpdCdzIGZpbmUgdG8gY2FzdCB0aGlzIGhlcmUsIG91ciBsb2dpYyBtYWtlcyBzdXJlIHRoYXQgd2UgY2FsbCB0aG9zZSAyIFwidmFyaWFudHNcIiBjb3JyZWN0bHlcbiAgICByZXR1cm4gcmVzb2x2ZWQoZ3VhcmRBcmdzLCBndWFyZFBhcmFtcyk7XG4gIH1cbiAgY29uc3QgYnVpbHRpbkd1YXJkID0gcmVzb2x2ZWQ7XG4gIHJldHVybiBidWlsdGluR3VhcmQuY2hlY2soc25hcHNob3QsIGd1YXJkQXJncywgcmVzb2x2ZWQgLy8gdGhpcyBob2xkcyBhbGwgcGFyYW1zXG4gICk7XG59XG5cbmNvbnN0IGlzQXRvbWljU3RhdGVOb2RlID0gc3RhdGVOb2RlID0+IHN0YXRlTm9kZS50eXBlID09PSAnYXRvbWljJyB8fCBzdGF0ZU5vZGUudHlwZSA9PT0gJ2ZpbmFsJztcbmZ1bmN0aW9uIGdldENoaWxkcmVuKHN0YXRlTm9kZSkge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdGF0ZU5vZGUuc3RhdGVzKS5maWx0ZXIoc24gPT4gc24udHlwZSAhPT0gJ2hpc3RvcnknKTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlKSB7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICBpZiAodG9TdGF0ZU5vZGUgPT09IHN0YXRlTm9kZSkge1xuICAgIHJldHVybiBhbmNlc3RvcnM7XG4gIH1cblxuICAvLyBhZGQgYWxsIGFuY2VzdG9yc1xuICBsZXQgbSA9IHN0YXRlTm9kZS5wYXJlbnQ7XG4gIHdoaWxlIChtICYmIG0gIT09IHRvU3RhdGVOb2RlKSB7XG4gICAgYW5jZXN0b3JzLnB1c2gobSk7XG4gICAgbSA9IG0ucGFyZW50O1xuICB9XG4gIHJldHVybiBhbmNlc3RvcnM7XG59XG5mdW5jdGlvbiBnZXRBbGxTdGF0ZU5vZGVzKHN0YXRlTm9kZXMpIHtcbiAgY29uc3Qgbm9kZVNldCA9IG5ldyBTZXQoc3RhdGVOb2Rlcyk7XG4gIGNvbnN0IGFkakxpc3QgPSBnZXRBZGpMaXN0KG5vZGVTZXQpO1xuXG4gIC8vIGFkZCBkZXNjZW5kYW50c1xuICBmb3IgKGNvbnN0IHMgb2Ygbm9kZVNldCkge1xuICAgIC8vIGlmIHByZXZpb3VzbHkgYWN0aXZlLCBhZGQgZXhpc3RpbmcgY2hpbGQgbm9kZXNcbiAgICBpZiAocy50eXBlID09PSAnY29tcG91bmQnICYmICghYWRqTGlzdC5nZXQocykgfHwgIWFkakxpc3QuZ2V0KHMpLmxlbmd0aCkpIHtcbiAgICAgIGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKHMpLmZvckVhY2goc24gPT4gbm9kZVNldC5hZGQoc24pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKHMpKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdoaXN0b3J5Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbm9kZVNldC5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsU3RhdGVzID0gZ2V0SW5pdGlhbFN0YXRlTm9kZXNXaXRoVGhlaXJBbmNlc3RvcnMoY2hpbGQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbml0aWFsU3RhdGVOb2RlIG9mIGluaXRpYWxTdGF0ZXMpIHtcbiAgICAgICAgICAgICAgbm9kZVNldC5hZGQoaW5pdGlhbFN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIGFsbCBhbmNlc3RvcnNcbiAgZm9yIChjb25zdCBzIG9mIG5vZGVTZXQpIHtcbiAgICBsZXQgbSA9IHMucGFyZW50O1xuICAgIHdoaWxlIChtKSB7XG4gICAgICBub2RlU2V0LmFkZChtKTtcbiAgICAgIG0gPSBtLnBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVTZXQ7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21BZGooYmFzZU5vZGUsIGFkakxpc3QpIHtcbiAgY29uc3QgY2hpbGRTdGF0ZU5vZGVzID0gYWRqTGlzdC5nZXQoYmFzZU5vZGUpO1xuICBpZiAoIWNoaWxkU3RhdGVOb2Rlcykge1xuICAgIHJldHVybiB7fTsgLy8gdG9kbzogZml4P1xuICB9XG4gIGlmIChiYXNlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgY29uc3QgY2hpbGRTdGF0ZU5vZGUgPSBjaGlsZFN0YXRlTm9kZXNbMF07XG4gICAgaWYgKGNoaWxkU3RhdGVOb2RlKSB7XG4gICAgICBpZiAoaXNBdG9taWNTdGF0ZU5vZGUoY2hpbGRTdGF0ZU5vZGUpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFN0YXRlTm9kZS5rZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RhdGVWYWx1ZSA9IHt9O1xuICBmb3IgKGNvbnN0IGNoaWxkU3RhdGVOb2RlIG9mIGNoaWxkU3RhdGVOb2Rlcykge1xuICAgIHN0YXRlVmFsdWVbY2hpbGRTdGF0ZU5vZGUua2V5XSA9IGdldFZhbHVlRnJvbUFkaihjaGlsZFN0YXRlTm9kZSwgYWRqTGlzdCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlVmFsdWU7XG59XG5mdW5jdGlvbiBnZXRBZGpMaXN0KHN0YXRlTm9kZXMpIHtcbiAgY29uc3QgYWRqTGlzdCA9IG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBzIG9mIHN0YXRlTm9kZXMpIHtcbiAgICBpZiAoIWFkakxpc3QuaGFzKHMpKSB7XG4gICAgICBhZGpMaXN0LnNldChzLCBbXSk7XG4gICAgfVxuICAgIGlmIChzLnBhcmVudCkge1xuICAgICAgaWYgKCFhZGpMaXN0LmhhcyhzLnBhcmVudCkpIHtcbiAgICAgICAgYWRqTGlzdC5zZXQocy5wYXJlbnQsIFtdKTtcbiAgICAgIH1cbiAgICAgIGFkakxpc3QuZ2V0KHMucGFyZW50KS5wdXNoKHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWRqTGlzdDtcbn1cbmZ1bmN0aW9uIGdldFN0YXRlVmFsdWUocm9vdE5vZGUsIHN0YXRlTm9kZXMpIHtcbiAgY29uc3QgY29uZmlnID0gZ2V0QWxsU3RhdGVOb2RlcyhzdGF0ZU5vZGVzKTtcbiAgcmV0dXJuIGdldFZhbHVlRnJvbUFkaihyb290Tm9kZSwgZ2V0QWRqTGlzdChjb25maWcpKTtcbn1cbmZ1bmN0aW9uIGlzSW5GaW5hbFN0YXRlKHN0YXRlTm9kZVNldCwgc3RhdGVOb2RlKSB7XG4gIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLnNvbWUocyA9PiBzLnR5cGUgPT09ICdmaW5hbCcgJiYgc3RhdGVOb2RlU2V0LmhhcyhzKSk7XG4gIH1cbiAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHN0YXRlTm9kZSkuZXZlcnkoc24gPT4gaXNJbkZpbmFsU3RhdGUoc3RhdGVOb2RlU2V0LCBzbikpO1xuICB9XG4gIHJldHVybiBzdGF0ZU5vZGUudHlwZSA9PT0gJ2ZpbmFsJztcbn1cbmNvbnN0IGlzU3RhdGVJZCA9IHN0ciA9PiBzdHJbMF0gPT09IFNUQVRFX0lERU5USUZJRVI7XG5mdW5jdGlvbiBnZXRDYW5kaWRhdGVzKHN0YXRlTm9kZSwgcmVjZWl2ZWRFdmVudFR5cGUpIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHN0YXRlTm9kZS50cmFuc2l0aW9ucy5nZXQocmVjZWl2ZWRFdmVudFR5cGUpIHx8IFsuLi5zdGF0ZU5vZGUudHJhbnNpdGlvbnMua2V5cygpXS5maWx0ZXIoZXZlbnREZXNjcmlwdG9yID0+IHtcbiAgICAvLyBjaGVjayBpZiB0cmFuc2l0aW9uIGlzIGEgd2lsZGNhcmQgdHJhbnNpdGlvbixcbiAgICAvLyB3aGljaCBtYXRjaGVzIGFueSBub24tdHJhbnNpZW50IGV2ZW50c1xuICAgIGlmIChldmVudERlc2NyaXB0b3IgPT09IFdJTERDQVJEKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFldmVudERlc2NyaXB0b3IuZW5kc1dpdGgoJy4qJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKC8uKlxcKi4rLy50ZXN0KGV2ZW50RGVzY3JpcHRvcikpIHtcbiAgICAgIGNvbnNvbGUud2FybihgV2lsZGNhcmRzIGNhbiBvbmx5IGJlIHRoZSBsYXN0IHRva2VuIG9mIGFuIGV2ZW50IGRlc2NyaXB0b3IgKGUuZy4sIFwiZXZlbnQuKlwiKSBvciB0aGUgZW50aXJlIGV2ZW50IGRlc2NyaXB0b3IgKFwiKlwiKS4gQ2hlY2sgdGhlIFwiJHtldmVudERlc2NyaXB0b3J9XCIgZXZlbnQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpYWxFdmVudFRva2VucyA9IGV2ZW50RGVzY3JpcHRvci5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGV2ZW50VG9rZW5zID0gcmVjZWl2ZWRFdmVudFR5cGUuc3BsaXQoJy4nKTtcbiAgICBmb3IgKGxldCB0b2tlbkluZGV4ID0gMDsgdG9rZW5JbmRleCA8IHBhcnRpYWxFdmVudFRva2Vucy5sZW5ndGg7IHRva2VuSW5kZXgrKykge1xuICAgICAgY29uc3QgcGFydGlhbEV2ZW50VG9rZW4gPSBwYXJ0aWFsRXZlbnRUb2tlbnNbdG9rZW5JbmRleF07XG4gICAgICBjb25zdCBldmVudFRva2VuID0gZXZlbnRUb2tlbnNbdG9rZW5JbmRleF07XG4gICAgICBpZiAocGFydGlhbEV2ZW50VG9rZW4gPT09ICcqJykge1xuICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IHRva2VuSW5kZXggPT09IHBhcnRpYWxFdmVudFRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoIWlzTGFzdFRva2VuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBJbmZpeCB3aWxkY2FyZHMgaW4gdHJhbnNpdGlvbiBldmVudHMgYXJlIG5vdCBhbGxvd2VkLiBDaGVjayB0aGUgXCIke2V2ZW50RGVzY3JpcHRvcn1cIiB0cmFuc2l0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0xhc3RUb2tlbjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0aWFsRXZlbnRUb2tlbiAhPT0gZXZlbnRUb2tlbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KS5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKS5mbGF0TWFwKGtleSA9PiBzdGF0ZU5vZGUudHJhbnNpdGlvbnMuZ2V0KGtleSkpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn1cblxuLyoqIEFsbCBkZWxheWVkIHRyYW5zaXRpb25zIGZyb20gdGhlIGNvbmZpZy4gKi9cbmZ1bmN0aW9uIGdldERlbGF5ZWRUcmFuc2l0aW9ucyhzdGF0ZU5vZGUpIHtcbiAgY29uc3QgYWZ0ZXJDb25maWcgPSBzdGF0ZU5vZGUuY29uZmlnLmFmdGVyO1xuICBpZiAoIWFmdGVyQ29uZmlnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG11dGF0ZUVudHJ5RXhpdCA9IGRlbGF5ID0+IHtcbiAgICBjb25zdCBhZnRlckV2ZW50ID0gY3JlYXRlQWZ0ZXJFdmVudChkZWxheSwgc3RhdGVOb2RlLmlkKTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBhZnRlckV2ZW50LnR5cGU7XG4gICAgc3RhdGVOb2RlLmVudHJ5LnB1c2gocmFpc2UoYWZ0ZXJFdmVudCwge1xuICAgICAgaWQ6IGV2ZW50VHlwZSxcbiAgICAgIGRlbGF5XG4gICAgfSkpO1xuICAgIHN0YXRlTm9kZS5leGl0LnB1c2goY2FuY2VsKGV2ZW50VHlwZSkpO1xuICAgIHJldHVybiBldmVudFR5cGU7XG4gIH07XG4gIGNvbnN0IGRlbGF5ZWRUcmFuc2l0aW9ucyA9IE9iamVjdC5rZXlzKGFmdGVyQ29uZmlnKS5mbGF0TWFwKGRlbGF5ID0+IHtcbiAgICBjb25zdCBjb25maWdUcmFuc2l0aW9uID0gYWZ0ZXJDb25maWdbZGVsYXldO1xuICAgIGNvbnN0IHJlc29sdmVkVHJhbnNpdGlvbiA9IHR5cGVvZiBjb25maWdUcmFuc2l0aW9uID09PSAnc3RyaW5nJyA/IHtcbiAgICAgIHRhcmdldDogY29uZmlnVHJhbnNpdGlvblxuICAgIH0gOiBjb25maWdUcmFuc2l0aW9uO1xuICAgIGNvbnN0IHJlc29sdmVkRGVsYXkgPSBOdW1iZXIuaXNOYU4oK2RlbGF5KSA/IGRlbGF5IDogK2RlbGF5O1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IG11dGF0ZUVudHJ5RXhpdChyZXNvbHZlZERlbGF5KTtcbiAgICByZXR1cm4gdG9BcnJheShyZXNvbHZlZFRyYW5zaXRpb24pLm1hcCh0cmFuc2l0aW9uID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgZXZlbnQ6IGV2ZW50VHlwZSxcbiAgICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIGRlbGF5ZWRUcmFuc2l0aW9ucy5tYXAoZGVsYXllZFRyYW5zaXRpb24gPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5XG4gICAgfSA9IGRlbGF5ZWRUcmFuc2l0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVsYXllZFRyYW5zaXRpb24uZXZlbnQsIGRlbGF5ZWRUcmFuc2l0aW9uKSxcbiAgICAgIGRlbGF5XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdHJhbnNpdGlvbkNvbmZpZykge1xuICBjb25zdCBub3JtYWxpemVkVGFyZ2V0ID0gbm9ybWFsaXplVGFyZ2V0KHRyYW5zaXRpb25Db25maWcudGFyZ2V0KTtcbiAgY29uc3QgcmVlbnRlciA9IHRyYW5zaXRpb25Db25maWcucmVlbnRlciA/PyBmYWxzZTtcbiAgY29uc3QgdGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChzdGF0ZU5vZGUsIG5vcm1hbGl6ZWRUYXJnZXQpO1xuXG4gIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIHBhcnQgb2YgYSBsaW50IHJ1bGUgaW5zdGVhZD9cbiAgaWYgKHRyYW5zaXRpb25Db25maWcuY29uZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGUgXCIke3N0YXRlTm9kZS5pZH1cIiBoYXMgZGVjbGFyZWQgXFxgY29uZFxcYCBmb3Igb25lIG9mIGl0cyB0cmFuc2l0aW9ucy4gVGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYGd1YXJkXFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZS5gKTtcbiAgfVxuICBjb25zdCB0cmFuc2l0aW9uID0ge1xuICAgIC4uLnRyYW5zaXRpb25Db25maWcsXG4gICAgYWN0aW9uczogdG9BcnJheSh0cmFuc2l0aW9uQ29uZmlnLmFjdGlvbnMpLFxuICAgIGd1YXJkOiB0cmFuc2l0aW9uQ29uZmlnLmd1YXJkLFxuICAgIHRhcmdldCxcbiAgICBzb3VyY2U6IHN0YXRlTm9kZSxcbiAgICByZWVudGVyLFxuICAgIGV2ZW50VHlwZTogZGVzY3JpcHRvcixcbiAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgc291cmNlOiBgIyR7c3RhdGVOb2RlLmlkfWAsXG4gICAgICB0YXJnZXQ6IHRhcmdldCA/IHRhcmdldC5tYXAodCA9PiBgIyR7dC5pZH1gKSA6IHVuZGVmaW5lZFxuICAgIH0pXG4gIH07XG4gIHJldHVybiB0cmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhbnNpdGlvbnMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICBpZiAoc3RhdGVOb2RlLmNvbmZpZy5vbikge1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBPYmplY3Qua2V5cyhzdGF0ZU5vZGUuY29uZmlnLm9uKSkge1xuICAgICAgaWYgKGRlc2NyaXB0b3IgPT09IE5VTExfRVZFTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGV2ZW50cyAoXCJcIikgY2Fubm90IGJlIHNwZWNpZmllZCBhcyBhIHRyYW5zaXRpb24ga2V5LiBVc2UgYGFsd2F5czogeyAuLi4gfWAgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zaXRpb25zQ29uZmlnID0gc3RhdGVOb2RlLmNvbmZpZy5vbltkZXNjcmlwdG9yXTtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheSh0cmFuc2l0aW9uc0NvbmZpZykubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHQpKSk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZU5vZGUuY29uZmlnLm9uRG9uZSkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmRvbmUuc3RhdGUuJHtzdGF0ZU5vZGUuaWR9YDtcbiAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoc3RhdGVOb2RlLmNvbmZpZy5vbkRvbmUpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICB9XG4gIGZvciAoY29uc3QgaW52b2tlRGVmIG9mIHN0YXRlTm9kZS5pbnZva2UpIHtcbiAgICBpZiAoaW52b2tlRGVmLm9uRG9uZSkge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGB4c3RhdGUuZG9uZS5hY3Rvci4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vbkRvbmUpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgICBpZiAoaW52b2tlRGVmLm9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmVycm9yLmFjdG9yLiR7aW52b2tlRGVmLmlkfWA7XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoaW52b2tlRGVmLm9uRXJyb3IpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgICBpZiAoaW52b2tlRGVmLm9uU25hcHNob3QpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLnNuYXBzaG90LiR7aW52b2tlRGVmLmlkfWA7XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoaW52b2tlRGVmLm9uU25hcHNob3QpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGRlbGF5ZWRUcmFuc2l0aW9uIG9mIHN0YXRlTm9kZS5hZnRlcikge1xuICAgIGxldCBleGlzdGluZyA9IHRyYW5zaXRpb25zLmdldChkZWxheWVkVHJhbnNpdGlvbi5ldmVudFR5cGUpO1xuICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgIGV4aXN0aW5nID0gW107XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVsYXllZFRyYW5zaXRpb24uZXZlbnRUeXBlLCBleGlzdGluZyk7XG4gICAgfVxuICAgIGV4aXN0aW5nLnB1c2goZGVsYXllZFRyYW5zaXRpb24pO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9ucztcbn1cbmZ1bmN0aW9uIGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uKHN0YXRlTm9kZSwgX3RhcmdldCkge1xuICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiBfdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHN0YXRlTm9kZS5zdGF0ZXNbX3RhcmdldF0gOiBfdGFyZ2V0ID8gc3RhdGVOb2RlLnN0YXRlc1tfdGFyZ2V0LnRhcmdldF0gOiB1bmRlZmluZWQ7XG4gIGlmICghcmVzb2x2ZWRUYXJnZXQgJiYgX3RhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICBgSW5pdGlhbCBzdGF0ZSBub2RlIFwiJHtfdGFyZ2V0fVwiIG5vdCBmb3VuZCBvbiBwYXJlbnQgc3RhdGUgbm9kZSAjJHtzdGF0ZU5vZGUuaWR9YCk7XG4gIH1cbiAgY29uc3QgdHJhbnNpdGlvbiA9IHtcbiAgICBzb3VyY2U6IHN0YXRlTm9kZSxcbiAgICBhY3Rpb25zOiAhX3RhcmdldCB8fCB0eXBlb2YgX3RhcmdldCA9PT0gJ3N0cmluZycgPyBbXSA6IHRvQXJyYXkoX3RhcmdldC5hY3Rpb25zKSxcbiAgICBldmVudFR5cGU6IG51bGwsXG4gICAgcmVlbnRlcjogZmFsc2UsXG4gICAgdGFyZ2V0OiByZXNvbHZlZFRhcmdldCA/IFtyZXNvbHZlZFRhcmdldF0gOiBbXSxcbiAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgc291cmNlOiBgIyR7c3RhdGVOb2RlLmlkfWAsXG4gICAgICB0YXJnZXQ6IHJlc29sdmVkVGFyZ2V0ID8gW2AjJHtyZXNvbHZlZFRhcmdldC5pZH1gXSA6IFtdXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIHRyYW5zaXRpb247XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0KHN0YXRlTm9kZSwgdGFyZ2V0cykge1xuICBpZiAodGFyZ2V0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gYW4gdW5kZWZpbmVkIHRhcmdldCBzaWduYWxzIHRoYXQgdGhlIHN0YXRlIG5vZGUgc2hvdWxkIG5vdCB0cmFuc2l0aW9uIGZyb20gdGhhdCBzdGF0ZSB3aGVuIHJlY2VpdmluZyB0aGF0IGV2ZW50XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChpc1N0YXRlSWQodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZS5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQodGFyZ2V0KTtcbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcm5hbFRhcmdldCA9IHRhcmdldFswXSA9PT0gU1RBVEVfREVMSU1JVEVSO1xuICAgIC8vIElmIGludGVybmFsIHRhcmdldCBpcyBkZWZpbmVkIG9uIG1hY2hpbmUsXG4gICAgLy8gZG8gbm90IGluY2x1ZGUgbWFjaGluZSBrZXkgb24gdGFyZ2V0XG4gICAgaWYgKGlzSW50ZXJuYWxUYXJnZXQgJiYgIXN0YXRlTm9kZS5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCB0YXJnZXQuc2xpY2UoMSkpO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZFRhcmdldCA9IGlzSW50ZXJuYWxUYXJnZXQgPyBzdGF0ZU5vZGUua2V5ICsgdGFyZ2V0IDogdGFyZ2V0O1xuICAgIGlmIChzdGF0ZU5vZGUucGFyZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLnBhcmVudCwgcmVzb2x2ZWRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhdGVOb2RlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cmFuc2l0aW9uIGRlZmluaXRpb24gZm9yIHN0YXRlIG5vZGUgJyR7c3RhdGVOb2RlLmlkfSc6XFxuJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldDogXCIke3RhcmdldH1cIiBpcyBub3QgYSB2YWxpZCB0YXJnZXQgZnJvbSB0aGUgcm9vdCBub2RlLiBEaWQgeW91IG1lYW4gXCIuJHt0YXJnZXR9XCI/YCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24oc3RhdGVOb2RlKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRUYXJnZXQgPSBub3JtYWxpemVUYXJnZXQoc3RhdGVOb2RlLmNvbmZpZy50YXJnZXQpO1xuICBpZiAoIW5vcm1hbGl6ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gc3RhdGVOb2RlLnBhcmVudC5pbml0aWFsO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiBub3JtYWxpemVkVGFyZ2V0Lm1hcCh0ID0+IHR5cGVvZiB0ID09PSAnc3RyaW5nJyA/IGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUucGFyZW50LCB0KSA6IHQpXG4gIH07XG59XG5mdW5jdGlvbiBpc0hpc3RvcnlOb2RlKHN0YXRlTm9kZSkge1xuICByZXR1cm4gc3RhdGVOb2RlLnR5cGUgPT09ICdoaXN0b3J5Jztcbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKHN0YXRlTm9kZSkge1xuICBjb25zdCBzdGF0ZXMgPSBnZXRJbml0aWFsU3RhdGVOb2RlcyhzdGF0ZU5vZGUpO1xuICBmb3IgKGNvbnN0IGluaXRpYWxTdGF0ZSBvZiBzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIGdldFByb3BlckFuY2VzdG9ycyhpbml0aWFsU3RhdGUsIHN0YXRlTm9kZSkpIHtcbiAgICAgIHN0YXRlcy5hZGQoYW5jZXN0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGVzO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlTm9kZXMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gaXRlcihkZXNjU3RhdGVOb2RlKSB7XG4gICAgaWYgKHNldC5oYXMoZGVzY1N0YXRlTm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0LmFkZChkZXNjU3RhdGVOb2RlKTtcbiAgICBpZiAoZGVzY1N0YXRlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICBpdGVyKGRlc2NTdGF0ZU5vZGUuaW5pdGlhbC50YXJnZXRbMF0pO1xuICAgIH0gZWxzZSBpZiAoZGVzY1N0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKGRlc2NTdGF0ZU5vZGUpKSB7XG4gICAgICAgIGl0ZXIoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpdGVyKHN0YXRlTm9kZSk7XG4gIHJldHVybiBzZXQ7XG59XG4vKiogUmV0dXJucyB0aGUgY2hpbGQgc3RhdGUgbm9kZSBmcm9tIGl0cyByZWxhdGl2ZSBgc3RhdGVLZXlgLCBvciB0aHJvd3MuICovXG5mdW5jdGlvbiBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdGF0ZUtleSkge1xuICBpZiAoaXNTdGF0ZUlkKHN0YXRlS2V5KSkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlS2V5KTtcbiAgfVxuICBpZiAoIXN0YXRlTm9kZS5zdGF0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXRyaWV2ZSBjaGlsZCBzdGF0ZSAnJHtzdGF0ZUtleX0nIGZyb20gJyR7c3RhdGVOb2RlLmlkfSc7IG5vIGNoaWxkIHN0YXRlcyBleGlzdC5gKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBzdGF0ZU5vZGUuc3RhdGVzW3N0YXRlS2V5XTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlICcke3N0YXRlS2V5fScgZG9lcyBub3QgZXhpc3Qgb24gJyR7c3RhdGVOb2RlLmlkfSdgKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlbGF0aXZlIHN0YXRlIG5vZGUgZnJvbSB0aGUgZ2l2ZW4gYHN0YXRlUGF0aGAsIG9yIHRocm93cy5cbiAqXG4gKiBAcGFyYW0gc3RhdGVQYXRoIFRoZSBzdHJpbmcgb3Igc3RyaW5nIGFycmF5IHJlbGF0aXZlIHBhdGggdG8gdGhlIHN0YXRlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUsIHN0YXRlUGF0aCkge1xuICBpZiAodHlwZW9mIHN0YXRlUGF0aCA9PT0gJ3N0cmluZycgJiYgaXNTdGF0ZUlkKHN0YXRlUGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZS5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoc3RhdGVQYXRoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIHRyeSBpbmRpdmlkdWFsIHBhdGhzXG4gICAgICAvLyB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBjb25zdCBhcnJheVN0YXRlUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlUGF0aCkuc2xpY2UoKTtcbiAgbGV0IGN1cnJlbnRTdGF0ZU5vZGUgPSBzdGF0ZU5vZGU7XG4gIHdoaWxlIChhcnJheVN0YXRlUGF0aC5sZW5ndGgpIHtcbiAgICBjb25zdCBrZXkgPSBhcnJheVN0YXRlUGF0aC5zaGlmdCgpO1xuICAgIGlmICgha2V5Lmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN1cnJlbnRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoY3VycmVudFN0YXRlTm9kZSwga2V5KTtcbiAgfVxuICByZXR1cm4gY3VycmVudFN0YXRlTm9kZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdGF0ZSBub2RlcyByZXByZXNlbnRlZCBieSB0aGUgY3VycmVudCBzdGF0ZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgc3RhdGUgdmFsdWUgb3IgU3RhdGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVOb2RlcyhzdGF0ZU5vZGUsIHN0YXRlVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNoaWxkU3RhdGVOb2RlID0gc3RhdGVOb2RlLnN0YXRlc1tzdGF0ZVZhbHVlXTtcbiAgICBpZiAoIWNoaWxkU3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlICcke3N0YXRlVmFsdWV9JyBkb2VzIG5vdCBleGlzdCBvbiAnJHtzdGF0ZU5vZGUuaWR9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXRlTm9kZSwgY2hpbGRTdGF0ZU5vZGVdO1xuICB9XG4gIGNvbnN0IGNoaWxkU3RhdGVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSk7XG4gIGNvbnN0IGNoaWxkU3RhdGVOb2RlcyA9IGNoaWxkU3RhdGVLZXlzLm1hcChzdWJTdGF0ZUtleSA9PiBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSkpLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIFtzdGF0ZU5vZGUubWFjaGluZS5yb290LCBzdGF0ZU5vZGVdLmNvbmNhdChjaGlsZFN0YXRlTm9kZXMsIGNoaWxkU3RhdGVLZXlzLnJlZHVjZSgoYWxsU3ViU3RhdGVOb2Rlcywgc3ViU3RhdGVLZXkpID0+IHtcbiAgICBjb25zdCBzdWJTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSk7XG4gICAgaWYgKCFzdWJTdGF0ZU5vZGUpIHtcbiAgICAgIHJldHVybiBhbGxTdWJTdGF0ZU5vZGVzO1xuICAgIH1cbiAgICBjb25zdCBzdWJTdGF0ZU5vZGVzID0gZ2V0U3RhdGVOb2RlcyhzdWJTdGF0ZU5vZGUsIHN0YXRlVmFsdWVbc3ViU3RhdGVLZXldKTtcbiAgICByZXR1cm4gYWxsU3ViU3RhdGVOb2Rlcy5jb25jYXQoc3ViU3RhdGVOb2Rlcyk7XG4gIH0sIFtdKSk7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uQXRvbWljTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUpO1xuICBjb25zdCBuZXh0ID0gY2hpbGRTdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICBpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uQ29tcG91bmROb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IHN1YlN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN1YlN0YXRlS2V5c1swXSk7XG4gIGNvbnN0IG5leHQgPSB0cmFuc2l0aW9uTm9kZShjaGlsZFN0YXRlTm9kZSwgc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleXNbMF1dLCBzbmFwc2hvdCwgZXZlbnQpO1xuICBpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IGFsbElubmVyVHJhbnNpdGlvbnMgPSBbXTtcbiAgZm9yIChjb25zdCBzdWJTdGF0ZUtleSBvZiBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKSkge1xuICAgIGNvbnN0IHN1YlN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlW3N1YlN0YXRlS2V5XTtcbiAgICBpZiAoIXN1YlN0YXRlVmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzdWJTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSk7XG4gICAgY29uc3QgaW5uZXJUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25Ob2RlKHN1YlN0YXRlTm9kZSwgc3ViU3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KTtcbiAgICBpZiAoaW5uZXJUcmFuc2l0aW9ucykge1xuICAgICAgYWxsSW5uZXJUcmFuc2l0aW9ucy5wdXNoKC4uLmlubmVyVHJhbnNpdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoIWFsbElubmVyVHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIGFsbElubmVyVHJhbnNpdGlvbnM7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICAvLyBsZWFmIG5vZGVcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0cmFuc2l0aW9uQXRvbWljTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gIH1cblxuICAvLyBjb21wb3VuZCBub2RlXG4gIGlmIChPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gIH1cblxuICAvLyBwYXJhbGxlbCBub2RlXG4gIHJldHVybiB0cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldEhpc3RvcnlOb2RlcyhzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlTm9kZS5zdGF0ZXMpLm1hcChrZXkgPT4gc3RhdGVOb2RlLnN0YXRlc1trZXldKS5maWx0ZXIoc24gPT4gc24udHlwZSA9PT0gJ2hpc3RvcnknKTtcbn1cbmZ1bmN0aW9uIGlzRGVzY2VuZGFudChjaGlsZFN0YXRlTm9kZSwgcGFyZW50U3RhdGVOb2RlKSB7XG4gIGxldCBtYXJrZXIgPSBjaGlsZFN0YXRlTm9kZTtcbiAgd2hpbGUgKG1hcmtlci5wYXJlbnQgJiYgbWFya2VyLnBhcmVudCAhPT0gcGFyZW50U3RhdGVOb2RlKSB7XG4gICAgbWFya2VyID0gbWFya2VyLnBhcmVudDtcbiAgfVxuICByZXR1cm4gbWFya2VyLnBhcmVudCA9PT0gcGFyZW50U3RhdGVOb2RlO1xufVxuZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uKHMxLCBzMikge1xuICBjb25zdCBzZXQxID0gbmV3IFNldChzMSk7XG4gIGNvbnN0IHNldDIgPSBuZXcgU2V0KHMyKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldDEpIHtcbiAgICBpZiAoc2V0Mi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2V0Mikge1xuICAgIGlmIChzZXQxLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnMoZW5hYmxlZFRyYW5zaXRpb25zLCBzdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSkge1xuICBjb25zdCBmaWx0ZXJlZFRyYW5zaXRpb25zID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHQxIG9mIGVuYWJsZWRUcmFuc2l0aW9ucykge1xuICAgIGxldCB0MVByZWVtcHRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHRyYW5zaXRpb25zVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB0MiBvZiBmaWx0ZXJlZFRyYW5zaXRpb25zKSB7XG4gICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uKGNvbXB1dGVFeGl0U2V0KFt0MV0sIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSwgY29tcHV0ZUV4aXRTZXQoW3QyXSwgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpKSkge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KHQxLnNvdXJjZSwgdDIuc291cmNlKSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zVG9SZW1vdmUuYWRkKHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0MVByZWVtcHRlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0MVByZWVtcHRlZCkge1xuICAgICAgZm9yIChjb25zdCB0MyBvZiB0cmFuc2l0aW9uc1RvUmVtb3ZlKSB7XG4gICAgICAgIGZpbHRlcmVkVHJhbnNpdGlvbnMuZGVsZXRlKHQzKTtcbiAgICAgIH1cbiAgICAgIGZpbHRlcmVkVHJhbnNpdGlvbnMuYWRkKHQxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oZmlsdGVyZWRUcmFuc2l0aW9ucyk7XG59XG5mdW5jdGlvbiBmaW5kTGVhc3RDb21tb25BbmNlc3RvcihzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHN0YXRlTm9kZXM7XG4gIGZvciAoY29uc3QgYW5jZXN0b3Igb2YgZ2V0UHJvcGVyQW5jZXN0b3JzKGhlYWQsIHVuZGVmaW5lZCkpIHtcbiAgICBpZiAodGFpbC5ldmVyeShzbiA9PiBpc0Rlc2NlbmRhbnQoc24sIGFuY2VzdG9yKSkpIHtcbiAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpIHtcbiAgaWYgKCF0cmFuc2l0aW9uLnRhcmdldCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB0YXJnZXRzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHRhcmdldE5vZGUgb2YgdHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICBpZiAoaXNIaXN0b3J5Tm9kZSh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGhpc3RvcnlWYWx1ZVt0YXJnZXROb2RlLmlkXSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaGlzdG9yeVZhbHVlW3RhcmdldE5vZGUuaWRdKSB7XG4gICAgICAgICAgdGFyZ2V0cy5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXMocmVzb2x2ZUhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbih0YXJnZXROb2RlKSwgaGlzdG9yeVZhbHVlKSkge1xuICAgICAgICAgIHRhcmdldHMuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldHMuYWRkKHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnRhcmdldHNdO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkRvbWFpbih0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVzID0gZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzKHRyYW5zaXRpb24sIGhpc3RvcnlWYWx1ZSk7XG4gIGlmICghdGFyZ2V0U3RhdGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdHJhbnNpdGlvbi5yZWVudGVyICYmIHRhcmdldFN0YXRlcy5ldmVyeSh0YXJnZXQgPT4gdGFyZ2V0ID09PSB0cmFuc2l0aW9uLnNvdXJjZSB8fCBpc0Rlc2NlbmRhbnQodGFyZ2V0LCB0cmFuc2l0aW9uLnNvdXJjZSkpKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb24uc291cmNlO1xuICB9XG4gIGNvbnN0IGxjYSA9IGZpbmRMZWFzdENvbW1vbkFuY2VzdG9yKHRhcmdldFN0YXRlcy5jb25jYXQodHJhbnNpdGlvbi5zb3VyY2UpKTtcbiAgaWYgKGxjYSkge1xuICAgIHJldHVybiBsY2E7XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50IHdlIGtub3cgdGhhdCBpdCdzIGEgcm9vdCB0cmFuc2l0aW9uIHNpbmNlIExDQSBjb3VsZG4ndCBiZSBmb3VuZFxuICBpZiAodHJhbnNpdGlvbi5yZWVudGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9uLnNvdXJjZS5tYWNoaW5lLnJvb3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlRXhpdFNldCh0cmFuc2l0aW9ucywgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3Qgc3RhdGVzVG9FeGl0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHQgb2YgdHJhbnNpdGlvbnMpIHtcbiAgICBpZiAodC50YXJnZXQ/Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZG9tYWluID0gZ2V0VHJhbnNpdGlvbkRvbWFpbih0LCBoaXN0b3J5VmFsdWUpO1xuICAgICAgaWYgKHQucmVlbnRlciAmJiB0LnNvdXJjZSA9PT0gZG9tYWluKSB7XG4gICAgICAgIHN0YXRlc1RvRXhpdC5hZGQoZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc3RhdGVOb2RlIG9mIHN0YXRlTm9kZVNldCkge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KHN0YXRlTm9kZSwgZG9tYWluKSkge1xuICAgICAgICAgIHN0YXRlc1RvRXhpdC5hZGQoc3RhdGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnN0YXRlc1RvRXhpdF07XG59XG5mdW5jdGlvbiBhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsKHByZXZTdGF0ZU5vZGVzLCBuZXh0U3RhdGVOb2RlU2V0KSB7XG4gIGlmIChwcmV2U3RhdGVOb2Rlcy5sZW5ndGggIT09IG5leHRTdGF0ZU5vZGVTZXQuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IG5vZGUgb2YgcHJldlN0YXRlTm9kZXMpIHtcbiAgICBpZiAoIW5leHRTdGF0ZU5vZGVTZXQuaGFzKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNtaWNyb3N0ZXBQcm9jZWR1cmUgKi9cbmZ1bmN0aW9uIG1pY3Jvc3RlcCh0cmFuc2l0aW9ucywgY3VycmVudFNuYXBzaG90LCBhY3RvclNjb3BlLCBldmVudCwgaXNJbml0aWFsLCBpbnRlcm5hbFF1ZXVlKSB7XG4gIGlmICghdHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbmFwc2hvdDtcbiAgfVxuICBjb25zdCBtdXRTdGF0ZU5vZGVTZXQgPSBuZXcgU2V0KGN1cnJlbnRTbmFwc2hvdC5fbm9kZXMpO1xuICBsZXQgaGlzdG9yeVZhbHVlID0gY3VycmVudFNuYXBzaG90Lmhpc3RvcnlWYWx1ZTtcbiAgY29uc3QgZmlsdGVyZWRUcmFuc2l0aW9ucyA9IHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnModHJhbnNpdGlvbnMsIG11dFN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKTtcbiAgbGV0IG5leHRTdGF0ZSA9IGN1cnJlbnRTbmFwc2hvdDtcblxuICAvLyBFeGl0IHN0YXRlc1xuICBpZiAoIWlzSW5pdGlhbCkge1xuICAgIFtuZXh0U3RhdGUsIGhpc3RvcnlWYWx1ZV0gPSBleGl0U3RhdGVzKG5leHRTdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUsIGZpbHRlcmVkVHJhbnNpdGlvbnMsIG11dFN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlLCBpbnRlcm5hbFF1ZXVlLCBhY3RvclNjb3BlLmFjdGlvbkV4ZWN1dG9yKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgdHJhbnNpdGlvbiBjb250ZW50XG4gIG5leHRTdGF0ZSA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLmZsYXRNYXAodCA9PiB0LmFjdGlvbnMpLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuXG4gIC8vIEVudGVyIHN0YXRlc1xuICBuZXh0U3RhdGUgPSBlbnRlclN0YXRlcyhuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGludGVybmFsUXVldWUsIGhpc3RvcnlWYWx1ZSwgaXNJbml0aWFsKTtcbiAgY29uc3QgbmV4dFN0YXRlTm9kZXMgPSBbLi4ubXV0U3RhdGVOb2RlU2V0XTtcbiAgaWYgKG5leHRTdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgIG5leHRTdGF0ZSA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBuZXh0U3RhdGVOb2Rlcy5zb3J0KChhLCBiKSA9PiBiLm9yZGVyIC0gYS5vcmRlcikuZmxhdE1hcChzdGF0ZSA9PiBzdGF0ZS5leGl0KSwgaW50ZXJuYWxRdWV1ZSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhdGNoXG4gIHRyeSB7XG4gICAgaWYgKGhpc3RvcnlWYWx1ZSA9PT0gY3VycmVudFNuYXBzaG90Lmhpc3RvcnlWYWx1ZSAmJiBhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsKGN1cnJlbnRTbmFwc2hvdC5fbm9kZXMsIG11dFN0YXRlTm9kZVNldCkpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZU1hY2hpbmVTbmFwc2hvdChuZXh0U3RhdGUsIHtcbiAgICAgIF9ub2RlczogbmV4dFN0YXRlTm9kZXMsXG4gICAgICBoaXN0b3J5VmFsdWVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgb25jZSBwcm9wZXIgZXJyb3IgaGFuZGxpbmcgaXMgaW1wbGVtZW50ZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGF0ZWx5YWkvcmZjcy9wdWxsLzRcbiAgICB0aHJvdyBlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRNYWNoaW5lT3V0cHV0KHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgcm9vdE5vZGUsIHJvb3RDb21wbGV0aW9uTm9kZSkge1xuICBpZiAocm9vdE5vZGUub3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZG9uZVN0YXRlRXZlbnQgPSBjcmVhdGVEb25lU3RhdGVFdmVudChyb290Q29tcGxldGlvbk5vZGUuaWQsIHJvb3RDb21wbGV0aW9uTm9kZS5vdXRwdXQgIT09IHVuZGVmaW5lZCAmJiByb290Q29tcGxldGlvbk5vZGUucGFyZW50ID8gcmVzb2x2ZU91dHB1dChyb290Q29tcGxldGlvbk5vZGUub3V0cHV0LCBzbmFwc2hvdC5jb250ZXh0LCBldmVudCwgYWN0b3JTY29wZS5zZWxmKSA6IHVuZGVmaW5lZCk7XG4gIHJldHVybiByZXNvbHZlT3V0cHV0KHJvb3ROb2RlLm91dHB1dCwgc25hcHNob3QuY29udGV4dCwgZG9uZVN0YXRlRXZlbnQsIGFjdG9yU2NvcGUuc2VsZik7XG59XG5mdW5jdGlvbiBlbnRlclN0YXRlcyhjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGludGVybmFsUXVldWUsIGhpc3RvcnlWYWx1ZSwgaXNJbml0aWFsKSB7XG4gIGxldCBuZXh0U25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7XG4gIGNvbnN0IHN0YXRlc1RvRW50ZXIgPSBuZXcgU2V0KCk7XG4gIC8vIHRob3NlIGFyZSBzdGF0ZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IHRhcmdldGVkIG9yIGluZGlyZWN0bHkgdGFyZ2V0ZWQgYnkgdGhlIGV4cGxpY2l0IHRhcmdldFxuICAvLyBpbiBvdGhlciB3b3JkcywgdGhvc2UgYXJlIHN0YXRlcyBmb3Igd2hpY2ggaW5pdGlhbCBhY3Rpb25zIHNob3VsZCBiZSBleGVjdXRlZFxuICAvLyB3aGVuIHdlIHRhcmdldCBgI2RlZXBfY2hpbGRgIGluaXRpYWwgYWN0aW9ucyBvZiBpdHMgYW5jZXN0b3JzIHNob3VsZG4ndCBiZSBleGVjdXRlZFxuICBjb25zdCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkgPSBuZXcgU2V0KCk7XG4gIGNvbXB1dGVFbnRyeVNldChmaWx0ZXJlZFRyYW5zaXRpb25zLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG5cbiAgLy8gSW4gdGhlIGluaXRpYWwgc3RhdGUsIHRoZSByb290IHN0YXRlIG5vZGUgaXMgXCJlbnRlcmVkXCIuXG4gIGlmIChpc0luaXRpYWwpIHtcbiAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKGN1cnJlbnRTbmFwc2hvdC5tYWNoaW5lLnJvb3QpO1xuICB9XG4gIGNvbnN0IGNvbXBsZXRlZE5vZGVzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHN0YXRlTm9kZVRvRW50ZXIgb2YgWy4uLnN0YXRlc1RvRW50ZXJdLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKSkge1xuICAgIG11dFN0YXRlTm9kZVNldC5hZGQoc3RhdGVOb2RlVG9FbnRlcik7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuXG4gICAgLy8gQWRkIGVudHJ5IGFjdGlvbnNcbiAgICBhY3Rpb25zLnB1c2goLi4uc3RhdGVOb2RlVG9FbnRlci5lbnRyeSk7XG4gICAgZm9yIChjb25zdCBpbnZva2VEZWYgb2Ygc3RhdGVOb2RlVG9FbnRlci5pbnZva2UpIHtcbiAgICAgIGFjdGlvbnMucHVzaChzcGF3bkNoaWxkKGludm9rZURlZi5zcmMsIHtcbiAgICAgICAgLi4uaW52b2tlRGVmLFxuICAgICAgICBzeW5jU25hcHNob3Q6ICEhaW52b2tlRGVmLm9uU25hcHNob3RcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5oYXMoc3RhdGVOb2RlVG9FbnRlcikpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxBY3Rpb25zID0gc3RhdGVOb2RlVG9FbnRlci5pbml0aWFsLmFjdGlvbnM7XG4gICAgICBhY3Rpb25zLnB1c2goLi4uaW5pdGlhbEFjdGlvbnMpO1xuICAgIH1cbiAgICBuZXh0U25hcHNob3QgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywgaW50ZXJuYWxRdWV1ZSwgc3RhdGVOb2RlVG9FbnRlci5pbnZva2UubWFwKGludm9rZURlZiA9PiBpbnZva2VEZWYuaWQpKTtcbiAgICBpZiAoc3RhdGVOb2RlVG9FbnRlci50eXBlID09PSAnZmluYWwnKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGF0ZU5vZGVUb0VudGVyLnBhcmVudDtcbiAgICAgIGxldCBhbmNlc3Rvck1hcmtlciA9IHBhcmVudD8udHlwZSA9PT0gJ3BhcmFsbGVsJyA/IHBhcmVudCA6IHBhcmVudD8ucGFyZW50O1xuICAgICAgbGV0IHJvb3RDb21wbGV0aW9uTm9kZSA9IGFuY2VzdG9yTWFya2VyIHx8IHN0YXRlTm9kZVRvRW50ZXI7XG4gICAgICBpZiAocGFyZW50Py50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICAgIGludGVybmFsUXVldWUucHVzaChjcmVhdGVEb25lU3RhdGVFdmVudChwYXJlbnQuaWQsIHN0YXRlTm9kZVRvRW50ZXIub3V0cHV0ICE9PSB1bmRlZmluZWQgPyByZXNvbHZlT3V0cHV0KHN0YXRlTm9kZVRvRW50ZXIub3V0cHV0LCBuZXh0U25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUuc2VsZikgOiB1bmRlZmluZWQpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhbmNlc3Rvck1hcmtlcj8udHlwZSA9PT0gJ3BhcmFsbGVsJyAmJiAhY29tcGxldGVkTm9kZXMuaGFzKGFuY2VzdG9yTWFya2VyKSAmJiBpc0luRmluYWxTdGF0ZShtdXRTdGF0ZU5vZGVTZXQsIGFuY2VzdG9yTWFya2VyKSkge1xuICAgICAgICBjb21wbGV0ZWROb2Rlcy5hZGQoYW5jZXN0b3JNYXJrZXIpO1xuICAgICAgICBpbnRlcm5hbFF1ZXVlLnB1c2goY3JlYXRlRG9uZVN0YXRlRXZlbnQoYW5jZXN0b3JNYXJrZXIuaWQpKTtcbiAgICAgICAgcm9vdENvbXBsZXRpb25Ob2RlID0gYW5jZXN0b3JNYXJrZXI7XG4gICAgICAgIGFuY2VzdG9yTWFya2VyID0gYW5jZXN0b3JNYXJrZXIucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKGFuY2VzdG9yTWFya2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV4dFNuYXBzaG90ID0gY2xvbmVNYWNoaW5lU25hcHNob3QobmV4dFNuYXBzaG90LCB7XG4gICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICBvdXRwdXQ6IGdldE1hY2hpbmVPdXRwdXQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgbmV4dFNuYXBzaG90Lm1hY2hpbmUucm9vdCwgcm9vdENvbXBsZXRpb25Ob2RlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlRW50cnlTZXQodHJhbnNpdGlvbnMsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKSB7XG4gIGZvciAoY29uc3QgdCBvZiB0cmFuc2l0aW9ucykge1xuICAgIGNvbnN0IGRvbWFpbiA9IGdldFRyYW5zaXRpb25Eb21haW4odCwgaGlzdG9yeVZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdC50YXJnZXQgfHwgW10pIHtcbiAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShzKSAmJiAoXG4gICAgICAvLyBpZiB0aGUgdGFyZ2V0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzb3VyY2UgdGhlbiBpdCB3aWxsICpkZWZpbml0ZWx5KiBiZSBlbnRlcmVkXG4gICAgICB0LnNvdXJjZSAhPT0gcyB8fFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBkb21haW4gY2FuJ3QgbGllIHdpdGhpbiB0aGUgc291cmNlXG4gICAgICAvLyBpZiBpdCdzIGRpZmZlcmVudCB0aGFuIHRoZSBzb3VyY2UgdGhlbiBpdCdzIG91dHNpZGUgb2YgaXQgYW5kIGl0IG1lYW5zIHRoYXQgdGhlIHRhcmdldCBoYXMgdG8gYmUgZW50ZXJlZCBhcyB3ZWxsXG4gICAgICB0LnNvdXJjZSAhPT0gZG9tYWluIHx8XG4gICAgICAvLyByZWVudGVyaW5nIHRyYW5zaXRpb25zIGFsd2F5cyBlbnRlciB0aGUgdGFyZ2V0LCBldmVuIGlmIGl0J3MgdGhlIHNvdXJjZSBpdHNlbGZcbiAgICAgIHQucmVlbnRlcikpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQocyk7XG4gICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQocyk7XG4gICAgICB9XG4gICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRlcyA9IGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0LCBoaXN0b3J5VmFsdWUpO1xuICAgIGZvciAoY29uc3QgcyBvZiB0YXJnZXRTdGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IGdldFByb3BlckFuY2VzdG9ycyhzLCBkb21haW4pO1xuICAgICAgaWYgKGRvbWFpbj8udHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChkb21haW4pO1xuICAgICAgfVxuICAgICAgYWRkQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBhbmNlc3RvcnMsICF0LnNvdXJjZS5wYXJlbnQgJiYgdC5yZWVudGVyID8gdW5kZWZpbmVkIDogZG9tYWluKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKHN0YXRlTm9kZSwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpIHtcbiAgaWYgKGlzSGlzdG9yeU5vZGUoc3RhdGVOb2RlKSkge1xuICAgIGlmIChoaXN0b3J5VmFsdWVbc3RhdGVOb2RlLmlkXSkge1xuICAgICAgY29uc3QgaGlzdG9yeVN0YXRlTm9kZXMgPSBoaXN0b3J5VmFsdWVbc3RhdGVOb2RlLmlkXTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5U3RhdGVOb2Rlcykge1xuICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChzKTtcbiAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzIG9mIGhpc3RvcnlTdGF0ZU5vZGVzKSB7XG4gICAgICAgIGFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlcihzLCBzdGF0ZU5vZGUucGFyZW50LCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiA9IHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24oc3RhdGVOb2RlKTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24udGFyZ2V0KSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKHMpO1xuICAgICAgICBpZiAoaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uID09PSBzdGF0ZU5vZGUucGFyZW50Py5pbml0aWFsKSB7XG4gICAgICAgICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChzdGF0ZU5vZGUucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uLnRhcmdldCkge1xuICAgICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIocywgc3RhdGVOb2RlLnBhcmVudCwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIGNvbnN0IFtpbml0aWFsU3RhdGVdID0gc3RhdGVOb2RlLmluaXRpYWwudGFyZ2V0O1xuICAgICAgaWYgKCFpc0hpc3RvcnlOb2RlKGluaXRpYWxTdGF0ZSkpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChpbml0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIoaW5pdGlhbFN0YXRlLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIoaW5pdGlhbFN0YXRlLCBzdGF0ZU5vZGUsIHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5maWx0ZXIoc24gPT4gIWlzSGlzdG9yeU5vZGUoc24pKSkge1xuICAgICAgICAgIGlmICghWy4uLnN0YXRlc1RvRW50ZXJdLnNvbWUocyA9PiBpc0Rlc2NlbmRhbnQocywgY2hpbGQpKSkge1xuICAgICAgICAgICAgaWYgKCFpc0hpc3RvcnlOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIoY2hpbGQsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgYW5jZXN0b3JzLCByZWVudHJhbmN5RG9tYWluKSB7XG4gIGZvciAoY29uc3QgYW5jIG9mIGFuY2VzdG9ycykge1xuICAgIGlmICghcmVlbnRyYW5jeURvbWFpbiB8fCBpc0Rlc2NlbmRhbnQoYW5jLCByZWVudHJhbmN5RG9tYWluKSkge1xuICAgICAgc3RhdGVzVG9FbnRlci5hZGQoYW5jKTtcbiAgICB9XG4gICAgaWYgKGFuYy50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKGFuYykuZmlsdGVyKHNuID0+ICFpc0hpc3RvcnlOb2RlKHNuKSkpIHtcbiAgICAgICAgaWYgKCFbLi4uc3RhdGVzVG9FbnRlcl0uc29tZShzID0+IGlzRGVzY2VuZGFudChzLCBjaGlsZCkpKSB7XG4gICAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoY2hpbGQpO1xuICAgICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGNoaWxkLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlLCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSkge1xuICBhZGRBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlKSk7XG59XG5mdW5jdGlvbiBleGl0U3RhdGVzKGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSwgaW50ZXJuYWxRdWV1ZSwgX2FjdGlvbkV4ZWN1dG9yKSB7XG4gIGxldCBuZXh0U25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7XG4gIGNvbnN0IHN0YXRlc1RvRXhpdCA9IGNvbXB1dGVFeGl0U2V0KHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSk7XG4gIHN0YXRlc1RvRXhpdC5zb3J0KChhLCBiKSA9PiBiLm9yZGVyIC0gYS5vcmRlcik7XG4gIGxldCBjaGFuZ2VkSGlzdG9yeTtcblxuICAvLyBGcm9tIFNDWE1MIGFsZ29yaXRobTogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNleGl0U3RhdGVzXG4gIGZvciAoY29uc3QgZXhpdFN0YXRlTm9kZSBvZiBzdGF0ZXNUb0V4aXQpIHtcbiAgICBmb3IgKGNvbnN0IGhpc3RvcnlOb2RlIG9mIGdldEhpc3RvcnlOb2RlcyhleGl0U3RhdGVOb2RlKSkge1xuICAgICAgbGV0IHByZWRpY2F0ZTtcbiAgICAgIGlmIChoaXN0b3J5Tm9kZS5oaXN0b3J5ID09PSAnZGVlcCcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gc24gPT4gaXNBdG9taWNTdGF0ZU5vZGUoc24pICYmIGlzRGVzY2VuZGFudChzbiwgZXhpdFN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVkaWNhdGUgPSBzbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIHNuLnBhcmVudCA9PT0gZXhpdFN0YXRlTm9kZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNoYW5nZWRIaXN0b3J5ID8/PSB7XG4gICAgICAgIC4uLmhpc3RvcnlWYWx1ZVxuICAgICAgfTtcbiAgICAgIGNoYW5nZWRIaXN0b3J5W2hpc3RvcnlOb2RlLmlkXSA9IEFycmF5LmZyb20obXV0U3RhdGVOb2RlU2V0KS5maWx0ZXIocHJlZGljYXRlKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzIG9mIHN0YXRlc1RvRXhpdCkge1xuICAgIG5leHRTbmFwc2hvdCA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBbLi4ucy5leGl0LCAuLi5zLmludm9rZS5tYXAoZGVmID0+IHN0b3BDaGlsZChkZWYuaWQpKV0sIGludGVybmFsUXVldWUsIHVuZGVmaW5lZCk7XG4gICAgbXV0U3RhdGVOb2RlU2V0LmRlbGV0ZShzKTtcbiAgfVxuICByZXR1cm4gW25leHRTbmFwc2hvdCwgY2hhbmdlZEhpc3RvcnkgfHwgaGlzdG9yeVZhbHVlXTtcbn1cbmZ1bmN0aW9uIGdldEFjdGlvbihtYWNoaW5lLCBhY3Rpb25UeXBlKSB7XG4gIHJldHVybiBtYWNoaW5lLmltcGxlbWVudGF0aW9ucy5hY3Rpb25zW2FjdGlvblR5cGVdO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywgZXh0cmEsIHJldHJpZXMpIHtcbiAgY29uc3Qge1xuICAgIG1hY2hpbmVcbiAgfSA9IGN1cnJlbnRTbmFwc2hvdDtcbiAgbGV0IGludGVybWVkaWF0ZVNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgY29uc3QgaXNJbmxpbmUgPSB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nO1xuICAgIGNvbnN0IHJlc29sdmVkQWN0aW9uID0gaXNJbmxpbmUgPyBhY3Rpb24gOlxuICAgIC8vIHRoZSBleGlzdGluZyB0eXBlIG9mIGAuYWN0aW9uc2AgYXNzdW1lcyBub24tbnVsbGFibGUgYFRFeHByZXNzaW9uQWN0aW9uYFxuICAgIC8vIGl0J3MgZmluZSB0byBjYXN0IHRoaXMgaGVyZSB0byBnZXQgYSBjb21tb24gdHlwZSBhbmQgbGFjayBvZiBlcnJvcnMgaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGVcbiAgICAvLyBvdXIgbG9naWMgYmVsb3cgbWFrZXMgc3VyZSB0aGF0IHdlIGNhbGwgdGhvc2UgMiBcInZhcmlhbnRzXCIgY29ycmVjdGx5XG5cbiAgICBnZXRBY3Rpb24obWFjaGluZSwgdHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycgPyBhY3Rpb24gOiBhY3Rpb24udHlwZSk7XG4gICAgY29uc3QgYWN0aW9uQXJncyA9IHtcbiAgICAgIGNvbnRleHQ6IGludGVybWVkaWF0ZVNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIHN5c3RlbTogYWN0b3JTY29wZS5zeXN0ZW1cbiAgICB9O1xuICAgIGNvbnN0IGFjdGlvblBhcmFtcyA9IGlzSW5saW5lIHx8IHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogJ3BhcmFtcycgaW4gYWN0aW9uID8gdHlwZW9mIGFjdGlvbi5wYXJhbXMgPT09ICdmdW5jdGlvbicgPyBhY3Rpb24ucGFyYW1zKHtcbiAgICAgIGNvbnRleHQ6IGludGVybWVkaWF0ZVNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudFxuICAgIH0pIDogYWN0aW9uLnBhcmFtcyA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIXJlc29sdmVkQWN0aW9uIHx8ICEoJ3Jlc29sdmUnIGluIHJlc29sdmVkQWN0aW9uKSkge1xuICAgICAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcih7XG4gICAgICAgIHR5cGU6IHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gYWN0aW9uIDogdHlwZW9mIGFjdGlvbiA9PT0gJ29iamVjdCcgPyBhY3Rpb24udHlwZSA6IGFjdGlvbi5uYW1lIHx8ICcoYW5vbnltb3VzKScsXG4gICAgICAgIGluZm86IGFjdGlvbkFyZ3MsXG4gICAgICAgIHBhcmFtczogYWN0aW9uUGFyYW1zLFxuICAgICAgICBleGVjOiByZXNvbHZlZEFjdGlvblxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYnVpbHRpbkFjdGlvbiA9IHJlc29sdmVkQWN0aW9uO1xuICAgIGNvbnN0IFtuZXh0U3RhdGUsIHBhcmFtcywgYWN0aW9uc10gPSBidWlsdGluQWN0aW9uLnJlc29sdmUoYWN0b3JTY29wZSwgaW50ZXJtZWRpYXRlU25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywgcmVzb2x2ZWRBY3Rpb24sXG4gICAgLy8gdGhpcyBob2xkcyBhbGwgcGFyYW1zXG4gICAgZXh0cmEpO1xuICAgIGludGVybWVkaWF0ZVNuYXBzaG90ID0gbmV4dFN0YXRlO1xuICAgIGlmICgncmV0cnlSZXNvbHZlJyBpbiBidWlsdGluQWN0aW9uKSB7XG4gICAgICByZXRyaWVzPy5wdXNoKFtidWlsdGluQWN0aW9uLCBwYXJhbXNdKTtcbiAgICB9XG4gICAgaWYgKCdleGVjdXRlJyBpbiBidWlsdGluQWN0aW9uKSB7XG4gICAgICBhY3RvclNjb3BlLmFjdGlvbkV4ZWN1dG9yKHtcbiAgICAgICAgdHlwZTogYnVpbHRpbkFjdGlvbi50eXBlLFxuICAgICAgICBpbmZvOiBhY3Rpb25BcmdzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGV4ZWM6IGJ1aWx0aW5BY3Rpb24uZXhlY3V0ZS5iaW5kKG51bGwsIGFjdG9yU2NvcGUsIHBhcmFtcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYWN0aW9ucykge1xuICAgICAgaW50ZXJtZWRpYXRlU25hcHNob3QgPSByZXNvbHZlQW5kRXhlY3V0ZUFjdGlvbnNXaXRoQ29udGV4dChpbnRlcm1lZGlhdGVTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGV4dHJhLCByZXRyaWVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVybWVkaWF0ZVNuYXBzaG90O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGludGVybmFsUXVldWUsIGRlZmVycmVkQWN0b3JJZHMpIHtcbiAgY29uc3QgcmV0cmllcyA9IGRlZmVycmVkQWN0b3JJZHMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmV4dFN0YXRlID0gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywge1xuICAgIGludGVybmFsUXVldWUsXG4gICAgZGVmZXJyZWRBY3Rvcklkc1xuICB9LCByZXRyaWVzKTtcbiAgcmV0cmllcz8uZm9yRWFjaCgoW2J1aWx0aW5BY3Rpb24sIHBhcmFtc10pID0+IHtcbiAgICBidWlsdGluQWN0aW9uLnJldHJ5UmVzb2x2ZShhY3RvclNjb3BlLCBuZXh0U3RhdGUsIHBhcmFtcyk7XG4gIH0pO1xuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuZnVuY3Rpb24gbWFjcm9zdGVwKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSkge1xuICBpZiAoZXZlbnQudHlwZSA9PT0gV0lMRENBUkQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIGV2ZW50IGNhbm5vdCBoYXZlIHRoZSB3aWxkY2FyZCB0eXBlICgnJHtXSUxEQ0FSRH0nKWApO1xuICB9XG4gIGxldCBuZXh0U25hcHNob3QgPSBzbmFwc2hvdDtcbiAgY29uc3QgbWljcm9zdGF0ZXMgPSBbXTtcbiAgZnVuY3Rpb24gYWRkTWljcm9zdGF0ZShtaWNyb3N0YXRlLCBldmVudCwgdHJhbnNpdGlvbnMpIHtcbiAgICBhY3RvclNjb3BlLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5taWNyb3N0ZXAnLFxuICAgICAgYWN0b3JSZWY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIGV2ZW50LFxuICAgICAgc25hcHNob3Q6IG1pY3Jvc3RhdGUsXG4gICAgICBfdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zXG4gICAgfSk7XG4gICAgbWljcm9zdGF0ZXMucHVzaChtaWNyb3N0YXRlKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBzdG9wIGV2ZW50XG4gIGlmIChldmVudC50eXBlID09PSBYU1RBVEVfU1RPUCkge1xuICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KHN0b3BDaGlsZHJlbihuZXh0U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSwge1xuICAgICAgc3RhdHVzOiAnc3RvcHBlZCdcbiAgICB9KTtcbiAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgZXZlbnQsIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICAgIG1pY3Jvc3RhdGVzXG4gICAgfTtcbiAgfVxuICBsZXQgbmV4dEV2ZW50ID0gZXZlbnQ7XG5cbiAgLy8gQXNzdW1lIHRoZSBzdGF0ZSBpcyBhdCByZXN0IChubyByYWlzZWQgZXZlbnRzKVxuICAvLyBEZXRlcm1pbmUgdGhlIG5leHQgc3RhdGUgYmFzZWQgb24gdGhlIG5leHQgbWljcm9zdGVwXG4gIGlmIChuZXh0RXZlbnQudHlwZSAhPT0gWFNUQVRFX0lOSVQpIHtcbiAgICBjb25zdCBjdXJyZW50RXZlbnQgPSBuZXh0RXZlbnQ7XG4gICAgY29uc3QgaXNFcnIgPSBpc0Vycm9yQWN0b3JFdmVudChjdXJyZW50RXZlbnQpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25zID0gc2VsZWN0VHJhbnNpdGlvbnMoY3VycmVudEV2ZW50LCBuZXh0U25hcHNob3QpO1xuICAgIGlmIChpc0VyciAmJiAhdHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgbGlrZWx5IG9ubHkgYWxsb3cgdHJhbnNpdGlvbnMgc2VsZWN0ZWQgYnkgdmVyeSBleHBsaWNpdCBkZXNjcmlwdG9yc1xuICAgICAgLy8gYCpgIHNob3VsZG4ndCBiZSBtYXRjaGVkLCBsaWtlbHkgYHhzdGF0ZS5lcnJvci4qYCBzaG91bGRuJ3QgYmUgZWl0aGVyXG4gICAgICAvLyBzaW1pbGFybHkgYHhzdGF0ZS5lcnJvci5hY3Rvci4qYCBhbmQgYHhzdGF0ZS5lcnJvci5hY3Rvci50b2RvLipgIGhhdmUgdG8gYmUgY29uc2lkZXJlZCB0b29cbiAgICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3I6IGN1cnJlbnRFdmVudC5lcnJvclxuICAgICAgfSk7XG4gICAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgY3VycmVudEV2ZW50LCBbXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzbmFwc2hvdDogbmV4dFNuYXBzaG90LFxuICAgICAgICBtaWNyb3N0YXRlc1xuICAgICAgfTtcbiAgICB9XG4gICAgbmV4dFNuYXBzaG90ID0gbWljcm9zdGVwKHRyYW5zaXRpb25zLCBzbmFwc2hvdCwgYWN0b3JTY29wZSwgbmV4dEV2ZW50LCBmYWxzZSxcbiAgICAvLyBpc0luaXRpYWxcbiAgICBpbnRlcm5hbFF1ZXVlKTtcbiAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgY3VycmVudEV2ZW50LCB0cmFuc2l0aW9ucyk7XG4gIH1cbiAgbGV0IHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgd2hpbGUgKG5leHRTbmFwc2hvdC5zdGF0dXMgPT09ICdhY3RpdmUnKSB7XG4gICAgbGV0IGVuYWJsZWRUcmFuc2l0aW9ucyA9IHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID8gc2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMobmV4dFNuYXBzaG90LCBuZXh0RXZlbnQpIDogW107XG5cbiAgICAvLyBldmVudGxlc3MgdHJhbnNpdGlvbnMgc2hvdWxkIGFsd2F5cyBiZSBzZWxlY3RlZCBhZnRlciBzZWxlY3RpbmcgKnJlZ3VsYXIqIHRyYW5zaXRpb25zXG4gICAgLy8gYnkgYXNzaWduaW5nIGB1bmRlZmluZWRgIHRvIGBwcmV2aW91c1N0YXRlYCB3ZSBlbnN1cmUgdGhhdCBgc2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnNgIGdldHMgYWx3YXlzIGNvbXB1dGVkIHRvIHRydWUgaW4gc3VjaCBhIGNhc2VcbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gZW5hYmxlZFRyYW5zaXRpb25zLmxlbmd0aCA/IG5leHRTbmFwc2hvdCA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWVuYWJsZWRUcmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGlmICghaW50ZXJuYWxRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuZXh0RXZlbnQgPSBpbnRlcm5hbFF1ZXVlLnNoaWZ0KCk7XG4gICAgICBlbmFibGVkVHJhbnNpdGlvbnMgPSBzZWxlY3RUcmFuc2l0aW9ucyhuZXh0RXZlbnQsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICAgIG5leHRTbmFwc2hvdCA9IG1pY3Jvc3RlcChlbmFibGVkVHJhbnNpdGlvbnMsIG5leHRTbmFwc2hvdCwgYWN0b3JTY29wZSwgbmV4dEV2ZW50LCBmYWxzZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgc2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMgPSBuZXh0U25hcHNob3QgIT09IHByZXZpb3VzU3RhdGU7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIG5leHRFdmVudCwgZW5hYmxlZFRyYW5zaXRpb25zKTtcbiAgfVxuICBpZiAobmV4dFNuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICBzdG9wQ2hpbGRyZW4obmV4dFNuYXBzaG90LCBuZXh0RXZlbnQsIGFjdG9yU2NvcGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICBtaWNyb3N0YXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc3RvcENoaWxkcmVuKG5leHRTdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUpIHtcbiAgcmV0dXJuIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBPYmplY3QudmFsdWVzKG5leHRTdGF0ZS5jaGlsZHJlbikubWFwKGNoaWxkID0+IHN0b3BDaGlsZChjaGlsZCkpLCBbXSwgdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRyYW5zaXRpb25zKGV2ZW50LCBuZXh0U3RhdGUpIHtcbiAgcmV0dXJuIG5leHRTdGF0ZS5tYWNoaW5lLmdldFRyYW5zaXRpb25EYXRhKG5leHRTdGF0ZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gc2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMobmV4dFN0YXRlLCBldmVudCkge1xuICBjb25zdCBlbmFibGVkVHJhbnNpdGlvblNldCA9IG5ldyBTZXQoKTtcbiAgY29uc3QgYXRvbWljU3RhdGVzID0gbmV4dFN0YXRlLl9ub2Rlcy5maWx0ZXIoaXNBdG9taWNTdGF0ZU5vZGUpO1xuICBmb3IgKGNvbnN0IHN0YXRlTm9kZSBvZiBhdG9taWNTdGF0ZXMpIHtcbiAgICBsb29wOiBmb3IgKGNvbnN0IHMgb2YgW3N0YXRlTm9kZV0uY29uY2F0KGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHVuZGVmaW5lZCkpKSB7XG4gICAgICBpZiAoIXMuYWx3YXlzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIHMuYWx3YXlzKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uLmd1YXJkID09PSB1bmRlZmluZWQgfHwgZXZhbHVhdGVHdWFyZCh0cmFuc2l0aW9uLmd1YXJkLCBuZXh0U3RhdGUuY29udGV4dCwgZXZlbnQsIG5leHRTdGF0ZSkpIHtcbiAgICAgICAgICBlbmFibGVkVHJhbnNpdGlvblNldC5hZGQodHJhbnNpdGlvbik7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVtb3ZlQ29uZmxpY3RpbmdUcmFuc2l0aW9ucyhBcnJheS5mcm9tKGVuYWJsZWRUcmFuc2l0aW9uU2V0KSwgbmV3IFNldChuZXh0U3RhdGUuX25vZGVzKSwgbmV4dFN0YXRlLmhpc3RvcnlWYWx1ZSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBwYXJ0aWFsIHN0YXRlIHZhbHVlIHdpdGggaXRzIGZ1bGwgcmVwcmVzZW50YXRpb24gaW4gdGhlIHN0YXRlXG4gKiBub2RlJ3MgbWFjaGluZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgcGFydGlhbCBzdGF0ZSB2YWx1ZSB0byByZXNvbHZlLlxuICovXG5mdW5jdGlvbiByZXNvbHZlU3RhdGVWYWx1ZShyb290Tm9kZSwgc3RhdGVWYWx1ZSkge1xuICBjb25zdCBhbGxTdGF0ZU5vZGVzID0gZ2V0QWxsU3RhdGVOb2RlcyhnZXRTdGF0ZU5vZGVzKHJvb3ROb2RlLCBzdGF0ZVZhbHVlKSk7XG4gIHJldHVybiBnZXRTdGF0ZVZhbHVlKHJvb3ROb2RlLCBbLi4uYWxsU3RhdGVOb2Rlc10pO1xufVxuXG5mdW5jdGlvbiBpc01hY2hpbmVTbmFwc2hvdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICdtYWNoaW5lJyBpbiB2YWx1ZSAmJiAndmFsdWUnIGluIHZhbHVlO1xufVxuY29uc3QgbWFjaGluZVNuYXBzaG90TWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXModGVzdFZhbHVlKSB7XG4gIHJldHVybiBtYXRjaGVzU3RhdGUodGVzdFZhbHVlLCB0aGlzLnZhbHVlKTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RIYXNUYWcgPSBmdW5jdGlvbiBoYXNUYWcodGFnKSB7XG4gIHJldHVybiB0aGlzLnRhZ3MuaGFzKHRhZyk7XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90Q2FuID0gZnVuY3Rpb24gY2FuKGV2ZW50KSB7XG4gIGlmICghdGhpcy5tYWNoaW5lKSB7XG4gICAgY29uc29sZS53YXJuKGBzdGF0ZS5jYW4oLi4uKSB1c2VkIG91dHNpZGUgb2YgYSBtYWNoaW5lLWNyZWF0ZWQgU3RhdGUgb2JqZWN0OyB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5gKTtcbiAgfVxuICBjb25zdCB0cmFuc2l0aW9uRGF0YSA9IHRoaXMubWFjaGluZS5nZXRUcmFuc2l0aW9uRGF0YSh0aGlzLCBldmVudCk7XG4gIHJldHVybiAhIXRyYW5zaXRpb25EYXRhPy5sZW5ndGggJiZcbiAgLy8gQ2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdHJhbnNpdGlvbiBpcyBub3QgZm9yYmlkZGVuXG4gIHRyYW5zaXRpb25EYXRhLnNvbWUodCA9PiB0LnRhcmdldCAhPT0gdW5kZWZpbmVkIHx8IHQuYWN0aW9ucy5sZW5ndGgpO1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdFRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgY29uc3Qge1xuICAgIF9ub2Rlczogbm9kZXMsXG4gICAgdGFncyxcbiAgICBtYWNoaW5lLFxuICAgIGdldE1ldGEsXG4gICAgdG9KU09OLFxuICAgIGNhbixcbiAgICBoYXNUYWcsXG4gICAgbWF0Y2hlcyxcbiAgICAuLi5qc29uVmFsdWVzXG4gIH0gPSB0aGlzO1xuICByZXR1cm4ge1xuICAgIC4uLmpzb25WYWx1ZXMsXG4gICAgdGFnczogQXJyYXkuZnJvbSh0YWdzKVxuICB9O1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdEdldE1ldGEgPSBmdW5jdGlvbiBnZXRNZXRhKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXMucmVkdWNlKChhY2MsIHN0YXRlTm9kZSkgPT4ge1xuICAgIGlmIChzdGF0ZU5vZGUubWV0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhY2Nbc3RhdGVOb2RlLmlkXSA9IHN0YXRlTm9kZS5tZXRhO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlTWFjaGluZVNuYXBzaG90KGNvbmZpZywgbWFjaGluZSkge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogY29uZmlnLnN0YXR1cyxcbiAgICBvdXRwdXQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgZXJyb3I6IGNvbmZpZy5lcnJvcixcbiAgICBtYWNoaW5lLFxuICAgIGNvbnRleHQ6IGNvbmZpZy5jb250ZXh0LFxuICAgIF9ub2RlczogY29uZmlnLl9ub2RlcyxcbiAgICB2YWx1ZTogZ2V0U3RhdGVWYWx1ZShtYWNoaW5lLnJvb3QsIGNvbmZpZy5fbm9kZXMpLFxuICAgIHRhZ3M6IG5ldyBTZXQoY29uZmlnLl9ub2Rlcy5mbGF0TWFwKHNuID0+IHNuLnRhZ3MpKSxcbiAgICBjaGlsZHJlbjogY29uZmlnLmNoaWxkcmVuLFxuICAgIGhpc3RvcnlWYWx1ZTogY29uZmlnLmhpc3RvcnlWYWx1ZSB8fCB7fSxcbiAgICBtYXRjaGVzOiBtYWNoaW5lU25hcHNob3RNYXRjaGVzLFxuICAgIGhhc1RhZzogbWFjaGluZVNuYXBzaG90SGFzVGFnLFxuICAgIGNhbjogbWFjaGluZVNuYXBzaG90Q2FuLFxuICAgIGdldE1ldGE6IG1hY2hpbmVTbmFwc2hvdEdldE1ldGEsXG4gICAgdG9KU09OOiBtYWNoaW5lU25hcHNob3RUb0pTT05cbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gY3JlYXRlTWFjaGluZVNuYXBzaG90KHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICAuLi5jb25maWdcbiAgfSwgc25hcHNob3QubWFjaGluZSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVIaXN0b3J5VmFsdWUoaGlzdG9yeVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaGlzdG9yeVZhbHVlICE9PSAnb2JqZWN0JyB8fCBoaXN0b3J5VmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGhpc3RvcnlWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gaGlzdG9yeVZhbHVlW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlLm1hcChpdGVtID0+ICh7XG4gICAgICAgIGlkOiBpdGVtLmlkXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgX25vZGVzOiBub2RlcyxcbiAgICB0YWdzLFxuICAgIG1hY2hpbmUsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dCxcbiAgICBjYW4sXG4gICAgaGFzVGFnLFxuICAgIG1hdGNoZXMsXG4gICAgZ2V0TWV0YSxcbiAgICB0b0pTT04sXG4gICAgLi4uanNvblZhbHVlc1xuICB9ID0gc25hcHNob3Q7XG4gIGNvbnN0IGNoaWxkcmVuSnNvbiA9IHt9O1xuICBmb3IgKGNvbnN0IGlkIGluIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpZF07XG4gICAgaWYgKHR5cGVvZiBjaGlsZC5zcmMgIT09ICdzdHJpbmcnICYmICghb3B0aW9ucyB8fCAhKCdfX3Vuc2FmZUFsbG93SW5saW5lQWN0b3JzJyBpbiBvcHRpb25zKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaW5saW5lIGNoaWxkIGFjdG9yIGNhbm5vdCBiZSBwZXJzaXN0ZWQuJyk7XG4gICAgfVxuICAgIGNoaWxkcmVuSnNvbltpZF0gPSB7XG4gICAgICBzbmFwc2hvdDogY2hpbGQuZ2V0UGVyc2lzdGVkU25hcHNob3Qob3B0aW9ucyksXG4gICAgICBzcmM6IGNoaWxkLnNyYyxcbiAgICAgIHN5c3RlbUlkOiBjaGlsZC5fc3lzdGVtSWQsXG4gICAgICBzeW5jU25hcHNob3Q6IGNoaWxkLl9zeW5jU25hcHNob3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IHBlcnNpc3RlZCA9IHtcbiAgICAuLi5qc29uVmFsdWVzLFxuICAgIGNvbnRleHQ6IHBlcnNpc3RDb250ZXh0KGNvbnRleHQpLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbkpzb24sXG4gICAgaGlzdG9yeVZhbHVlOiBzZXJpYWxpemVIaXN0b3J5VmFsdWUoanNvblZhbHVlcy5oaXN0b3J5VmFsdWUpXG4gIH07XG4gIHJldHVybiBwZXJzaXN0ZWQ7XG59XG5mdW5jdGlvbiBwZXJzaXN0Q29udGV4dChjb250ZXh0UGFydCkge1xuICBsZXQgY29weTtcbiAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dFBhcnQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHRQYXJ0W2tleV07XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICgnc2Vzc2lvbklkJyBpbiB2YWx1ZSAmJiAnc2VuZCcgaW4gdmFsdWUgJiYgJ3JlZicgaW4gdmFsdWUpIHtcbiAgICAgICAgY29weSA/Pz0gQXJyYXkuaXNBcnJheShjb250ZXh0UGFydCkgPyBjb250ZXh0UGFydC5zbGljZSgpIDoge1xuICAgICAgICAgIC4uLmNvbnRleHRQYXJ0XG4gICAgICAgIH07XG4gICAgICAgIGNvcHlba2V5XSA9IHtcbiAgICAgICAgICB4c3RhdGUkJHR5cGU6ICQkQUNUT1JfVFlQRSxcbiAgICAgICAgICBpZDogdmFsdWUuaWRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBlcnNpc3RDb250ZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBjb3B5ID8/PSBBcnJheS5pc0FycmF5KGNvbnRleHRQYXJ0KSA/IGNvbnRleHRQYXJ0LnNsaWNlKCkgOiB7XG4gICAgICAgICAgICAuLi5jb250ZXh0UGFydFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29weVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3B5ID8/IGNvbnRleHRQYXJ0O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUmFpc2UoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBldmVudDogZXZlbnRPckV4cHIsXG4gIGlkLFxuICBkZWxheVxufSwge1xuICBpbnRlcm5hbFF1ZXVlXG59KSB7XG4gIGNvbnN0IGRlbGF5c01hcCA9IHNuYXBzaG90Lm1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmRlbGF5cztcbiAgaWYgKHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgIGBPbmx5IGV2ZW50IG9iamVjdHMgbWF5IGJlIHVzZWQgd2l0aCByYWlzZTsgdXNlIHJhaXNlKHsgdHlwZTogXCIke2V2ZW50T3JFeHByfVwiIH0pIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICBsZXQgcmVzb2x2ZWREZWxheTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb25maWdEZWxheSA9IGRlbGF5c01hcCAmJiBkZWxheXNNYXBbZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgY29uZmlnRGVsYXkgPT09ICdmdW5jdGlvbicgPyBjb25maWdEZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGRlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBkZWxheTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc29sdmVkRGVsYXkgIT09ICdudW1iZXInKSB7XG4gICAgaW50ZXJuYWxRdWV1ZS5wdXNoKHJlc29sdmVkRXZlbnQpO1xuICB9XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICBldmVudDogcmVzb2x2ZWRFdmVudCxcbiAgICBpZCxcbiAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVJhaXNlKGFjdG9yU2NvcGUsIHBhcmFtcykge1xuICBjb25zdCB7XG4gICAgZXZlbnQsXG4gICAgZGVsYXksXG4gICAgaWRcbiAgfSA9IHBhcmFtcztcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBhY3RvclNjb3BlLnNlbGY7XG4gICAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuc2NoZWR1bGUoc2VsZiwgc2VsZiwgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG59XG4vKipcbiAqIFJhaXNlcyBhbiBldmVudC4gVGhpcyBwbGFjZXMgdGhlIGV2ZW50IGluIHRoZSBpbnRlcm5hbCBldmVudCBxdWV1ZSwgc28gdGhhdFxuICogdGhlIGV2ZW50IGlzIGltbWVkaWF0ZWx5IGNvbnN1bWVkIGJ5IHRoZSBtYWNoaW5lIGluIHRoZSBjdXJyZW50IHN0ZXAuXG4gKlxuICogQHBhcmFtIGV2ZW50VHlwZSBUaGUgZXZlbnQgdG8gcmFpc2UuXG4gKi9cbmZ1bmN0aW9uIHJhaXNlKGV2ZW50T3JFeHByLCBvcHRpb25zKSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgcmFpc2UoKWAgZGlyZWN0bHksIGFzIGl0IGlzIG5vdCBpbXBlcmF0aXZlLiBTZWUgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvYWN0aW9ucyNidWlsdC1pbi1hY3Rpb25zIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gIH1cbiAgZnVuY3Rpb24gcmFpc2UoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHJhaXNlLnR5cGUgPSAneHN0YXRlLnJhaXNlJztcbiAgcmFpc2UuZXZlbnQgPSBldmVudE9yRXhwcjtcbiAgcmFpc2UuaWQgPSBvcHRpb25zPy5pZDtcbiAgcmFpc2UuZGVsYXkgPSBvcHRpb25zPy5kZWxheTtcbiAgcmFpc2UucmVzb2x2ZSA9IHJlc29sdmVSYWlzZTtcbiAgcmFpc2UuZXhlY3V0ZSA9IGV4ZWN1dGVSYWlzZTtcbiAgcmV0dXJuIHJhaXNlO1xufVxuXG5leHBvcnQgeyAkJEFDVE9SX1RZUEUgYXMgJCwgY3JlYXRlQWN0b3IgYXMgQSwgQWN0b3IgYXMgQiwgaW50ZXJwcmV0IGFzIEMsIGFuZCBhcyBELCBub3QgYXMgRSwgb3IgYXMgRiwgc3RhdGVJbiBhcyBHLCBpc01hY2hpbmVTbmFwc2hvdCBhcyBILCBnZXRBbGxPd25FdmVudERlc2NyaXB0b3JzIGFzIEksIG1hdGNoZXNTdGF0ZSBhcyBKLCBwYXRoVG9TdGF0ZVZhbHVlIGFzIEssIHRvT2JzZXJ2ZXIgYXMgTCwgY2FuY2VsIGFzIE0sIE5VTExfRVZFTlQgYXMgTiwgcmFpc2UgYXMgTywgc3Bhd25DaGlsZCBhcyBQLCBzdG9wIGFzIFEsIHN0b3BDaGlsZCBhcyBSLCBTVEFURV9ERUxJTUlURVIgYXMgUywgUHJvY2Vzc2luZ1N0YXR1cyBhcyBULCBjbG9uZU1hY2hpbmVTbmFwc2hvdCBhcyBVLCBleGVjdXRpbmdDdXN0b21BY3Rpb24gYXMgViwgWFNUQVRFX0VSUk9SIGFzIFcsIFhTVEFURV9TVE9QIGFzIFgsIGNyZWF0ZUVycm9yQWN0b3JFdmVudCBhcyBZLCB0b1RyYW5zaXRpb25Db25maWdBcnJheSBhcyBhLCBmb3JtYXRUcmFuc2l0aW9uIGFzIGIsIGNyZWF0ZUludm9rZUlkIGFzIGMsIGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uIGFzIGQsIGV2YWx1YXRlR3VhcmQgYXMgZSwgZm9ybWF0VHJhbnNpdGlvbnMgYXMgZiwgZ2V0RGVsYXllZFRyYW5zaXRpb25zIGFzIGcsIGdldENhbmRpZGF0ZXMgYXMgaCwgZ2V0QWxsU3RhdGVOb2RlcyBhcyBpLCBnZXRTdGF0ZU5vZGVzIGFzIGosIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCBhcyBrLCBpc0luRmluYWxTdGF0ZSBhcyBsLCBtYXBWYWx1ZXMgYXMgbSwgbWFjcm9zdGVwIGFzIG4sIHRyYW5zaXRpb25Ob2RlIGFzIG8sIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dCBhcyBwLCBjcmVhdGVJbml0RXZlbnQgYXMgcSwgcmVzb2x2ZVN0YXRlVmFsdWUgYXMgciwgbWljcm9zdGVwIGFzIHMsIHRvQXJyYXkgYXMgdCwgZ2V0SW5pdGlhbFN0YXRlTm9kZXMgYXMgdSwgdG9TdGF0ZVBhdGggYXMgdiwgaXNTdGF0ZUlkIGFzIHcsIGdldFN0YXRlTm9kZUJ5UGF0aCBhcyB4LCBnZXRQZXJzaXN0ZWRTbmFwc2hvdCBhcyB5LCByZXNvbHZlUmVmZXJlbmNlZEFjdG9yIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJkZXZUb29sc0FkYXB0ZXIiLCJNYWlsYm94IiwiY29uc3RydWN0b3IiLCJfcHJvY2VzcyIsIl9hY3RpdmUiLCJfY3VycmVudCIsIl9sYXN0Iiwic3RhcnQiLCJmbHVzaCIsImNsZWFyIiwibmV4dCIsImVucXVldWUiLCJldmVudCIsImVucXVldWVkIiwidmFsdWUiLCJjb25zdW1lZCIsIlNUQVRFX0RFTElNSVRFUiIsIlRBUkdFVExFU1NfS0VZIiwiTlVMTF9FVkVOVCIsIlNUQVRFX0lERU5USUZJRVIiLCJXSUxEQ0FSRCIsIlhTVEFURV9JTklUIiwiWFNUQVRFX0VSUk9SIiwiWFNUQVRFX1NUT1AiLCJjcmVhdGVBZnRlckV2ZW50IiwiZGVsYXlSZWYiLCJpZCIsInR5cGUiLCJjcmVhdGVEb25lU3RhdGVFdmVudCIsIm91dHB1dCIsImNyZWF0ZURvbmVBY3RvckV2ZW50IiwiaW52b2tlSWQiLCJhY3RvcklkIiwiY3JlYXRlRXJyb3JBY3RvckV2ZW50IiwiZXJyb3IiLCJjcmVhdGVJbml0RXZlbnQiLCJpbnB1dCIsInJlcG9ydFVuaGFuZGxlZEVycm9yIiwiZXJyIiwic2V0VGltZW91dCIsInN5bWJvbE9ic2VydmFibGUiLCJTeW1ib2wiLCJvYnNlcnZhYmxlIiwibWF0Y2hlc1N0YXRlIiwicGFyZW50U3RhdGVJZCIsImNoaWxkU3RhdGVJZCIsInBhcmVudFN0YXRlVmFsdWUiLCJ0b1N0YXRlVmFsdWUiLCJjaGlsZFN0YXRlVmFsdWUiLCJPYmplY3QiLCJrZXlzIiwiZXZlcnkiLCJrZXkiLCJ0b1N0YXRlUGF0aCIsInN0YXRlSWQiLCJpc0FycmF5IiwicmVzdWx0Iiwic2VnbWVudCIsImkiLCJsZW5ndGgiLCJjaGFyIiwiY2hhckNvZGVBdCIsInB1c2giLCJzdGF0ZVZhbHVlIiwiaXNNYWNoaW5lU25hcHNob3QiLCJzdGF0ZVBhdGgiLCJwYXRoVG9TdGF0ZVZhbHVlIiwibWFya2VyIiwicHJldmlvdXMiLCJtYXBWYWx1ZXMiLCJjb2xsZWN0aW9uIiwiaXRlcmF0ZWUiLCJjb2xsZWN0aW9uS2V5cyIsInRvQXJyYXlTdHJpY3QiLCJ0b0FycmF5IiwidW5kZWZpbmVkIiwicmVzb2x2ZU91dHB1dCIsIm1hcHBlciIsImNvbnRleHQiLCJzZWxmIiwidmFsdWVzIiwic29tZSIsInZhbCIsImNvbnNvbGUiLCJ3YXJuIiwiZW50cmllcyIsImZpbHRlciIsIm1hcCIsInRvU3RyaW5nIiwicmVwbGFjZSIsImpvaW4iLCJBcnJheSIsImlzRXJyb3JBY3RvckV2ZW50Iiwic3RhcnRzV2l0aCIsInRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5IiwiY29uZmlnTGlrZSIsInRyYW5zaXRpb25MaWtlIiwidGFyZ2V0Iiwibm9ybWFsaXplVGFyZ2V0IiwidG9PYnNlcnZlciIsIm5leHRIYW5kbGVyIiwiZXJyb3JIYW5kbGVyIiwiY29tcGxldGlvbkhhbmRsZXIiLCJpc09ic2VydmVyIiwiYmluZCIsImNvbXBsZXRlIiwiY3JlYXRlSW52b2tlSWQiLCJzdGF0ZU5vZGVJZCIsImluZGV4IiwicmVzb2x2ZVJlZmVyZW5jZWRBY3RvciIsIm1hY2hpbmUiLCJzcmMiLCJtYXRjaCIsImltcGxlbWVudGF0aW9ucyIsImFjdG9ycyIsImluZGV4U3RyIiwibm9kZUlkIiwibm9kZSIsImdldFN0YXRlTm9kZUJ5SWQiLCJpbnZva2VDb25maWciLCJjb25maWciLCJpbnZva2UiLCJnZXRBbGxPd25FdmVudERlc2NyaXB0b3JzIiwic25hcHNob3QiLCJTZXQiLCJfbm9kZXMiLCJmbGF0TWFwIiwic24iLCJvd25FdmVudHMiLCJjcmVhdGVTY2hlZHVsZWRFdmVudElkIiwiYWN0b3JSZWYiLCJzZXNzaW9uSWQiLCJpZENvdW50ZXIiLCJjcmVhdGVTeXN0ZW0iLCJyb290QWN0b3IiLCJvcHRpb25zIiwiY2hpbGRyZW4iLCJNYXAiLCJrZXllZEFjdG9ycyIsInJldmVyc2VLZXllZEFjdG9ycyIsIldlYWtNYXAiLCJpbnNwZWN0aW9uT2JzZXJ2ZXJzIiwidGltZXJNYXAiLCJjbG9jayIsImxvZ2dlciIsInNjaGVkdWxlciIsInNjaGVkdWxlIiwic291cmNlIiwiZGVsYXkiLCJNYXRoIiwicmFuZG9tIiwic2xpY2UiLCJzY2hlZHVsZWRFdmVudCIsInN0YXJ0ZWRBdCIsIkRhdGUiLCJub3ciLCJzY2hlZHVsZWRFdmVudElkIiwic3lzdGVtIiwiX3NuYXBzaG90IiwiX3NjaGVkdWxlZEV2ZW50cyIsInRpbWVvdXQiLCJfcmVsYXkiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJjYW5jZWxBbGwiLCJzZW5kSW5zcGVjdGlvbkV2ZW50Iiwic2l6ZSIsInJlc29sdmVkSW5zcGVjdGlvbkV2ZW50Iiwicm9vdElkIiwiZm9yRWFjaCIsIm9ic2VydmVyIiwiX2Jvb2tJZCIsIl9yZWdpc3RlciIsInNldCIsIl91bnJlZ2lzdGVyIiwiZGVsZXRlIiwic3lzdGVtSWQiLCJnZXQiLCJfc2V0IiwiZXhpc3RpbmciLCJFcnJvciIsImluc3BlY3QiLCJvYnNlcnZlck9yRm4iLCJhZGQiLCJ1bnN1YnNjcmliZSIsIl9zZW5kSW5zcGVjdGlvbkV2ZW50Iiwic291cmNlUmVmIiwiX3NlbmQiLCJnZXRTbmFwc2hvdCIsInNjaGVkdWxlZEV2ZW50cyIsInNjaGVkdWxlZElkIiwiX2Nsb2NrIiwiX2xvZ2dlciIsImV4ZWN1dGluZ0N1c3RvbUFjdGlvbiIsIiQkQUNUT1JfVFlQRSIsIlByb2Nlc3NpbmdTdGF0dXMiLCJkZWZhdWx0T3B0aW9ucyIsImZuIiwibXMiLCJsb2ciLCJkZXZUb29scyIsIkFjdG9yIiwibG9naWMiLCJtYWlsYm94Iiwib2JzZXJ2ZXJzIiwiZXZlbnRMaXN0ZW5lcnMiLCJfcHJvY2Vzc2luZ1N0YXR1cyIsIk5vdFN0YXJ0ZWQiLCJfcGFyZW50IiwiX3N5bmNTbmFwc2hvdCIsInJlZiIsIl9hY3RvclNjb3BlIiwiX3N5c3RlbUlkIiwiX2RvbmVFdmVudCIsIl9kZWZlcnJlZCIsInJlc29sdmVkT3B0aW9ucyIsInBhcmVudCIsInN5bmNTbmFwc2hvdCIsImRlZmVyIiwic3RvcENoaWxkIiwiY2hpbGQiLCJfc3RvcCIsImVtaXQiLCJlbWl0dGVkRXZlbnQiLCJsaXN0ZW5lcnMiLCJ3aWxkY2FyZExpc3RlbmVyIiwiYWxsTGlzdGVuZXJzIiwiaGFuZGxlciIsImFjdGlvbkV4ZWN1dG9yIiwiYWN0aW9uIiwiZXhlYyIsInBhcmFtcyIsInNhdmVFeGVjdXRpbmdDdXN0b21BY3Rpb24iLCJpbmZvIiwiUnVubmluZyIsInNlbmQiLCJfaW5pdFN0YXRlIiwic3RhdGUiLCJzdGF0dXMiLCJwZXJzaXN0ZWRTdGF0ZSIsInJlc3RvcmVTbmFwc2hvdCIsImdldEluaXRpYWxTbmFwc2hvdCIsInVwZGF0ZSIsImRlZmVycmVkRm4iLCJzaGlmdCIsIl9zdG9wUHJvY2VkdXJlIiwiX2NvbXBsZXRlIiwiX2Vycm9yIiwic3Vic2NyaWJlIiwibmV4dExpc3RlbmVyT3JPYnNlcnZlciIsImVycm9yTGlzdGVuZXIiLCJjb21wbGV0ZUxpc3RlbmVyIiwiU3RvcHBlZCIsIm9uIiwid3JhcHBlZEhhbmRsZXIiLCJpbml0RXZlbnQiLCJhdHRhY2hEZXZUb29scyIsIm5leHRTdGF0ZSIsImNhdWdodEVycm9yIiwidHJhbnNpdGlvbiIsInN0b3AiLCJfcmVwb3J0RXJyb3IiLCJyZXBvcnRFcnJvciIsImVycjIiLCJldmVudFN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNvbHZlZERldlRvb2xzQWRhcHRlciIsInRvSlNPTiIsInhzdGF0ZSQkdHlwZSIsImdldFBlcnNpc3RlZFNuYXBzaG90IiwiY3JlYXRlQWN0b3IiLCJpbnRlcnByZXQiLCJyZXNvbHZlQ2FuY2VsIiwiXyIsImFjdGlvbkFyZ3MiLCJhY3Rpb25QYXJhbXMiLCJzZW5kSWQiLCJyZXNvbHZlZFNlbmRJZCIsImV4ZWN1dGVDYW5jZWwiLCJhY3RvclNjb3BlIiwiX2FyZ3MiLCJfcGFyYW1zIiwicmVzb2x2ZSIsImV4ZWN1dGUiLCJyZXNvbHZlU3Bhd24iLCJfYWN0aW9uUGFyYW1zIiwicmVzb2x2ZWRJZCIsInJlc29sdmVkSW5wdXQiLCJjbG9uZU1hY2hpbmVTbmFwc2hvdCIsImV4ZWN1dGVTcGF3biIsInNwYXduQ2hpbGQiLCJyZXNvbHZlU3RvcCIsImFyZ3MiLCJhY3RvclJlZk9yU3RyaW5nIiwicmVzb2x2ZWRBY3RvclJlZiIsImV4ZWN1dGVTdG9wIiwiY2hlY2tTdGF0ZUluIiwiaXNTdGF0ZUlkIiwibWF0Y2hlcyIsInN0YXRlSW4iLCJjaGVjayIsImNoZWNrTm90IiwiZ3VhcmRzIiwiZXZhbHVhdGVHdWFyZCIsIm5vdCIsImd1YXJkIiwiY2hlY2tBbmQiLCJhbmQiLCJjaGVja09yIiwib3IiLCJpc0lubGluZSIsInJlc29sdmVkIiwiZ3VhcmRBcmdzIiwiZ3VhcmRQYXJhbXMiLCJidWlsdGluR3VhcmQiLCJpc0F0b21pY1N0YXRlTm9kZSIsInN0YXRlTm9kZSIsImdldENoaWxkcmVuIiwic3RhdGVzIiwiZ2V0UHJvcGVyQW5jZXN0b3JzIiwidG9TdGF0ZU5vZGUiLCJhbmNlc3RvcnMiLCJtIiwiZ2V0QWxsU3RhdGVOb2RlcyIsInN0YXRlTm9kZXMiLCJub2RlU2V0IiwiYWRqTGlzdCIsImdldEFkakxpc3QiLCJzIiwiZ2V0SW5pdGlhbFN0YXRlTm9kZXNXaXRoVGhlaXJBbmNlc3RvcnMiLCJoYXMiLCJpbml0aWFsU3RhdGVzIiwiaW5pdGlhbFN0YXRlTm9kZSIsImdldFZhbHVlRnJvbUFkaiIsImJhc2VOb2RlIiwiY2hpbGRTdGF0ZU5vZGVzIiwiY2hpbGRTdGF0ZU5vZGUiLCJnZXRTdGF0ZVZhbHVlIiwicm9vdE5vZGUiLCJpc0luRmluYWxTdGF0ZSIsInN0YXRlTm9kZVNldCIsInN0ciIsImdldENhbmRpZGF0ZXMiLCJyZWNlaXZlZEV2ZW50VHlwZSIsImNhbmRpZGF0ZXMiLCJ0cmFuc2l0aW9ucyIsImV2ZW50RGVzY3JpcHRvciIsImVuZHNXaXRoIiwidGVzdCIsInBhcnRpYWxFdmVudFRva2VucyIsInNwbGl0IiwiZXZlbnRUb2tlbnMiLCJ0b2tlbkluZGV4IiwicGFydGlhbEV2ZW50VG9rZW4iLCJldmVudFRva2VuIiwiaXNMYXN0VG9rZW4iLCJzb3J0IiwiYSIsImIiLCJnZXREZWxheWVkVHJhbnNpdGlvbnMiLCJhZnRlckNvbmZpZyIsImFmdGVyIiwibXV0YXRlRW50cnlFeGl0IiwiYWZ0ZXJFdmVudCIsImV2ZW50VHlwZSIsImVudHJ5IiwicmFpc2UiLCJleGl0IiwiZGVsYXllZFRyYW5zaXRpb25zIiwiY29uZmlnVHJhbnNpdGlvbiIsInJlc29sdmVkVHJhbnNpdGlvbiIsInJlc29sdmVkRGVsYXkiLCJOdW1iZXIiLCJpc05hTiIsImRlbGF5ZWRUcmFuc2l0aW9uIiwiZm9ybWF0VHJhbnNpdGlvbiIsImRlc2NyaXB0b3IiLCJ0cmFuc2l0aW9uQ29uZmlnIiwibm9ybWFsaXplZFRhcmdldCIsInJlZW50ZXIiLCJyZXNvbHZlVGFyZ2V0IiwiY29uZCIsImFjdGlvbnMiLCJ0IiwiZm9ybWF0VHJhbnNpdGlvbnMiLCJ0cmFuc2l0aW9uc0NvbmZpZyIsIm9uRG9uZSIsImludm9rZURlZiIsIm9uRXJyb3IiLCJvblNuYXBzaG90IiwiZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24iLCJfdGFyZ2V0IiwicmVzb2x2ZWRUYXJnZXQiLCJ0YXJnZXRzIiwiaXNJbnRlcm5hbFRhcmdldCIsImdldFN0YXRlTm9kZUJ5UGF0aCIsInRhcmdldFN0YXRlTm9kZSIsIm1lc3NhZ2UiLCJyZXNvbHZlSGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uIiwiaW5pdGlhbCIsImlzSGlzdG9yeU5vZGUiLCJnZXRJbml0aWFsU3RhdGVOb2RlcyIsImluaXRpYWxTdGF0ZSIsImFuY2VzdG9yIiwiaXRlciIsImRlc2NTdGF0ZU5vZGUiLCJnZXRTdGF0ZU5vZGUiLCJzdGF0ZUtleSIsImFycmF5U3RhdGVQYXRoIiwiY3VycmVudFN0YXRlTm9kZSIsImdldFN0YXRlTm9kZXMiLCJjaGlsZFN0YXRlS2V5cyIsInN1YlN0YXRlS2V5IiwiQm9vbGVhbiIsInJvb3QiLCJjb25jYXQiLCJyZWR1Y2UiLCJhbGxTdWJTdGF0ZU5vZGVzIiwic3ViU3RhdGVOb2RlIiwic3ViU3RhdGVOb2RlcyIsInRyYW5zaXRpb25BdG9taWNOb2RlIiwidHJhbnNpdGlvbkNvbXBvdW5kTm9kZSIsInN1YlN0YXRlS2V5cyIsInRyYW5zaXRpb25Ob2RlIiwidHJhbnNpdGlvblBhcmFsbGVsTm9kZSIsImFsbElubmVyVHJhbnNpdGlvbnMiLCJzdWJTdGF0ZVZhbHVlIiwiaW5uZXJUcmFuc2l0aW9ucyIsImdldEhpc3RvcnlOb2RlcyIsImlzRGVzY2VuZGFudCIsInBhcmVudFN0YXRlTm9kZSIsImhhc0ludGVyc2VjdGlvbiIsInMxIiwiczIiLCJzZXQxIiwic2V0MiIsIml0ZW0iLCJyZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zIiwiZW5hYmxlZFRyYW5zaXRpb25zIiwiaGlzdG9yeVZhbHVlIiwiZmlsdGVyZWRUcmFuc2l0aW9ucyIsInQxIiwidDFQcmVlbXB0ZWQiLCJ0cmFuc2l0aW9uc1RvUmVtb3ZlIiwidDIiLCJjb21wdXRlRXhpdFNldCIsInQzIiwiZnJvbSIsImZpbmRMZWFzdENvbW1vbkFuY2VzdG9yIiwiaGVhZCIsInRhaWwiLCJnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXMiLCJ0YXJnZXROb2RlIiwiZ2V0VHJhbnNpdGlvbkRvbWFpbiIsInRhcmdldFN0YXRlcyIsImxjYSIsInN0YXRlc1RvRXhpdCIsImRvbWFpbiIsImFyZVN0YXRlTm9kZUNvbGxlY3Rpb25zRXF1YWwiLCJwcmV2U3RhdGVOb2RlcyIsIm5leHRTdGF0ZU5vZGVTZXQiLCJtaWNyb3N0ZXAiLCJjdXJyZW50U25hcHNob3QiLCJpc0luaXRpYWwiLCJpbnRlcm5hbFF1ZXVlIiwibXV0U3RhdGVOb2RlU2V0IiwiZXhpdFN0YXRlcyIsInJlc29sdmVBY3Rpb25zQW5kQ29udGV4dCIsImVudGVyU3RhdGVzIiwibmV4dFN0YXRlTm9kZXMiLCJvcmRlciIsImUiLCJnZXRNYWNoaW5lT3V0cHV0Iiwicm9vdENvbXBsZXRpb25Ob2RlIiwiZG9uZVN0YXRlRXZlbnQiLCJuZXh0U25hcHNob3QiLCJzdGF0ZXNUb0VudGVyIiwic3RhdGVzRm9yRGVmYXVsdEVudHJ5IiwiY29tcHV0ZUVudHJ5U2V0IiwiY29tcGxldGVkTm9kZXMiLCJzdGF0ZU5vZGVUb0VudGVyIiwiaW5pdGlhbEFjdGlvbnMiLCJhbmNlc3Rvck1hcmtlciIsImFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyIiwiYWRkQW5jZXN0b3JTdGF0ZXNUb0VudGVyIiwiaGlzdG9yeVN0YXRlTm9kZXMiLCJhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIiLCJoaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24iLCJyZWVudHJhbmN5RG9tYWluIiwiYW5jIiwiX2FjdGlvbkV4ZWN1dG9yIiwiY2hhbmdlZEhpc3RvcnkiLCJleGl0U3RhdGVOb2RlIiwiaGlzdG9yeU5vZGUiLCJwcmVkaWNhdGUiLCJoaXN0b3J5IiwiZGVmIiwiZ2V0QWN0aW9uIiwiYWN0aW9uVHlwZSIsInJlc29sdmVBbmRFeGVjdXRlQWN0aW9uc1dpdGhDb250ZXh0IiwiZXh0cmEiLCJyZXRyaWVzIiwiaW50ZXJtZWRpYXRlU25hcHNob3QiLCJyZXNvbHZlZEFjdGlvbiIsIm5hbWUiLCJidWlsdGluQWN0aW9uIiwiZGVmZXJyZWRBY3RvcklkcyIsInJldHJ5UmVzb2x2ZSIsIm1hY3Jvc3RlcCIsIm1pY3Jvc3RhdGVzIiwiYWRkTWljcm9zdGF0ZSIsIm1pY3Jvc3RhdGUiLCJfdHJhbnNpdGlvbnMiLCJzdG9wQ2hpbGRyZW4iLCJuZXh0RXZlbnQiLCJjdXJyZW50RXZlbnQiLCJpc0VyciIsInNlbGVjdFRyYW5zaXRpb25zIiwic2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMiLCJzZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyIsInByZXZpb3VzU3RhdGUiLCJnZXRUcmFuc2l0aW9uRGF0YSIsImVuYWJsZWRUcmFuc2l0aW9uU2V0IiwiYXRvbWljU3RhdGVzIiwibG9vcCIsImFsd2F5cyIsInJlc29sdmVTdGF0ZVZhbHVlIiwiYWxsU3RhdGVOb2RlcyIsIm1hY2hpbmVTbmFwc2hvdE1hdGNoZXMiLCJ0ZXN0VmFsdWUiLCJtYWNoaW5lU25hcHNob3RIYXNUYWciLCJoYXNUYWciLCJ0YWciLCJ0YWdzIiwibWFjaGluZVNuYXBzaG90Q2FuIiwiY2FuIiwidHJhbnNpdGlvbkRhdGEiLCJtYWNoaW5lU25hcHNob3RUb0pTT04iLCJub2RlcyIsImdldE1ldGEiLCJqc29uVmFsdWVzIiwibWFjaGluZVNuYXBzaG90R2V0TWV0YSIsImFjYyIsIm1ldGEiLCJjcmVhdGVNYWNoaW5lU25hcHNob3QiLCJzZXJpYWxpemVIaXN0b3J5VmFsdWUiLCJjaGlsZHJlbkpzb24iLCJwZXJzaXN0ZWQiLCJwZXJzaXN0Q29udGV4dCIsImNvbnRleHRQYXJ0IiwiY29weSIsInJlc29sdmVSYWlzZSIsImV2ZW50T3JFeHByIiwiZGVsYXlzTWFwIiwiZGVsYXlzIiwicmVzb2x2ZWRFdmVudCIsImNvbmZpZ0RlbGF5IiwiZXhlY3V0ZVJhaXNlIiwiJCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJUIiwiVSIsIlYiLCJXIiwiWCIsIlkiLCJjIiwiZCIsImYiLCJnIiwiaCIsImoiLCJrIiwibCIsIm4iLCJvIiwicCIsInEiLCJyIiwidSIsInYiLCJ3IiwieCIsInkiLCJ6Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/raise-59549771.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/xstate.development.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/xstate/dist/xstate.development.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Actor: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.B),\n/* harmony export */   SimulatedClock: () => (/* binding */ SimulatedClock),\n/* harmony export */   SpecialTargets: () => (/* reexport safe */ _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S),\n/* harmony export */   StateMachine: () => (/* binding */ StateMachine),\n/* harmony export */   StateNode: () => (/* binding */ StateNode),\n/* harmony export */   __unsafe_getAllOwnEventDescriptors: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.I),\n/* harmony export */   and: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.D),\n/* harmony export */   assertEvent: () => (/* binding */ assertEvent),\n/* harmony export */   assign: () => (/* reexport safe */ _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a),\n/* harmony export */   cancel: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.M),\n/* harmony export */   createActor: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A),\n/* harmony export */   createEmptyActor: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.createEmptyActor),\n/* harmony export */   createMachine: () => (/* binding */ createMachine),\n/* harmony export */   emit: () => (/* reexport safe */ _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.e),\n/* harmony export */   enqueueActions: () => (/* reexport safe */ _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.b),\n/* harmony export */   forwardTo: () => (/* reexport safe */ _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.f),\n/* harmony export */   fromCallback: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromCallback),\n/* harmony export */   fromEventObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromEventObservable),\n/* harmony export */   fromObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromObservable),\n/* harmony export */   fromPromise: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromPromise),\n/* harmony export */   fromTransition: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromTransition),\n/* harmony export */   getInitialSnapshot: () => (/* binding */ getInitialSnapshot),\n/* harmony export */   getNextSnapshot: () => (/* binding */ getNextSnapshot),\n/* harmony export */   getStateNodes: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j),\n/* harmony export */   initialTransition: () => (/* binding */ initialTransition),\n/* harmony export */   interpret: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.C),\n/* harmony export */   isMachineSnapshot: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.H),\n/* harmony export */   log: () => (/* reexport safe */ _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.l),\n/* harmony export */   matchesState: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.J),\n/* harmony export */   not: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.E),\n/* harmony export */   or: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.F),\n/* harmony export */   pathToStateValue: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.K),\n/* harmony export */   raise: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.O),\n/* harmony export */   sendParent: () => (/* reexport safe */ _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.s),\n/* harmony export */   sendTo: () => (/* reexport safe */ _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.c),\n/* harmony export */   setup: () => (/* binding */ setup),\n/* harmony export */   spawnChild: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.P),\n/* harmony export */   stateIn: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.G),\n/* harmony export */   stop: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.Q),\n/* harmony export */   stopChild: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.R),\n/* harmony export */   toObserver: () => (/* reexport safe */ _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.L),\n/* harmony export */   toPromise: () => (/* binding */ toPromise),\n/* harmony export */   transition: () => (/* binding */ transition),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actors/dist/xstate-actors.development.esm.js */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raise-59549771.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-59549771.development.esm.js\");\n/* harmony import */ var _log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./log-5a7b5528.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/log-5a7b5528.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n\n\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */ function assertEvent(event, type) {\n    const types = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(type);\n    if (!types.includes(event.type)) {\n        const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n        throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n    }\n}\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n    let memoizedData = cache.get(object);\n    if (!memoizedData) {\n        memoizedData = {\n            [key]: fn()\n        };\n        cache.set(object, memoizedData);\n    } else if (!(key in memoizedData)) {\n        memoizedData[key] = fn();\n    }\n    return memoizedData[key];\n}\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = (action)=>{\n    if (typeof action === \"string\") {\n        return {\n            type: action\n        };\n    }\n    if (typeof action === \"function\") {\n        if (\"resolve\" in action) {\n            return {\n                type: action.type\n            };\n        }\n        return {\n            type: action.name\n        };\n    }\n    return action;\n};\nclass StateNode {\n    constructor(/** The raw config used to create the machine. */ config, options){\n        this.config = config;\n        /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */ this.key = void 0;\n        /** The unique ID of the state node. */ this.id = void 0;\n        /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */ this.type = void 0;\n        /** The string path from the root machine node to this node. */ this.path = void 0;\n        /** The child state nodes. */ this.states = void 0;\n        /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */ this.history = void 0;\n        /** The action(s) to be executed upon entering the state node. */ this.entry = void 0;\n        /** The action(s) to be executed upon exiting the state node. */ this.exit = void 0;\n        /** The parent state node. */ this.parent = void 0;\n        /** The root machine node. */ this.machine = void 0;\n        /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */ this.meta = void 0;\n        /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */ this.output = void 0;\n        /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */ this.order = -1;\n        this.description = void 0;\n        this.tags = [];\n        this.transitions = void 0;\n        this.always = void 0;\n        this.parent = options._parent;\n        this.key = options._key;\n        this.machine = options._machine;\n        this.path = this.parent ? this.parent.path.concat(this.key) : [];\n        this.id = this.config.id || [\n            this.machine.id,\n            ...this.path\n        ].join(_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.S);\n        this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? \"compound\" : this.config.history ? \"history\" : \"atomic\");\n        this.description = this.config.description;\n        this.order = this.machine.idMap.size;\n        this.machine.idMap.set(this.id, this);\n        this.states = this.config.states ? (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.config.states, (stateConfig, key)=>{\n            const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key,\n                _machine: this.machine\n            });\n            return stateNode;\n        }) : EMPTY_OBJECT;\n        if (this.type === \"compound\" && !this.config.initial) {\n            throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n        }\n        // History config\n        this.history = this.config.history === true ? \"shallow\" : this.config.history || false;\n        this.entry = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.entry).slice();\n        this.exit = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.exit).slice();\n        this.meta = this.config.meta;\n        this.output = this.type === \"final\" || !this.parent ? this.config.output : undefined;\n        this.tags = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(config.tags).slice();\n    }\n    /** @internal */ _initialize() {\n        this.transitions = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(this);\n        if (this.config.always) {\n            this.always = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this.config.always).map((t)=>(0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.N, t));\n        }\n        Object.keys(this.states).forEach((key)=>{\n            this.states[key]._initialize();\n        });\n    }\n    /** The well-structured state node definition. */ get definition() {\n        return {\n            id: this.id,\n            key: this.key,\n            version: this.machine.version,\n            type: this.type,\n            initial: this.initial ? {\n                target: this.initial.target,\n                source: this,\n                actions: this.initial.actions.map(toSerializableAction),\n                eventType: null,\n                reenter: false,\n                toJSON: ()=>({\n                        target: this.initial.target.map((t)=>`#${t.id}`),\n                        source: `#${this.id}`,\n                        actions: this.initial.actions.map(toSerializableAction),\n                        eventType: null\n                    })\n            } : undefined,\n            history: this.history,\n            states: (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.states, (state)=>{\n                return state.definition;\n            }),\n            on: this.on,\n            transitions: [\n                ...this.transitions.values()\n            ].flat().map((t)=>({\n                    ...t,\n                    actions: t.actions.map(toSerializableAction)\n                })),\n            entry: this.entry.map(toSerializableAction),\n            exit: this.exit.map(toSerializableAction),\n            meta: this.meta,\n            order: this.order || -1,\n            output: this.output,\n            invoke: this.invoke,\n            description: this.description,\n            tags: this.tags\n        };\n    }\n    /** @internal */ toJSON() {\n        return this.definition;\n    }\n    /** The logic invoked as actors by this state node. */ get invoke() {\n        return memo(this, \"invoke\", ()=>(0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.invoke).map((invokeConfig, i)=>{\n                const { src, systemId } = invokeConfig;\n                const resolvedId = invokeConfig.id ?? (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id, i);\n                const sourceName = typeof src === \"string\" ? src : `xstate.invoke.${(0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id, i)}`;\n                return {\n                    ...invokeConfig,\n                    src: sourceName,\n                    id: resolvedId,\n                    systemId: systemId,\n                    toJSON () {\n                        const { onDone, onError, ...invokeDefValues } = invokeConfig;\n                        return {\n                            ...invokeDefValues,\n                            type: \"xstate.invoke\",\n                            src: sourceName,\n                            id: resolvedId\n                        };\n                    }\n                };\n            }));\n    }\n    /** The mapping of events to transitions. */ get on() {\n        return memo(this, \"on\", ()=>{\n            const transitions = this.transitions;\n            return [\n                ...transitions\n            ].flatMap(([descriptor, t])=>t.map((t)=>[\n                        descriptor,\n                        t\n                    ])).reduce((map, [descriptor, transition])=>{\n                map[descriptor] = map[descriptor] || [];\n                map[descriptor].push(transition);\n                return map;\n            }, {});\n        });\n    }\n    get after() {\n        return memo(this, \"delayedTransitions\", ()=>(0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(this));\n    }\n    get initial() {\n        return memo(this, \"initial\", ()=>(0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(this, this.config.initial));\n    }\n    /** @internal */ next(snapshot, event) {\n        const eventType = event.type;\n        const actions = [];\n        let selectedTransition;\n        const candidates = memo(this, `candidates-${eventType}`, ()=>(0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.h)(this, eventType));\n        for (const candidate of candidates){\n            const { guard } = candidate;\n            const resolvedContext = snapshot.context;\n            let guardPassed = false;\n            try {\n                guardPassed = !guard || (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.e)(guard, resolvedContext, event, snapshot);\n            } catch (err) {\n                const guardType = typeof guard === \"string\" ? guard : typeof guard === \"object\" ? guard.type : undefined;\n                throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : \"\"}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n            }\n            if (guardPassed) {\n                actions.push(...candidate.actions);\n                selectedTransition = candidate;\n                break;\n            }\n        }\n        return selectedTransition ? [\n            selectedTransition\n        ] : undefined;\n    }\n    /** All the event types accepted by this state node and its descendants. */ get events() {\n        return memo(this, \"events\", ()=>{\n            const { states } = this;\n            const events = new Set(this.ownEvents);\n            if (states) {\n                for (const stateId of Object.keys(states)){\n                    const state = states[stateId];\n                    if (state.states) {\n                        for (const event of state.events){\n                            events.add(`${event}`);\n                        }\n                    }\n                }\n            }\n            return Array.from(events);\n        });\n    }\n    /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */ get ownEvents() {\n        const events = new Set([\n            ...this.transitions.keys()\n        ].filter((descriptor)=>{\n            return this.transitions.get(descriptor).some((transition)=>!(!transition.target && !transition.actions.length && !transition.reenter));\n        }));\n        return Array.from(events);\n    }\n}\nconst STATE_IDENTIFIER = \"#\";\nclass StateMachine {\n    constructor(/** The raw config used to create the machine. */ config, implementations){\n        this.config = config;\n        /** The machine's own version. */ this.version = void 0;\n        this.schemas = void 0;\n        this.implementations = void 0;\n        /** @internal */ this.__xstatenode = true;\n        /** @internal */ this.idMap = new Map();\n        this.root = void 0;\n        this.id = void 0;\n        this.states = void 0;\n        this.events = void 0;\n        this.id = config.id || \"(machine)\";\n        this.implementations = {\n            actors: implementations?.actors ?? {},\n            actions: implementations?.actions ?? {},\n            delays: implementations?.delays ?? {},\n            guards: implementations?.guards ?? {}\n        };\n        this.version = this.config.version;\n        this.schemas = this.config.schemas;\n        this.transition = this.transition.bind(this);\n        this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n        this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n        this.restoreSnapshot = this.restoreSnapshot.bind(this);\n        this.start = this.start.bind(this);\n        this.root = new StateNode(config, {\n            _key: this.id,\n            _machine: this\n        });\n        this.root._initialize();\n        this.states = this.root.states; // TODO: remove!\n        this.events = this.root.events;\n        if (!(\"output\" in this.root) && Object.values(this.states).some((state)=>state.type === \"final\" && \"output\" in state)) {\n            console.warn(\"Missing `machine.output` declaration (top-level final state with output detected)\");\n        }\n    }\n    /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`)\n   *   to recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */ provide(implementations) {\n        const { actions, guards, actors, delays } = this.implementations;\n        return new StateMachine(this.config, {\n            actions: {\n                ...actions,\n                ...implementations.actions\n            },\n            guards: {\n                ...guards,\n                ...implementations.guards\n            },\n            actors: {\n                ...actors,\n                ...implementations.actors\n            },\n            delays: {\n                ...delays,\n                ...implementations.delays\n            }\n        });\n    }\n    resolveState(config) {\n        const resolvedStateValue = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r)(this.root, config.value);\n        const nodeSet = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root, resolvedStateValue));\n        return (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            _nodes: [\n                ...nodeSet\n            ],\n            context: config.context || {},\n            children: {},\n            status: (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.l)(nodeSet, this.root) ? \"done\" : config.status || \"active\",\n            output: config.output,\n            error: config.error,\n            historyValue: config.historyValue\n        }, this);\n    }\n    /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */ transition(snapshot, event, actorScope) {\n        return (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot, event, actorScope, []).snapshot;\n    }\n    /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */ microstep(snapshot, event, actorScope) {\n        return (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot, event, actorScope, []).microstates;\n    }\n    getTransitionData(snapshot, event) {\n        return (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.o)(this.root, snapshot.value, snapshot, event) || [];\n    }\n    /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */ getPreInitialState(actorScope, initEvent, internalQueue) {\n        const { context } = this.config;\n        const preInitial = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            context: typeof context !== \"function\" && context ? context : {},\n            _nodes: [\n                this.root\n            ],\n            children: {},\n            status: \"active\"\n        }, this);\n        if (typeof context === \"function\") {\n            const assignment = ({ spawn, event, self })=>context({\n                    spawn,\n                    input: event.input,\n                    self\n                });\n            return (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.p)(preInitial, initEvent, actorScope, [\n                (0,_log_5a7b5528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a)(assignment)\n            ], internalQueue, undefined);\n        }\n        return preInitial;\n    }\n    /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */ getInitialSnapshot(actorScope, input) {\n        const initEvent = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.q)(input); // TODO: fix;\n        const internalQueue = [];\n        const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n        const nextState = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s)([\n            {\n                target: [\n                    ...(0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.u)(this.root)\n                ],\n                source: this.root,\n                reenter: true,\n                actions: [],\n                eventType: null,\n                toJSON: null // TODO: fix\n            }\n        ], preInitialState, actorScope, initEvent, true, internalQueue);\n        const { snapshot: macroState } = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(nextState, initEvent, actorScope, internalQueue);\n        return macroState;\n    }\n    start(snapshot) {\n        Object.values(snapshot.children).forEach((child)=>{\n            if (child.getSnapshot().status === \"active\") {\n                child.start();\n            }\n        });\n    }\n    getStateNodeById(stateId) {\n        const fullPath = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(stateId);\n        const relativePath = fullPath.slice(1);\n        const resolvedStateId = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.w)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n        const stateNode = this.idMap.get(resolvedStateId);\n        if (!stateNode) {\n            throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n        }\n        return (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.x)(stateNode, relativePath);\n    }\n    get definition() {\n        return this.root.definition;\n    }\n    toJSON() {\n        return this.definition;\n    }\n    getPersistedSnapshot(snapshot, options) {\n        return (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.y)(snapshot, options);\n    }\n    restoreSnapshot(snapshot, _actorScope) {\n        const children = {};\n        const snapshotChildren = snapshot.children;\n        Object.keys(snapshotChildren).forEach((actorId)=>{\n            const actorData = snapshotChildren[actorId];\n            const childState = actorData.snapshot;\n            const src = actorData.src;\n            const logic = typeof src === \"string\" ? (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.z)(this, src) : src;\n            if (!logic) {\n                return;\n            }\n            const actorRef = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(logic, {\n                id: actorId,\n                parent: _actorScope.self,\n                syncSnapshot: actorData.syncSnapshot,\n                snapshot: childState,\n                src,\n                systemId: actorData.systemId\n            });\n            children[actorId] = actorRef;\n        });\n        function resolveHistoryReferencedState(root, referenced) {\n            if (referenced instanceof StateNode) {\n                return referenced;\n            }\n            try {\n                return root.machine.getStateNodeById(referenced.id);\n            } catch  {\n                {\n                    console.warn(`Could not resolve StateNode for id: ${referenced.id}`);\n                }\n            }\n        }\n        function reviveHistoryValue(root, historyValue) {\n            if (!historyValue || typeof historyValue !== \"object\") {\n                return {};\n            }\n            const revived = {};\n            for(const key in historyValue){\n                const arr = historyValue[key];\n                for (const item of arr){\n                    const resolved = resolveHistoryReferencedState(root, item);\n                    if (!resolved) {\n                        continue;\n                    }\n                    revived[key] ??= [];\n                    revived[key].push(resolved);\n                }\n            }\n            return revived;\n        }\n        const revivedHistoryValue = reviveHistoryValue(this.root, snapshot.historyValue);\n        const restoredSnapshot = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            ...snapshot,\n            children,\n            _nodes: Array.from((0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root, snapshot.value))),\n            historyValue: revivedHistoryValue\n        }, this);\n        const seen = new Set();\n        function reviveContext(contextPart, children) {\n            if (seen.has(contextPart)) {\n                return;\n            }\n            seen.add(contextPart);\n            for(const key in contextPart){\n                const value = contextPart[key];\n                if (value && typeof value === \"object\") {\n                    if (\"xstate$$type\" in value && value.xstate$$type === _raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.$) {\n                        contextPart[key] = children[value.id];\n                        continue;\n                    }\n                    reviveContext(value, children);\n                }\n            }\n        }\n        reviveContext(restoredSnapshot.context, children);\n        return restoredSnapshot;\n    }\n}\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */ function createMachine(config, implementations) {\n    return new StateMachine(config, implementations);\n}\n/** @internal */ function createInertActorScope(actorLogic) {\n    const self = (0,_raise_59549771_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(actorLogic);\n    const inertActorScope = {\n        self,\n        defer: ()=>{},\n        id: \"\",\n        logger: ()=>{},\n        sessionId: \"\",\n        stopChild: ()=>{},\n        system: self.system,\n        emit: ()=>{},\n        actionExecutor: ()=>{}\n    };\n    return inertActorScope;\n}\n/** @deprecated Use `initialTransition(…)` instead. */ function getInitialSnapshot(actorLogic, ...[input]) {\n    const actorScope = createInertActorScope(actorLogic);\n    return actorLogic.getInitialSnapshot(actorScope, input);\n}\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @deprecated Use `transition(…)` instead.\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */ function getNextSnapshot(actorLogic, snapshot, event) {\n    const inertActorScope = createInertActorScope(actorLogic);\n    inertActorScope.self._snapshot = snapshot;\n    return actorLogic.transition(snapshot, event, inertActorScope);\n}\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\nfunction setup({ schemas, actors, actions, guards, delays }) {\n    return {\n        createMachine: (config)=>createMachine({\n                ...config,\n                schemas\n            }, {\n                actors,\n                actions,\n                guards,\n                delays\n            })\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass SimulatedClock {\n    constructor(){\n        this.timeouts = new Map();\n        this._now = 0;\n        this._id = 0;\n        this._flushing = false;\n        this._flushingInvalidated = false;\n    }\n    now() {\n        return this._now;\n    }\n    getId() {\n        return this._id++;\n    }\n    setTimeout(fn, timeout) {\n        this._flushingInvalidated = this._flushing;\n        const id = this.getId();\n        this.timeouts.set(id, {\n            start: this.now(),\n            timeout,\n            fn\n        });\n        return id;\n    }\n    clearTimeout(id) {\n        this._flushingInvalidated = this._flushing;\n        this.timeouts.delete(id);\n    }\n    set(time) {\n        if (this._now > time) {\n            throw new Error(\"Unable to travel back in time\");\n        }\n        this._now = time;\n        this.flushTimeouts();\n    }\n    flushTimeouts() {\n        if (this._flushing) {\n            this._flushingInvalidated = true;\n            return;\n        }\n        this._flushing = true;\n        const sorted = [\n            ...this.timeouts\n        ].sort(([_idA, timeoutA], [_idB, timeoutB])=>{\n            const endA = timeoutA.start + timeoutA.timeout;\n            const endB = timeoutB.start + timeoutB.timeout;\n            return endB > endA ? -1 : 1;\n        });\n        for (const [id, timeout] of sorted){\n            if (this._flushingInvalidated) {\n                this._flushingInvalidated = false;\n                this._flushing = false;\n                this.flushTimeouts();\n                return;\n            }\n            if (this.now() - timeout.start >= timeout.timeout) {\n                this.timeouts.delete(id);\n                timeout.fn.call(null);\n            }\n        }\n        this._flushing = false;\n    }\n    increment(ms) {\n        this._now += ms;\n        this.flushTimeouts();\n    }\n}\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */ function toPromise(actor) {\n    return new Promise((resolve, reject)=>{\n        actor.subscribe({\n            complete: ()=>{\n                resolve(actor.getSnapshot().output);\n            },\n            error: reject\n        });\n    });\n}\n/**\n * Given actor `logic`, a `snapshot`, and an `event`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute.\n *\n * This is a pure function that does not execute `actions`.\n */ function transition(logic, snapshot, event) {\n    const executableActions = [];\n    const actorScope = createInertActorScope(logic);\n    actorScope.actionExecutor = (action)=>{\n        executableActions.push(action);\n    };\n    const nextSnapshot = logic.transition(snapshot, event, actorScope);\n    return [\n        nextSnapshot,\n        executableActions\n    ];\n}\n/**\n * Given actor `logic` and optional `input`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute from the initial transition (no\n * previous state).\n *\n * This is a pure function that does not execute `actions`.\n */ function initialTransition(logic, ...[input]) {\n    const executableActions = [];\n    const actorScope = createInertActorScope(logic);\n    actorScope.actionExecutor = (action)=>{\n        executableActions.push(action);\n    };\n    const nextSnapshot = logic.getInitialSnapshot(actorScope, input);\n    return [\n        nextSnapshot,\n        executableActions\n    ];\n}\nconst defaultWaitForOptions = {\n    timeout: Infinity // much more than 10 seconds\n};\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */ function waitFor(actorRef, predicate, options) {\n    const resolvedOptions = {\n        ...defaultWaitForOptions,\n        ...options\n    };\n    return new Promise((res, rej)=>{\n        const { signal } = resolvedOptions;\n        if (signal?.aborted) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            rej(signal.reason);\n            return;\n        }\n        let done = false;\n        if (resolvedOptions.timeout < 0) {\n            console.error(\"`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.\");\n        }\n        const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(()=>{\n            dispose();\n            rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n        }, resolvedOptions.timeout);\n        const dispose = ()=>{\n            clearTimeout(handle);\n            done = true;\n            sub?.unsubscribe();\n            if (abortListener) {\n                signal.removeEventListener(\"abort\", abortListener);\n            }\n        };\n        function checkEmitted(emitted) {\n            if (predicate(emitted)) {\n                dispose();\n                res(emitted);\n            }\n        }\n        /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */ let abortListener;\n        // eslint-disable-next-line prefer-const\n        let sub; // avoid TDZ when disposing synchronously\n        // See if the current snapshot already matches the predicate\n        checkEmitted(actorRef.getSnapshot());\n        if (done) {\n            return;\n        }\n        // only define the `abortListener` if the `signal` option is provided\n        if (signal) {\n            abortListener = ()=>{\n                dispose();\n                // XState does not \"own\" the signal, so we should reject with its reason (if any)\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                rej(signal.reason);\n            };\n            signal.addEventListener(\"abort\", abortListener);\n        }\n        sub = actorRef.subscribe({\n            next: checkEmitted,\n            error: (err)=>{\n                dispose();\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                rej(err);\n            },\n            complete: ()=>{\n                dispose();\n                rej(new Error(`Actor terminated without satisfying predicate`));\n            }\n        });\n        if (done) {\n            sub.unsubscribe();\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QveHN0YXRlLmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUs7QUFDNGlCO0FBQzVXO0FBQ25TO0FBQzZHO0FBQzFIO0FBRW5EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBUzBHLFlBQVlDLEtBQUssRUFBRUMsSUFBSTtJQUM5QixNQUFNQyxRQUFRdEcscUVBQU9BLENBQUNxRztJQUN0QixJQUFJLENBQUNDLE1BQU1DLFFBQVEsQ0FBQ0gsTUFBTUMsSUFBSSxHQUFHO1FBQy9CLE1BQU1HLFlBQVlGLE1BQU1HLE1BQU0sS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFSCxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFQSxNQUFNSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDcEcsTUFBTSxJQUFJQyxNQUFNLENBQUMsZUFBZSxFQUFFQyxLQUFLQyxTQUFTLENBQUNULE9BQU8sU0FBUyxFQUFFSSxVQUFVLENBQUM7SUFDaEY7QUFDRjtBQUVBLE1BQU1NLFFBQVEsSUFBSUM7QUFDbEIsU0FBU0MsS0FBS0MsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLEVBQUU7SUFDM0IsSUFBSUMsZUFBZU4sTUFBTU8sR0FBRyxDQUFDSjtJQUM3QixJQUFJLENBQUNHLGNBQWM7UUFDakJBLGVBQWU7WUFDYixDQUFDRixJQUFJLEVBQUVDO1FBQ1Q7UUFDQUwsTUFBTVEsR0FBRyxDQUFDTCxRQUFRRztJQUNwQixPQUFPLElBQUksQ0FBRUYsQ0FBQUEsT0FBT0UsWUFBVyxHQUFJO1FBQ2pDQSxZQUFZLENBQUNGLElBQUksR0FBR0M7SUFDdEI7SUFDQSxPQUFPQyxZQUFZLENBQUNGLElBQUk7QUFDMUI7QUFFQSxNQUFNSyxlQUFlLENBQUM7QUFDdEIsTUFBTUMsdUJB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QTJFO2dCQUMzRU4sSUFBSXJJO1lBQ047WUFDQTJILFVBQVU7Z0JBQ1JnQjtnQkFDQU4sSUFBSSxJQUFJNU4sTUFBTSxDQUFDLDZDQUE2QyxDQUFDO1lBQy9EO1FBQ0Y7UUFDQSxJQUFJZ08sTUFBTTtZQUNSRyxJQUFJQyxXQUFXO1FBQ2pCO0lBQ0Y7QUFDRjtBQUU4SyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsaXBsaTktcGFyYW5vcm1hbC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC94c3RhdGUuZGV2ZWxvcG1lbnQuZXNtLmpzPzRjZDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgY3JlYXRlRW1wdHlBY3RvciwgZnJvbUNhbGxiYWNrLCBmcm9tRXZlbnRPYnNlcnZhYmxlLCBmcm9tT2JzZXJ2YWJsZSwgZnJvbVByb21pc2UsIGZyb21UcmFuc2l0aW9uIH0gZnJvbSAnLi4vYWN0b3JzL2Rpc3QveHN0YXRlLWFjdG9ycy5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgdCBhcyB0b0FycmF5LCBTIGFzIFNUQVRFX0RFTElNSVRFUiwgbSBhcyBtYXBWYWx1ZXMsIGYgYXMgZm9ybWF0VHJhbnNpdGlvbnMsIGEgYXMgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXksIGIgYXMgZm9ybWF0VHJhbnNpdGlvbiwgTiBhcyBOVUxMX0VWRU5ULCBlIGFzIGV2YWx1YXRlR3VhcmQsIGMgYXMgY3JlYXRlSW52b2tlSWQsIGcgYXMgZ2V0RGVsYXllZFRyYW5zaXRpb25zLCBkIGFzIGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uLCBoIGFzIGdldENhbmRpZGF0ZXMsIHIgYXMgcmVzb2x2ZVN0YXRlVmFsdWUsIGkgYXMgZ2V0QWxsU3RhdGVOb2RlcywgaiBhcyBnZXRTdGF0ZU5vZGVzLCBrIGFzIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCwgbCBhcyBpc0luRmluYWxTdGF0ZSwgbiBhcyBtYWNyb3N0ZXAsIG8gYXMgdHJhbnNpdGlvbk5vZGUsIHAgYXMgcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0LCBxIGFzIGNyZWF0ZUluaXRFdmVudCwgcyBhcyBtaWNyb3N0ZXAsIHUgYXMgZ2V0SW5pdGlhbFN0YXRlTm9kZXMsIHYgYXMgdG9TdGF0ZVBhdGgsIHcgYXMgaXNTdGF0ZUlkLCB4IGFzIGdldFN0YXRlTm9kZUJ5UGF0aCwgeSBhcyBnZXRQZXJzaXN0ZWRTbmFwc2hvdCwgeiBhcyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yLCBBIGFzIGNyZWF0ZUFjdG9yLCAkIGFzICQkQUNUT1JfVFlQRSB9IGZyb20gJy4vcmFpc2UtNTk1NDk3NzEuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmV4cG9ydCB7IEIgYXMgQWN0b3IsIEkgYXMgX191bnNhZmVfZ2V0QWxsT3duRXZlbnREZXNjcmlwdG9ycywgRCBhcyBhbmQsIE0gYXMgY2FuY2VsLCBBIGFzIGNyZWF0ZUFjdG9yLCBqIGFzIGdldFN0YXRlTm9kZXMsIEMgYXMgaW50ZXJwcmV0LCBIIGFzIGlzTWFjaGluZVNuYXBzaG90LCBKIGFzIG1hdGNoZXNTdGF0ZSwgRSBhcyBub3QsIEYgYXMgb3IsIEsgYXMgcGF0aFRvU3RhdGVWYWx1ZSwgTyBhcyByYWlzZSwgUCBhcyBzcGF3bkNoaWxkLCBHIGFzIHN0YXRlSW4sIFEgYXMgc3RvcCwgUiBhcyBzdG9wQ2hpbGQsIEwgYXMgdG9PYnNlcnZlciB9IGZyb20gJy4vcmFpc2UtNTk1NDk3NzEuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCB7IGEgYXMgYXNzaWduIH0gZnJvbSAnLi9sb2ctNWE3YjU1MjguZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmV4cG9ydCB7IFMgYXMgU3BlY2lhbFRhcmdldHMsIGEgYXMgYXNzaWduLCBlIGFzIGVtaXQsIGIgYXMgZW5xdWV1ZUFjdGlvbnMsIGYgYXMgZm9yd2FyZFRvLCBsIGFzIGxvZywgcyBhcyBzZW5kUGFyZW50LCBjIGFzIHNlbmRUbyB9IGZyb20gJy4vbG9nLTVhN2I1NTI4LmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgJy4uL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGV2ZW50IG9iamVjdCBpcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb3IgdHlwZXMuIFRocm93c1xuICogYW4gZXJyb3IgaWYgdGhlIGV2ZW50IG9iamVjdCBpcyBub3Qgb2YgdGhlIHNwZWNpZmllZCB0eXBlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiAvLyAuLi5cbiAqIGVudHJ5OiAoeyBldmVudCB9KSA9PiB7XG4gKiAgIGFzc2VydEV2ZW50KGV2ZW50LCAnZG9Ob3RoaW5nJyk7XG4gKiAgIC8vIGV2ZW50IGlzIHsgdHlwZTogJ2RvTm90aGluZycgfVxuICogfSxcbiAqIC8vIC4uLlxuICogZXhpdDogKHsgZXZlbnQgfSkgPT4ge1xuICogICBhc3NlcnRFdmVudChldmVudCwgJ2dyZWV0Jyk7XG4gKiAgIC8vIGV2ZW50IGlzIHsgdHlwZTogJ2dyZWV0JzsgbWVzc2FnZTogc3RyaW5nIH1cbiAqXG4gKiAgIGFzc2VydEV2ZW50KGV2ZW50LCBbJ2dyZWV0JywgJ25vdGlmeSddKTtcbiAqICAgLy8gZXZlbnQgaXMgeyB0eXBlOiAnZ3JlZXQnOyBtZXNzYWdlOiBzdHJpbmcgfVxuICogICAvLyBvciB7IHR5cGU6ICdub3RpZnknOyBtZXNzYWdlOiBzdHJpbmc7IGxldmVsOiAnaW5mbycgfCAnZXJyb3InIH1cbiAqIH0sXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RXZlbnQoZXZlbnQsIHR5cGUpIHtcbiAgY29uc3QgdHlwZXMgPSB0b0FycmF5KHR5cGUpO1xuICBpZiAoIXR5cGVzLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XG4gICAgY29uc3QgdHlwZXNUZXh0ID0gdHlwZXMubGVuZ3RoID09PSAxID8gYHR5cGUgXCIke3R5cGVzWzBdfVwiYCA6IGBvbmUgb2YgdHlwZXMgXCIke3R5cGVzLmpvaW4oJ1wiLCBcIicpfVwiYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQpfSB0byBoYXZlICR7dHlwZXNUZXh0fWApO1xuICB9XG59XG5cbmNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG1lbW8ob2JqZWN0LCBrZXksIGZuKSB7XG4gIGxldCBtZW1vaXplZERhdGEgPSBjYWNoZS5nZXQob2JqZWN0KTtcbiAgaWYgKCFtZW1vaXplZERhdGEpIHtcbiAgICBtZW1vaXplZERhdGEgPSB7XG4gICAgICBba2V5XTogZm4oKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KG9iamVjdCwgbWVtb2l6ZWREYXRhKTtcbiAgfSBlbHNlIGlmICghKGtleSBpbiBtZW1vaXplZERhdGEpKSB7XG4gICAgbWVtb2l6ZWREYXRhW2tleV0gPSBmbigpO1xuICB9XG4gIHJldHVybiBtZW1vaXplZERhdGFba2V5XTtcbn1cblxuY29uc3QgRU1QVFlfT0JKRUNUID0ge307XG5jb25zdCB0b1NlcmlhbGl6YWJsZUFjdGlvbiA9IGFjdGlvbiA9PiB7XG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBhY3Rpb25cbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCdyZXNvbHZlJyBpbiBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGFjdGlvbi50eXBlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYWN0aW9uLm5hbWVcbiAgICB9O1xuICB9XG4gIHJldHVybiBhY3Rpb247XG59O1xuY2xhc3MgU3RhdGVOb2RlIHtcbiAgY29uc3RydWN0b3IoLyoqIFRoZSByYXcgY29uZmlnIHVzZWQgdG8gY3JlYXRlIHRoZSBtYWNoaW5lLiAqL1xuICBjb25maWcsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXRpdmUga2V5IG9mIHRoZSBzdGF0ZSBub2RlLCB3aGljaCByZXByZXNlbnRzIGl0cyBsb2NhdGlvbiBpbiB0aGVcbiAgICAgKiBvdmVyYWxsIHN0YXRlIHZhbHVlLlxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzdGF0ZSBub2RlLiAqL1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBzdGF0ZSBub2RlOlxuICAgICAqXG4gICAgICogLSBgJ2F0b21pYydgIC0gbm8gY2hpbGQgc3RhdGUgbm9kZXNcbiAgICAgKiAtIGAnY29tcG91bmQnYCAtIG5lc3RlZCBjaGlsZCBzdGF0ZSBub2RlcyAoWE9SKVxuICAgICAqIC0gYCdwYXJhbGxlbCdgIC0gb3J0aG9nb25hbCBuZXN0ZWQgY2hpbGQgc3RhdGUgbm9kZXMgKEFORClcbiAgICAgKiAtIGAnaGlzdG9yeSdgIC0gaGlzdG9yeSBzdGF0ZSBub2RlXG4gICAgICogLSBgJ2ZpbmFsJ2AgLSBmaW5hbCBzdGF0ZSBub2RlXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgc3RyaW5nIHBhdGggZnJvbSB0aGUgcm9vdCBtYWNoaW5lIG5vZGUgdG8gdGhpcyBub2RlLiAqL1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGNoaWxkIHN0YXRlIG5vZGVzLiAqL1xuICAgIHRoaXMuc3RhdGVzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGhpc3Rvcnkgb24gdGhpcyBzdGF0ZSBub2RlLiBDYW4gYmU6XG4gICAgICpcbiAgICAgKiAtIGAnc2hhbGxvdydgIC0gcmVjYWxscyBvbmx5IHRvcC1sZXZlbCBoaXN0b3JpY2FsIHN0YXRlIHZhbHVlXG4gICAgICogLSBgJ2RlZXAnYCAtIHJlY2FsbHMgaGlzdG9yaWNhbCBzdGF0ZSB2YWx1ZSBhdCBhbGwgbGV2ZWxzXG4gICAgICovXG4gICAgdGhpcy5oaXN0b3J5ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgYWN0aW9uKHMpIHRvIGJlIGV4ZWN1dGVkIHVwb24gZW50ZXJpbmcgdGhlIHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5lbnRyeSA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGFjdGlvbihzKSB0byBiZSBleGVjdXRlZCB1cG9uIGV4aXRpbmcgdGhlIHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5leGl0ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgcGFyZW50IHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSByb290IG1hY2hpbmUgbm9kZS4gKi9cbiAgICB0aGlzLm1hY2hpbmUgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGEgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZSBub2RlLCB3aGljaCB3aWxsIGJlIHJldHVybmVkIGluXG4gICAgICogU3RhdGUgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IGRhdGEgc2VudCB3aXRoIHRoZSBcInhzdGF0ZS5kb25lLnN0YXRlLl9pZF9cIiBldmVudCBpZiB0aGlzIGlzIGFcbiAgICAgKiBmaW5hbCBzdGF0ZSBub2RlLlxuICAgICAqL1xuICAgIHRoaXMub3V0cHV0ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGlzIHN0YXRlIG5vZGUgYXBwZWFycy4gQ29ycmVzcG9uZHMgdG8gdGhlIGltcGxpY2l0IGRvY3VtZW50XG4gICAgICogb3JkZXIuXG4gICAgICovXG4gICAgdGhpcy5vcmRlciA9IC0xO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy50YWdzID0gW107XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmFsd2F5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMuX3BhcmVudDtcbiAgICB0aGlzLmtleSA9IG9wdGlvbnMuX2tleTtcbiAgICB0aGlzLm1hY2hpbmUgPSBvcHRpb25zLl9tYWNoaW5lO1xuICAgIHRoaXMucGF0aCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucGF0aC5jb25jYXQodGhpcy5rZXkpIDogW107XG4gICAgdGhpcy5pZCA9IHRoaXMuY29uZmlnLmlkIHx8IFt0aGlzLm1hY2hpbmUuaWQsIC4uLnRoaXMucGF0aF0uam9pbihTVEFURV9ERUxJTUlURVIpO1xuICAgIHRoaXMudHlwZSA9IHRoaXMuY29uZmlnLnR5cGUgfHwgKHRoaXMuY29uZmlnLnN0YXRlcyAmJiBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZy5zdGF0ZXMpLmxlbmd0aCA/ICdjb21wb3VuZCcgOiB0aGlzLmNvbmZpZy5oaXN0b3J5ID8gJ2hpc3RvcnknIDogJ2F0b21pYycpO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLm9yZGVyID0gdGhpcy5tYWNoaW5lLmlkTWFwLnNpemU7XG4gICAgdGhpcy5tYWNoaW5lLmlkTWFwLnNldCh0aGlzLmlkLCB0aGlzKTtcbiAgICB0aGlzLnN0YXRlcyA9IHRoaXMuY29uZmlnLnN0YXRlcyA/IG1hcFZhbHVlcyh0aGlzLmNvbmZpZy5zdGF0ZXMsIChzdGF0ZUNvbmZpZywga2V5KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZU5vZGUgPSBuZXcgU3RhdGVOb2RlKHN0YXRlQ29uZmlnLCB7XG4gICAgICAgIF9wYXJlbnQ6IHRoaXMsXG4gICAgICAgIF9rZXk6IGtleSxcbiAgICAgICAgX21hY2hpbmU6IHRoaXMubWFjaGluZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RhdGVOb2RlO1xuICAgIH0pIDogRU1QVFlfT0JKRUNUO1xuICAgIGlmICh0aGlzLnR5cGUgPT09ICdjb21wb3VuZCcgJiYgIXRoaXMuY29uZmlnLmluaXRpYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5pdGlhbCBzdGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvdW5kIHN0YXRlIG5vZGUgXCIjJHt0aGlzLmlkfVwiLiBUcnkgYWRkaW5nIHsgaW5pdGlhbDogXCIke09iamVjdC5rZXlzKHRoaXMuc3RhdGVzKVswXX1cIiB9IHRvIHRoZSBzdGF0ZSBjb25maWcuYCk7XG4gICAgfVxuXG4gICAgLy8gSGlzdG9yeSBjb25maWdcbiAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmNvbmZpZy5oaXN0b3J5ID09PSB0cnVlID8gJ3NoYWxsb3cnIDogdGhpcy5jb25maWcuaGlzdG9yeSB8fCBmYWxzZTtcbiAgICB0aGlzLmVudHJ5ID0gdG9BcnJheSh0aGlzLmNvbmZpZy5lbnRyeSkuc2xpY2UoKTtcbiAgICB0aGlzLmV4aXQgPSB0b0FycmF5KHRoaXMuY29uZmlnLmV4aXQpLnNsaWNlKCk7XG4gICAgdGhpcy5tZXRhID0gdGhpcy5jb25maWcubWV0YTtcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMudHlwZSA9PT0gJ2ZpbmFsJyB8fCAhdGhpcy5wYXJlbnQgPyB0aGlzLmNvbmZpZy5vdXRwdXQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy50YWdzID0gdG9BcnJheShjb25maWcudGFncykuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IGZvcm1hdFRyYW5zaXRpb25zKHRoaXMpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5hbHdheXMpIHtcbiAgICAgIHRoaXMuYWx3YXlzID0gdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkodGhpcy5jb25maWcuYWx3YXlzKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHRoaXMsIE5VTExfRVZFTlQsIHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHRoaXMuc3RhdGVzW2tleV0uX2luaXRpYWxpemUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUaGUgd2VsbC1zdHJ1Y3R1cmVkIHN0YXRlIG5vZGUgZGVmaW5pdGlvbi4gKi9cbiAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgIHZlcnNpb246IHRoaXMubWFjaGluZS52ZXJzaW9uLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgaW5pdGlhbDogdGhpcy5pbml0aWFsID8ge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuaW5pdGlhbC50YXJnZXQsXG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgYWN0aW9uczogdGhpcy5pbml0aWFsLmFjdGlvbnMubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKSxcbiAgICAgICAgZXZlbnRUeXBlOiBudWxsLFxuICAgICAgICByZWVudGVyOiBmYWxzZSxcbiAgICAgICAgdG9KU09OOiAoKSA9PiAoe1xuICAgICAgICAgIHRhcmdldDogdGhpcy5pbml0aWFsLnRhcmdldC5tYXAodCA9PiBgIyR7dC5pZH1gKSxcbiAgICAgICAgICBzb3VyY2U6IGAjJHt0aGlzLmlkfWAsXG4gICAgICAgICAgYWN0aW9uczogdGhpcy5pbml0aWFsLmFjdGlvbnMubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKSxcbiAgICAgICAgICBldmVudFR5cGU6IG51bGxcbiAgICAgICAgfSlcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICBzdGF0ZXM6IG1hcFZhbHVlcyh0aGlzLnN0YXRlcywgc3RhdGUgPT4ge1xuICAgICAgICByZXR1cm4gc3RhdGUuZGVmaW5pdGlvbjtcbiAgICAgIH0pLFxuICAgICAgb246IHRoaXMub24sXG4gICAgICB0cmFuc2l0aW9uczogWy4uLnRoaXMudHJhbnNpdGlvbnMudmFsdWVzKCldLmZsYXQoKS5tYXAodCA9PiAoe1xuICAgICAgICAuLi50LFxuICAgICAgICBhY3Rpb25zOiB0LmFjdGlvbnMubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKVxuICAgICAgfSkpLFxuICAgICAgZW50cnk6IHRoaXMuZW50cnkubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKSxcbiAgICAgIGV4aXQ6IHRoaXMuZXhpdC5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgbWV0YTogdGhpcy5tZXRhLFxuICAgICAgb3JkZXI6IHRoaXMub3JkZXIgfHwgLTEsXG4gICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0LFxuICAgICAgaW52b2tlOiB0aGlzLmludm9rZSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgdGFnczogdGhpcy50YWdzXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb247XG4gIH1cblxuICAvKiogVGhlIGxvZ2ljIGludm9rZWQgYXMgYWN0b3JzIGJ5IHRoaXMgc3RhdGUgbm9kZS4gKi9cbiAgZ2V0IGludm9rZSgpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnaW52b2tlJywgKCkgPT4gdG9BcnJheSh0aGlzLmNvbmZpZy5pbnZva2UpLm1hcCgoaW52b2tlQ29uZmlnLCBpKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWRcbiAgICAgIH0gPSBpbnZva2VDb25maWc7XG4gICAgICBjb25zdCByZXNvbHZlZElkID0gaW52b2tlQ29uZmlnLmlkID8/IGNyZWF0ZUludm9rZUlkKHRoaXMuaWQsIGkpO1xuICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gc3JjIDogYHhzdGF0ZS5pbnZva2UuJHtjcmVhdGVJbnZva2VJZCh0aGlzLmlkLCBpKX1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW52b2tlQ29uZmlnLFxuICAgICAgICBzcmM6IHNvdXJjZU5hbWUsXG4gICAgICAgIGlkOiByZXNvbHZlZElkLFxuICAgICAgICBzeXN0ZW1JZDogc3lzdGVtSWQsXG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvbkRvbmUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgLi4uaW52b2tlRGVmVmFsdWVzXG4gICAgICAgICAgfSA9IGludm9rZUNvbmZpZztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaW52b2tlRGVmVmFsdWVzLFxuICAgICAgICAgICAgdHlwZTogJ3hzdGF0ZS5pbnZva2UnLFxuICAgICAgICAgICAgc3JjOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgaWQ6IHJlc29sdmVkSWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKiBUaGUgbWFwcGluZyBvZiBldmVudHMgdG8gdHJhbnNpdGlvbnMuICovXG4gIGdldCBvbigpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbnM7XG4gICAgICByZXR1cm4gWy4uLnRyYW5zaXRpb25zXS5mbGF0TWFwKChbZGVzY3JpcHRvciwgdF0pID0+IHQubWFwKHQgPT4gW2Rlc2NyaXB0b3IsIHRdKSkucmVkdWNlKChtYXAsIFtkZXNjcmlwdG9yLCB0cmFuc2l0aW9uXSkgPT4ge1xuICAgICAgICBtYXBbZGVzY3JpcHRvcl0gPSBtYXBbZGVzY3JpcHRvcl0gfHwgW107XG4gICAgICAgIG1hcFtkZXNjcmlwdG9yXS5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfSwge30pO1xuICAgIH0pO1xuICB9XG4gIGdldCBhZnRlcigpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnZGVsYXllZFRyYW5zaXRpb25zJywgKCkgPT4gZ2V0RGVsYXllZFRyYW5zaXRpb25zKHRoaXMpKTtcbiAgfVxuICBnZXQgaW5pdGlhbCgpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnaW5pdGlhbCcsICgpID0+IGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uKHRoaXMsIHRoaXMuY29uZmlnLmluaXRpYWwpKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgbmV4dChzbmFwc2hvdCwgZXZlbnQpIHtcbiAgICBjb25zdCBldmVudFR5cGUgPSBldmVudC50eXBlO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgICBsZXQgc2VsZWN0ZWRUcmFuc2l0aW9uO1xuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBtZW1vKHRoaXMsIGBjYW5kaWRhdGVzLSR7ZXZlbnRUeXBlfWAsICgpID0+IGdldENhbmRpZGF0ZXModGhpcywgZXZlbnRUeXBlKSk7XG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBndWFyZFxuICAgICAgfSA9IGNhbmRpZGF0ZTtcbiAgICAgIGNvbnN0IHJlc29sdmVkQ29udGV4dCA9IHNuYXBzaG90LmNvbnRleHQ7XG4gICAgICBsZXQgZ3VhcmRQYXNzZWQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGd1YXJkUGFzc2VkID0gIWd1YXJkIHx8IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIHJlc29sdmVkQ29udGV4dCwgZXZlbnQsIHNuYXBzaG90KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBndWFyZFR5cGUgPSB0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gZ3VhcmQgOiB0eXBlb2YgZ3VhcmQgPT09ICdvYmplY3QnID8gZ3VhcmQudHlwZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZXZhbHVhdGUgZ3VhcmQgJHtndWFyZFR5cGUgPyBgJyR7Z3VhcmRUeXBlfScgYCA6ICcnfWluIHRyYW5zaXRpb24gZm9yIGV2ZW50ICcke2V2ZW50VHlwZX0nIGluIHN0YXRlIG5vZGUgJyR7dGhpcy5pZH0nOlxcbiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmRQYXNzZWQpIHtcbiAgICAgICAgYWN0aW9ucy5wdXNoKC4uLmNhbmRpZGF0ZS5hY3Rpb25zKTtcbiAgICAgICAgc2VsZWN0ZWRUcmFuc2l0aW9uID0gY2FuZGlkYXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkVHJhbnNpdGlvbiA/IFtzZWxlY3RlZFRyYW5zaXRpb25dIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqIEFsbCB0aGUgZXZlbnQgdHlwZXMgYWNjZXB0ZWQgYnkgdGhpcyBzdGF0ZSBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMuICovXG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ2V2ZW50cycsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhdGVzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBTZXQodGhpcy5vd25FdmVudHMpO1xuICAgICAgaWYgKHN0YXRlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHN0YXRlSWQgb2YgT2JqZWN0LmtleXMoc3RhdGVzKSkge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzW3N0YXRlSWRdO1xuICAgICAgICAgIGlmIChzdGF0ZS5zdGF0ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygc3RhdGUuZXZlbnRzKSB7XG4gICAgICAgICAgICAgIGV2ZW50cy5hZGQoYCR7ZXZlbnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShldmVudHMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbCB0aGUgZXZlbnRzIHRoYXQgaGF2ZSB0cmFuc2l0aW9ucyBkaXJlY3RseSBmcm9tIHRoaXMgc3RhdGUgbm9kZS5cbiAgICpcbiAgICogRXhjbHVkZXMgYW55IGluZXJ0IGV2ZW50cy5cbiAgICovXG4gIGdldCBvd25FdmVudHMoKSB7XG4gICAgY29uc3QgZXZlbnRzID0gbmV3IFNldChbLi4udGhpcy50cmFuc2l0aW9ucy5rZXlzKCldLmZpbHRlcihkZXNjcmlwdG9yID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zLmdldChkZXNjcmlwdG9yKS5zb21lKHRyYW5zaXRpb24gPT4gISghdHJhbnNpdGlvbi50YXJnZXQgJiYgIXRyYW5zaXRpb24uYWN0aW9ucy5sZW5ndGggJiYgIXRyYW5zaXRpb24ucmVlbnRlcikpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShldmVudHMpO1xuICB9XG59XG5cbmNvbnN0IFNUQVRFX0lERU5USUZJRVIgPSAnIyc7XG5jbGFzcyBTdGF0ZU1hY2hpbmUge1xuICBjb25zdHJ1Y3RvcigvKiogVGhlIHJhdyBjb25maWcgdXNlZCB0byBjcmVhdGUgdGhlIG1hY2hpbmUuICovXG4gIGNvbmZpZywgaW1wbGVtZW50YXRpb25zKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgLyoqIFRoZSBtYWNoaW5lJ3Mgb3duIHZlcnNpb24uICovXG4gICAgdGhpcy52ZXJzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMuc2NoZW1hcyA9IHZvaWQgMDtcbiAgICB0aGlzLmltcGxlbWVudGF0aW9ucyA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fX3hzdGF0ZW5vZGUgPSB0cnVlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLmlkTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucm9vdCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuZXZlbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSBjb25maWcuaWQgfHwgJyhtYWNoaW5lKSc7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbnMgPSB7XG4gICAgICBhY3RvcnM6IGltcGxlbWVudGF0aW9ucz8uYWN0b3JzID8/IHt9LFxuICAgICAgYWN0aW9uczogaW1wbGVtZW50YXRpb25zPy5hY3Rpb25zID8/IHt9LFxuICAgICAgZGVsYXlzOiBpbXBsZW1lbnRhdGlvbnM/LmRlbGF5cyA/PyB7fSxcbiAgICAgIGd1YXJkczogaW1wbGVtZW50YXRpb25zPy5ndWFyZHMgPz8ge31cbiAgICB9O1xuICAgIHRoaXMudmVyc2lvbiA9IHRoaXMuY29uZmlnLnZlcnNpb247XG4gICAgdGhpcy5zY2hlbWFzID0gdGhpcy5jb25maWcuc2NoZW1hcztcbiAgICB0aGlzLnRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldEluaXRpYWxTbmFwc2hvdCA9IHRoaXMuZ2V0SW5pdGlhbFNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRQZXJzaXN0ZWRTbmFwc2hvdCA9IHRoaXMuZ2V0UGVyc2lzdGVkU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlc3RvcmVTbmFwc2hvdCA9IHRoaXMucmVzdG9yZVNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJvb3QgPSBuZXcgU3RhdGVOb2RlKGNvbmZpZywge1xuICAgICAgX2tleTogdGhpcy5pZCxcbiAgICAgIF9tYWNoaW5lOiB0aGlzXG4gICAgfSk7XG4gICAgdGhpcy5yb290Ll9pbml0aWFsaXplKCk7XG4gICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnJvb3Quc3RhdGVzOyAvLyBUT0RPOiByZW1vdmUhXG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLnJvb3QuZXZlbnRzO1xuICAgIGlmICghKCdvdXRwdXQnIGluIHRoaXMucm9vdCkgJiYgT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlcykuc29tZShzdGF0ZSA9PiBzdGF0ZS50eXBlID09PSAnZmluYWwnICYmICdvdXRwdXQnIGluIHN0YXRlKSkge1xuICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIGBtYWNoaW5lLm91dHB1dGAgZGVjbGFyYXRpb24gKHRvcC1sZXZlbCBmaW5hbCBzdGF0ZSB3aXRoIG91dHB1dCBkZXRlY3RlZCknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoaXMgc3RhdGUgbWFjaGluZSB3aXRoIHRoZSBwcm92aWRlZCBpbXBsZW1lbnRhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbXBsZW1lbnRhdGlvbnMgT3B0aW9ucyAoYGFjdGlvbnNgLCBgZ3VhcmRzYCwgYGFjdG9yc2AsIGBkZWxheXNgKVxuICAgKiAgIHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHdpdGggdGhlIGV4aXN0aW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIEEgbmV3IGBTdGF0ZU1hY2hpbmVgIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGltcGxlbWVudGF0aW9ucy5cbiAgICovXG4gIHByb3ZpZGUoaW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWN0aW9ucyxcbiAgICAgIGd1YXJkcyxcbiAgICAgIGFjdG9ycyxcbiAgICAgIGRlbGF5c1xuICAgIH0gPSB0aGlzLmltcGxlbWVudGF0aW9ucztcbiAgICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZSh0aGlzLmNvbmZpZywge1xuICAgICAgYWN0aW9uczoge1xuICAgICAgICAuLi5hY3Rpb25zLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuYWN0aW9uc1xuICAgICAgfSxcbiAgICAgIGd1YXJkczoge1xuICAgICAgICAuLi5ndWFyZHMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5ndWFyZHNcbiAgICAgIH0sXG4gICAgICBhY3RvcnM6IHtcbiAgICAgICAgLi4uYWN0b3JzLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuYWN0b3JzXG4gICAgICB9LFxuICAgICAgZGVsYXlzOiB7XG4gICAgICAgIC4uLmRlbGF5cyxcbiAgICAgICAgLi4uaW1wbGVtZW50YXRpb25zLmRlbGF5c1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc29sdmVTdGF0ZShjb25maWcpIHtcbiAgICBjb25zdCByZXNvbHZlZFN0YXRlVmFsdWUgPSByZXNvbHZlU3RhdGVWYWx1ZSh0aGlzLnJvb3QsIGNvbmZpZy52YWx1ZSk7XG4gICAgY29uc3Qgbm9kZVNldCA9IGdldEFsbFN0YXRlTm9kZXMoZ2V0U3RhdGVOb2Rlcyh0aGlzLnJvb3QsIHJlc29sdmVkU3RhdGVWYWx1ZSkpO1xuICAgIHJldHVybiBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgX25vZGVzOiBbLi4ubm9kZVNldF0sXG4gICAgICBjb250ZXh0OiBjb25maWcuY29udGV4dCB8fCB7fSxcbiAgICAgIGNoaWxkcmVuOiB7fSxcbiAgICAgIHN0YXR1czogaXNJbkZpbmFsU3RhdGUobm9kZVNldCwgdGhpcy5yb290KSA/ICdkb25lJyA6IGNvbmZpZy5zdGF0dXMgfHwgJ2FjdGl2ZScsXG4gICAgICBvdXRwdXQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgICBlcnJvcjogY29uZmlnLmVycm9yLFxuICAgICAgaGlzdG9yeVZhbHVlOiBjb25maWcuaGlzdG9yeVZhbHVlXG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzbmFwc2hvdCBnaXZlbiB0aGUgY3VycmVudCBgc25hcHNob3RgIGFuZCByZWNlaXZlZFxuICAgKiBgZXZlbnRgLiBDYWxjdWxhdGVzIGEgZnVsbCBtYWNyb3N0ZXAgZnJvbSBhbGwgbWljcm9zdGVwcy5cbiAgICpcbiAgICogQHBhcmFtIHNuYXBzaG90IFRoZSBjdXJyZW50IHNuYXBzaG90XG4gICAqIEBwYXJhbSBldmVudCBUaGUgcmVjZWl2ZWQgZXZlbnRcbiAgICovXG4gIHRyYW5zaXRpb24oc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIFtdKS5zbmFwc2hvdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBuZXh0IHN0YXRlIGdpdmVuIHRoZSBjdXJyZW50IGBzdGF0ZWAgYW5kIGBldmVudGAuIENhbGN1bGF0ZXNcbiAgICogYSBtaWNyb3N0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIHJlY2VpdmVkIGV2ZW50XG4gICAqL1xuICBtaWNyb3N0ZXAoc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIFtdKS5taWNyb3N0YXRlcztcbiAgfVxuICBnZXRUcmFuc2l0aW9uRGF0YShzbmFwc2hvdCwgZXZlbnQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk5vZGUodGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSwgc25hcHNob3QsIGV2ZW50KSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBzdGF0ZSBfYmVmb3JlXyBldmFsdWF0aW5nIGFueSBtaWNyb3N0ZXBzLiBUaGlzIFwicHJlLWluaXRpYWxcIlxuICAgKiBzdGF0ZSBpcyBwcm92aWRlZCB0byBpbml0aWFsIGFjdGlvbnMgZXhlY3V0ZWQgaW4gdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBnZXRQcmVJbml0aWFsU3RhdGUoYWN0b3JTY29wZSwgaW5pdEV2ZW50LCBpbnRlcm5hbFF1ZXVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBwcmVJbml0aWFsID0gY3JlYXRlTWFjaGluZVNuYXBzaG90KHtcbiAgICAgIGNvbnRleHQ6IHR5cGVvZiBjb250ZXh0ICE9PSAnZnVuY3Rpb24nICYmIGNvbnRleHQgPyBjb250ZXh0IDoge30sXG4gICAgICBfbm9kZXM6IFt0aGlzLnJvb3RdLFxuICAgICAgY2hpbGRyZW46IHt9LFxuICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgIH0sIHRoaXMpO1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgYXNzaWdubWVudCA9ICh7XG4gICAgICAgIHNwYXduLFxuICAgICAgICBldmVudCxcbiAgICAgICAgc2VsZlxuICAgICAgfSkgPT4gY29udGV4dCh7XG4gICAgICAgIHNwYXduLFxuICAgICAgICBpbnB1dDogZXZlbnQuaW5wdXQsXG4gICAgICAgIHNlbGZcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChwcmVJbml0aWFsLCBpbml0RXZlbnQsIGFjdG9yU2NvcGUsIFthc3NpZ24oYXNzaWdubWVudCldLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlSW5pdGlhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIGBTdGF0ZWAgaW5zdGFuY2UsIHdpdGggcmVmZXJlbmNlIHRvIGBzZWxmYCBhcyBhblxuICAgKiBgQWN0b3JSZWZgLlxuICAgKi9cbiAgZ2V0SW5pdGlhbFNuYXBzaG90KGFjdG9yU2NvcGUsIGlucHV0KSB7XG4gICAgY29uc3QgaW5pdEV2ZW50ID0gY3JlYXRlSW5pdEV2ZW50KGlucHV0KTsgLy8gVE9ETzogZml4O1xuICAgIGNvbnN0IGludGVybmFsUXVldWUgPSBbXTtcbiAgICBjb25zdCBwcmVJbml0aWFsU3RhdGUgPSB0aGlzLmdldFByZUluaXRpYWxTdGF0ZShhY3RvclNjb3BlLCBpbml0RXZlbnQsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IG1pY3Jvc3RlcChbe1xuICAgICAgdGFyZ2V0OiBbLi4uZ2V0SW5pdGlhbFN0YXRlTm9kZXModGhpcy5yb290KV0sXG4gICAgICBzb3VyY2U6IHRoaXMucm9vdCxcbiAgICAgIHJlZW50ZXI6IHRydWUsXG4gICAgICBhY3Rpb25zOiBbXSxcbiAgICAgIGV2ZW50VHlwZTogbnVsbCxcbiAgICAgIHRvSlNPTjogbnVsbCAvLyBUT0RPOiBmaXhcbiAgICB9XSwgcHJlSW5pdGlhbFN0YXRlLCBhY3RvclNjb3BlLCBpbml0RXZlbnQsIHRydWUsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNuYXBzaG90OiBtYWNyb1N0YXRlXG4gICAgfSA9IG1hY3Jvc3RlcChuZXh0U3RhdGUsIGluaXRFdmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgcmV0dXJuIG1hY3JvU3RhdGU7XG4gIH1cbiAgc3RhcnQoc25hcHNob3QpIHtcbiAgICBPYmplY3QudmFsdWVzKHNuYXBzaG90LmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmIChjaGlsZC5nZXRTbmFwc2hvdCgpLnN0YXR1cyA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgY2hpbGQuc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZU5vZGVCeUlkKHN0YXRlSWQpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlSWQpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGZ1bGxQYXRoLnNsaWNlKDEpO1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVJZCA9IGlzU3RhdGVJZChmdWxsUGF0aFswXSkgPyBmdWxsUGF0aFswXS5zbGljZShTVEFURV9JREVOVElGSUVSLmxlbmd0aCkgOiBmdWxsUGF0aFswXTtcbiAgICBjb25zdCBzdGF0ZU5vZGUgPSB0aGlzLmlkTWFwLmdldChyZXNvbHZlZFN0YXRlSWQpO1xuICAgIGlmICghc3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vZGUgJyMke3Jlc29sdmVkU3RhdGVJZH0nIGRvZXMgbm90IGV4aXN0IG9uIG1hY2hpbmUgJyR7dGhpcy5pZH0nYCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCByZWxhdGl2ZVBhdGgpO1xuICB9XG4gIGdldCBkZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QuZGVmaW5pdGlvbjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgfVxuICBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucyk7XG4gIH1cbiAgcmVzdG9yZVNuYXBzaG90KHNuYXBzaG90LCBfYWN0b3JTY29wZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0ge307XG4gICAgY29uc3Qgc25hcHNob3RDaGlsZHJlbiA9IHNuYXBzaG90LmNoaWxkcmVuO1xuICAgIE9iamVjdC5rZXlzKHNuYXBzaG90Q2hpbGRyZW4pLmZvckVhY2goYWN0b3JJZCA9PiB7XG4gICAgICBjb25zdCBhY3RvckRhdGEgPSBzbmFwc2hvdENoaWxkcmVuW2FjdG9ySWRdO1xuICAgICAgY29uc3QgY2hpbGRTdGF0ZSA9IGFjdG9yRGF0YS5zbmFwc2hvdDtcbiAgICAgIGNvbnN0IHNyYyA9IGFjdG9yRGF0YS5zcmM7XG4gICAgICBjb25zdCBsb2dpYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcmVzb2x2ZVJlZmVyZW5jZWRBY3Rvcih0aGlzLCBzcmMpIDogc3JjO1xuICAgICAgaWYgKCFsb2dpYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7XG4gICAgICAgIGlkOiBhY3RvcklkLFxuICAgICAgICBwYXJlbnQ6IF9hY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogYWN0b3JEYXRhLnN5bmNTbmFwc2hvdCxcbiAgICAgICAgc25hcHNob3Q6IGNoaWxkU3RhdGUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IGFjdG9yRGF0YS5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblthY3RvcklkXSA9IGFjdG9yUmVmO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVIaXN0b3J5UmVmZXJlbmNlZFN0YXRlKHJvb3QsIHJlZmVyZW5jZWQpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VkIGluc3RhbmNlb2YgU3RhdGVOb2RlKSB7XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VkO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJvb3QubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHJlZmVyZW5jZWQuaWQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCByZXNvbHZlIFN0YXRlTm9kZSBmb3IgaWQ6ICR7cmVmZXJlbmNlZC5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXZpdmVIaXN0b3J5VmFsdWUocm9vdCwgaGlzdG9yeVZhbHVlKSB7XG4gICAgICBpZiAoIWhpc3RvcnlWYWx1ZSB8fCB0eXBlb2YgaGlzdG9yeVZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCByZXZpdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBoaXN0b3J5VmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXJyID0gaGlzdG9yeVZhbHVlW2tleV07XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVIaXN0b3J5UmVmZXJlbmNlZFN0YXRlKHJvb3QsIGl0ZW0pO1xuICAgICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXZpdmVkW2tleV0gPz89IFtdO1xuICAgICAgICAgIHJldml2ZWRba2V5XS5wdXNoKHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldml2ZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJldml2ZWRIaXN0b3J5VmFsdWUgPSByZXZpdmVIaXN0b3J5VmFsdWUodGhpcy5yb290LCBzbmFwc2hvdC5oaXN0b3J5VmFsdWUpO1xuICAgIGNvbnN0IHJlc3RvcmVkU25hcHNob3QgPSBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIF9ub2RlczogQXJyYXkuZnJvbShnZXRBbGxTdGF0ZU5vZGVzKGdldFN0YXRlTm9kZXModGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSkpKSxcbiAgICAgIGhpc3RvcnlWYWx1ZTogcmV2aXZlZEhpc3RvcnlWYWx1ZVxuICAgIH0sIHRoaXMpO1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gcmV2aXZlQ29udGV4dChjb250ZXh0UGFydCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChzZWVuLmhhcyhjb250ZXh0UGFydCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vlbi5hZGQoY29udGV4dFBhcnQpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dFBhcnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0UGFydFtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICgneHN0YXRlJCR0eXBlJyBpbiB2YWx1ZSAmJiB2YWx1ZS54c3RhdGUkJHR5cGUgPT09ICQkQUNUT1JfVFlQRSkge1xuICAgICAgICAgICAgY29udGV4dFBhcnRba2V5XSA9IGNoaWxkcmVuW3ZhbHVlLmlkXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXZpdmVDb250ZXh0KHZhbHVlLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV2aXZlQ29udGV4dChyZXN0b3JlZFNuYXBzaG90LmNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICByZXR1cm4gcmVzdG9yZWRTbmFwc2hvdDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZSBtYWNoaW5lIChzdGF0ZWNoYXJ0KSB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoZSBzdGF0ZSBtYWNoaW5lIHJlcHJlc2VudHMgdGhlIHB1cmUgbG9naWMgb2YgYSBzdGF0ZSBtYWNoaW5lIGFjdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IGxpZ2h0TWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICBpZDogJ2xpZ2h0JyxcbiAqICAgaW5pdGlhbDogJ2dyZWVuJyxcbiAqICAgc3RhdGVzOiB7XG4gKiAgICAgZ3JlZW46IHtcbiAqICAgICAgIG9uOiB7XG4gKiAgICAgICAgIFRJTUVSOiB7IHRhcmdldDogJ3llbGxvdycgfVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgeWVsbG93OiB7XG4gKiAgICAgICBvbjoge1xuICogICAgICAgICBUSU1FUjogeyB0YXJnZXQ6ICdyZWQnIH1cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHJlZDoge1xuICogICAgICAgb246IHtcbiAqICAgICAgICAgVElNRVI6IHsgdGFyZ2V0OiAnZ3JlZW4nIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGxpZ2h0QWN0b3IgPSBjcmVhdGVBY3RvcihsaWdodE1hY2hpbmUpO1xuICogbGlnaHRBY3Rvci5zdGFydCgpO1xuICpcbiAqIGxpZ2h0QWN0b3Iuc2VuZCh7IHR5cGU6ICdUSU1FUicgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29uZmlnIFRoZSBzdGF0ZSBtYWNoaW5lIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0gb3B0aW9ucyBERVBSRUNBVEVEOiB1c2UgYHNldHVwKHsgLi4uIH0pYCBvciBgbWFjaGluZS5wcm92aWRlKHsgLi4uIH0pYFxuICogICB0byBwcm92aWRlIG1hY2hpbmUgaW1wbGVtZW50YXRpb25zIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hY2hpbmUoY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmUoY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYykge1xuICBjb25zdCBzZWxmID0gY3JlYXRlQWN0b3IoYWN0b3JMb2dpYyk7XG4gIGNvbnN0IGluZXJ0QWN0b3JTY29wZSA9IHtcbiAgICBzZWxmLFxuICAgIGRlZmVyOiAoKSA9PiB7fSxcbiAgICBpZDogJycsXG4gICAgbG9nZ2VyOiAoKSA9PiB7fSxcbiAgICBzZXNzaW9uSWQ6ICcnLFxuICAgIHN0b3BDaGlsZDogKCkgPT4ge30sXG4gICAgc3lzdGVtOiBzZWxmLnN5c3RlbSxcbiAgICBlbWl0OiAoKSA9PiB7fSxcbiAgICBhY3Rpb25FeGVjdXRvcjogKCkgPT4ge31cbiAgfTtcbiAgcmV0dXJuIGluZXJ0QWN0b3JTY29wZTtcbn1cblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgaW5pdGlhbFRyYW5zaXRpb24o4oCmKWAgaW5zdGVhZC4gKi9cbmZ1bmN0aW9uIGdldEluaXRpYWxTbmFwc2hvdChhY3RvckxvZ2ljLCAuLi5baW5wdXRdKSB7XG4gIGNvbnN0IGFjdG9yU2NvcGUgPSBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYyk7XG4gIHJldHVybiBhY3RvckxvZ2ljLmdldEluaXRpYWxTbmFwc2hvdChhY3RvclNjb3BlLCBpbnB1dCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIGBhY3RvckxvZ2ljYCBiYXNlZCBvbiB0aGUgZ2l2ZW5cbiAqIGBzbmFwc2hvdGAgYW5kIGBldmVudGAuXG4gKlxuICogSWYgdGhlIGBzbmFwc2hvdGAgaXMgYHVuZGVmaW5lZGAsIHRoZSBpbml0aWFsIHNuYXBzaG90IG9mIHRoZSBgYWN0b3JMb2dpY2AgaXNcbiAqIHVzZWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB0cmFuc2l0aW9uKOKApilgIGluc3RlYWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBnZXROZXh0U25hcHNob3QgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgdHJhZmZpY0xpZ2h0TWFjaGluZSB9IGZyb20gJy4vdHJhZmZpY0xpZ2h0TWFjaGluZS50cyc7XG4gKlxuICogY29uc3QgbmV4dFNuYXBzaG90ID0gZ2V0TmV4dFNuYXBzaG90KFxuICogICB0cmFmZmljTGlnaHRNYWNoaW5lLCAvLyBhY3RvciBsb2dpY1xuICogICB1bmRlZmluZWQsIC8vIHNuYXBzaG90IChvciBpbml0aWFsIHN0YXRlIGlmIHVuZGVmaW5lZClcbiAqICAgeyB0eXBlOiAnVElNRVInIH1cbiAqICk7IC8vIGV2ZW50IG9iamVjdFxuICpcbiAqIGNvbnNvbGUubG9nKG5leHRTbmFwc2hvdC52YWx1ZSk7XG4gKiAvLyA9PiAneWVsbG93J1xuICpcbiAqIGNvbnN0IG5leHRTbmFwc2hvdDIgPSBnZXROZXh0U25hcHNob3QoXG4gKiAgIHRyYWZmaWNMaWdodE1hY2hpbmUsIC8vIGFjdG9yIGxvZ2ljXG4gKiAgIG5leHRTbmFwc2hvdCwgLy8gc25hcHNob3RcbiAqICAgeyB0eXBlOiAnVElNRVInIH1cbiAqICk7IC8vIGV2ZW50IG9iamVjdFxuICpcbiAqIGNvbnNvbGUubG9nKG5leHRTbmFwc2hvdDIudmFsdWUpO1xuICogLy8gPT4ncmVkJ1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldE5leHRTbmFwc2hvdChhY3RvckxvZ2ljLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgY29uc3QgaW5lcnRBY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGFjdG9yTG9naWMpO1xuICBpbmVydEFjdG9yU2NvcGUuc2VsZi5fc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgcmV0dXJuIGFjdG9yTG9naWMudHJhbnNpdGlvbihzbmFwc2hvdCwgZXZlbnQsIGluZXJ0QWN0b3JTY29wZSk7XG59XG5cbi8vIGF0IHRoZSBtb21lbnQgd2UgYWxsb3cgZXh0cmEgYWN0b3JzIC0gb25lcyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIGJ5IGBjaGlsZHJlbmBcbi8vIHRoaXMgY291bGQgYmUgcmVjb25zaWRlcmVkIGluIHRoZSBmdXR1cmVcblxuZnVuY3Rpb24gc2V0dXAoe1xuICBzY2hlbWFzLFxuICBhY3RvcnMsXG4gIGFjdGlvbnMsXG4gIGd1YXJkcyxcbiAgZGVsYXlzXG59KSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlTWFjaGluZTogY29uZmlnID0+IGNyZWF0ZU1hY2hpbmUoe1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgc2NoZW1hc1xuICAgIH0sIHtcbiAgICAgIGFjdG9ycyxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBndWFyZHMsXG4gICAgICBkZWxheXNcbiAgICB9KVxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmNsYXNzIFNpbXVsYXRlZENsb2NrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50aW1lb3V0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub3cgPSAwO1xuICAgIHRoaXMuX2lkID0gMDtcbiAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdztcbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQrKztcbiAgfVxuICBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRoaXMuX2ZsdXNoaW5nO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZCgpO1xuICAgIHRoaXMudGltZW91dHMuc2V0KGlkLCB7XG4gICAgICBzdGFydDogdGhpcy5ub3coKSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBmblxuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBjbGVhclRpbWVvdXQoaWQpIHtcbiAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gdGhpcy5fZmx1c2hpbmc7XG4gICAgdGhpcy50aW1lb3V0cy5kZWxldGUoaWQpO1xuICB9XG4gIHNldCh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX25vdyA+IHRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHRyYXZlbCBiYWNrIGluIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5fbm93ID0gdGltZTtcbiAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgfVxuICBmbHVzaFRpbWVvdXRzKCkge1xuICAgIGlmICh0aGlzLl9mbHVzaGluZykge1xuICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZsdXNoaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4udGhpcy50aW1lb3V0c10uc29ydCgoW19pZEEsIHRpbWVvdXRBXSwgW19pZEIsIHRpbWVvdXRCXSkgPT4ge1xuICAgICAgY29uc3QgZW5kQSA9IHRpbWVvdXRBLnN0YXJ0ICsgdGltZW91dEEudGltZW91dDtcbiAgICAgIGNvbnN0IGVuZEIgPSB0aW1lb3V0Qi5zdGFydCArIHRpbWVvdXRCLnRpbWVvdXQ7XG4gICAgICByZXR1cm4gZW5kQiA+IGVuZEEgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbaWQsIHRpbWVvdXRdIG9mIHNvcnRlZCkge1xuICAgICAgaWYgKHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm93KCkgLSB0aW1lb3V0LnN0YXJ0ID49IHRpbWVvdXQudGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIHRpbWVvdXQuZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmx1c2hpbmcgPSBmYWxzZTtcbiAgfVxuICBpbmNyZW1lbnQobXMpIHtcbiAgICB0aGlzLl9ub3cgKz0gbXM7XG4gICAgdGhpcy5mbHVzaFRpbWVvdXRzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBgb3V0cHV0YCBvZiB0aGUgYWN0b3Igd2hlbiBpdCBpcyBkb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IG1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgLy8gLi4uXG4gKiAgIG91dHB1dDoge1xuICogICAgIGNvdW50OiA0MlxuICogICB9XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpO1xuICpcbiAqIGFjdG9yLnN0YXJ0KCk7XG4gKlxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgdG9Qcm9taXNlKGFjdG9yKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICogLy8gbG9ncyB7IGNvdW50OiA0MiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdG9Qcm9taXNlKGFjdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYWN0b3Iuc3Vic2NyaWJlKHtcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoYWN0b3IuZ2V0U25hcHNob3QoKS5vdXRwdXQpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiByZWplY3RcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYWN0b3IgYGxvZ2ljYCwgYSBgc25hcHNob3RgLCBhbmQgYW4gYGV2ZW50YCwgcmV0dXJucyBhIHR1cGxlIG9mIHRoZVxuICogYG5leHRTbmFwc2hvdGAgYW5kIGBhY3Rpb25zYCB0byBleGVjdXRlLlxuICpcbiAqIFRoaXMgaXMgYSBwdXJlIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgZXhlY3V0ZSBgYWN0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zaXRpb24obG9naWMsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBleGVjdXRhYmxlQWN0aW9ucyA9IFtdO1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGxvZ2ljKTtcbiAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvciA9IGFjdGlvbiA9PiB7XG4gICAgZXhlY3V0YWJsZUFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBjb25zdCBuZXh0U25hcHNob3QgPSBsb2dpYy50cmFuc2l0aW9uKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSk7XG4gIHJldHVybiBbbmV4dFNuYXBzaG90LCBleGVjdXRhYmxlQWN0aW9uc107XG59XG5cbi8qKlxuICogR2l2ZW4gYWN0b3IgYGxvZ2ljYCBhbmQgb3B0aW9uYWwgYGlucHV0YCwgcmV0dXJucyBhIHR1cGxlIG9mIHRoZVxuICogYG5leHRTbmFwc2hvdGAgYW5kIGBhY3Rpb25zYCB0byBleGVjdXRlIGZyb20gdGhlIGluaXRpYWwgdHJhbnNpdGlvbiAobm9cbiAqIHByZXZpb3VzIHN0YXRlKS5cbiAqXG4gKiBUaGlzIGlzIGEgcHVyZSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IGV4ZWN1dGUgYGFjdGlvbnNgLlxuICovXG5mdW5jdGlvbiBpbml0aWFsVHJhbnNpdGlvbihsb2dpYywgLi4uW2lucHV0XSkge1xuICBjb25zdCBleGVjdXRhYmxlQWN0aW9ucyA9IFtdO1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGxvZ2ljKTtcbiAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvciA9IGFjdGlvbiA9PiB7XG4gICAgZXhlY3V0YWJsZUFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBjb25zdCBuZXh0U25hcHNob3QgPSBsb2dpYy5nZXRJbml0aWFsU25hcHNob3QoYWN0b3JTY29wZSwgaW5wdXQpO1xuICByZXR1cm4gW25leHRTbmFwc2hvdCwgZXhlY3V0YWJsZUFjdGlvbnNdO1xufVxuXG5jb25zdCBkZWZhdWx0V2FpdEZvck9wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IEluZmluaXR5IC8vIG11Y2ggbW9yZSB0aGFuIDEwIHNlY29uZHNcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyB0byBhbiBhY3RvciByZWYgYW5kIHdhaXRzIGZvciBpdHMgZW1pdHRlZCB2YWx1ZSB0byBzYXRpc2Z5IGFcbiAqIHByZWRpY2F0ZSwgYW5kIHRoZW4gcmVzb2x2ZXMgd2l0aCB0aGF0IHZhbHVlLiBXaWxsIHRocm93IGlmIHRoZSBkZXNpcmVkIHN0YXRlXG4gKiBpcyBub3QgcmVhY2hlZCBhZnRlciBhbiBvcHRpb25hbCB0aW1lb3V0LiAoZGVmYXVsdHMgdG8gSW5maW5pdHkpLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHN0YXRlID0gYXdhaXQgd2FpdEZvcihzb21lU2VydmljZSwgKHN0YXRlKSA9PiB7XG4gKiAgIHJldHVybiBzdGF0ZS5oYXNUYWcoJ2xvYWRlZCcpO1xuICogfSk7XG4gKlxuICogc3RhdGUuaGFzVGFnKCdsb2FkZWQnKTsgLy8gdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjdG9yUmVmIFRoZSBhY3RvciByZWYgdG8gc3Vic2NyaWJlIHRvXG4gKiBAcGFyYW0gcHJlZGljYXRlIERldGVybWluZXMgaWYgYSB2YWx1ZSBtYXRjaGVzIHRoZSBjb25kaXRpb24gdG8gd2FpdCBmb3JcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBldmVudHVhbGx5IHJlc29sdmVzIHRvIHRoZSBlbWl0dGVkIHZhbHVlIHRoYXQgbWF0Y2hlc1xuICogICB0aGUgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIHdhaXRGb3IoYWN0b3JSZWYsIHByZWRpY2F0ZSwgb3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdFdhaXRGb3JPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgaWYgKHJlc29sdmVkT3B0aW9ucy50aW1lb3V0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignYHRpbWVvdXRgIHBhc3NlZCB0byBgd2FpdEZvcmAgaXMgbmVnYXRpdmUgYW5kIGl0IHdpbGwgcmVqZWN0IGl0cyBpbnRlcm5hbCBwcm9taXNlIGltbWVkaWF0ZWx5LicpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSByZXNvbHZlZE9wdGlvbnMudGltZW91dCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICAgIHJlaihuZXcgRXJyb3IoYFRpbWVvdXQgb2YgJHtyZXNvbHZlZE9wdGlvbnMudGltZW91dH0gbXMgZXhjZWVkZWRgKSk7XG4gICAgfSwgcmVzb2x2ZWRPcHRpb25zLnRpbWVvdXQpO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgc3ViPy51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKGFib3J0TGlzdGVuZXIpIHtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja0VtaXR0ZWQoZW1pdHRlZCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbWl0dGVkKSkge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIHJlcyhlbWl0dGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYHNpZ25hbGAgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgdGhlIGxpc3RlbmVyIGZvciBpdHNcbiAgICAgKiBgYWJvcnRgIGV2ZW50XG4gICAgICovXG4gICAgbGV0IGFib3J0TGlzdGVuZXI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCBzdWI7IC8vIGF2b2lkIFREWiB3aGVuIGRpc3Bvc2luZyBzeW5jaHJvbm91c2x5XG5cbiAgICAvLyBTZWUgaWYgdGhlIGN1cnJlbnQgc25hcHNob3QgYWxyZWFkeSBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAgICBjaGVja0VtaXR0ZWQoYWN0b3JSZWYuZ2V0U25hcHNob3QoKSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGRlZmluZSB0aGUgYGFib3J0TGlzdGVuZXJgIGlmIHRoZSBgc2lnbmFsYCBvcHRpb24gaXMgcHJvdmlkZWRcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBhYm9ydExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIC8vIFhTdGF0ZSBkb2VzIG5vdCBcIm93blwiIHRoZSBzaWduYWwsIHNvIHdlIHNob3VsZCByZWplY3Qgd2l0aCBpdHMgcmVhc29uIChpZiBhbnkpXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXByb21pc2UtcmVqZWN0LWVycm9yc1xuICAgICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICB9O1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgfVxuICAgIHN1YiA9IGFjdG9yUmVmLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiBjaGVja0VtaXR0ZWQsXG4gICAgICBlcnJvcjogZXJyID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcbiAgICAgICAgcmVqKGVycik7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICByZWoobmV3IEVycm9yKGBBY3RvciB0ZXJtaW5hdGVkIHdpdGhvdXQgc2F0aXNmeWluZyBwcmVkaWNhdGVgKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFNpbXVsYXRlZENsb2NrLCBTdGF0ZU1hY2hpbmUsIFN0YXRlTm9kZSwgYXNzZXJ0RXZlbnQsIGNyZWF0ZU1hY2hpbmUsIGdldEluaXRpYWxTbmFwc2hvdCwgZ2V0TmV4dFNuYXBzaG90LCBpbml0aWFsVHJhbnNpdGlvbiwgc2V0dXAsIHRvUHJvbWlzZSwgdHJhbnNpdGlvbiwgd2FpdEZvciB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUVtcHR5QWN0b3IiLCJmcm9tQ2FsbGJhY2siLCJmcm9tRXZlbnRPYnNlcnZhYmxlIiwiZnJvbU9ic2VydmFibGUiLCJmcm9tUHJvbWlzZSIsImZyb21UcmFuc2l0aW9uIiwidCIsInRvQXJyYXkiLCJTIiwiU1RBVEVfREVMSU1JVEVSIiwibSIsIm1hcFZhbHVlcyIsImYiLCJmb3JtYXRUcmFuc2l0aW9ucyIsImEiLCJ0b1RyYW5zaXRpb25Db25maWdBcnJheSIsImIiLCJmb3JtYXRUcmFuc2l0aW9uIiwiTiIsIk5VTExfRVZFTlQiLCJlIiwiZXZhbHVhdGVHdWFyZCIsImMiLCJjcmVhdGVJbnZva2VJZCIsImciLCJnZXREZWxheWVkVHJhbnNpdGlvbnMiLCJkIiwiZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24iLCJoIiwiZ2V0Q2FuZGlkYXRlcyIsInIiLCJyZXNvbHZlU3RhdGVWYWx1ZSIsImkiLCJnZXRBbGxTdGF0ZU5vZGVzIiwiaiIsImdldFN0YXRlTm9kZXMiLCJrIiwiY3JlYXRlTWFjaGluZVNuYXBzaG90IiwibCIsImlzSW5GaW5hbFN0YXRlIiwibiIsIm1hY3Jvc3RlcCIsIm8iLCJ0cmFuc2l0aW9uTm9kZSIsInAiLCJyZXNvbHZlQWN0aW9uc0FuZENvbnRleHQiLCJxIiwiY3JlYXRlSW5pdEV2ZW50IiwicyIsIm1pY3Jvc3RlcCIsInUiLCJnZXRJbml0aWFsU3RhdGVOb2RlcyIsInYiLCJ0b1N0YXRlUGF0aCIsInciLCJpc1N0YXRlSWQiLCJ4IiwiZ2V0U3RhdGVOb2RlQnlQYXRoIiwieSIsImdldFBlcnNpc3RlZFNuYXBzaG90IiwieiIsInJlc29sdmVSZWZlcmVuY2VkQWN0b3IiLCJBIiwiY3JlYXRlQWN0b3IiLCIkIiwiJCRBQ1RPUl9UWVBFIiwiQiIsIkFjdG9yIiwiSSIsIl9fdW5zYWZlX2dldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMiLCJEIiwiYW5kIiwiTSIsImNhbmNlbCIsIkMiLCJpbnRlcnByZXQiLCJIIiwiaXNNYWNoaW5lU25hcHNob3QiLCJKIiwibWF0Y2hlc1N0YXRlIiwiRSIsIm5vdCIsIkYiLCJvciIsIksiLCJwYXRoVG9TdGF0ZVZhbHVlIiwiTyIsInJhaXNlIiwiUCIsInNwYXduQ2hpbGQiLCJHIiwic3RhdGVJbiIsIlEiLCJzdG9wIiwiUiIsInN0b3BDaGlsZCIsIkwiLCJ0b09ic2VydmVyIiwiYXNzaWduIiwiU3BlY2lhbFRhcmdldHMiLCJlbWl0IiwiZW5xdWV1ZUFjdGlvbnMiLCJmb3J3YXJkVG8iLCJsb2ciLCJzZW5kUGFyZW50Iiwic2VuZFRvIiwiYXNzZXJ0RXZlbnQiLCJldmVudCIsInR5cGUiLCJ0eXBlcyIsImluY2x1ZGVzIiwidHlwZXNUZXh0IiwibGVuZ3RoIiwiam9pbiIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImNhY2hlIiwiV2Vha01hcCIsIm1lbW8iLCJvYmplY3QiLCJrZXkiLCJmbiIsIm1lbW9pemVkRGF0YSIsImdldCIsInNldCIsIkVNUFRZX09CSkVDVCIsInRvU2VyaWFsaXphYmxlQWN0aW9uIiwiYWN0aW9uIiwibmFtZSIsIlN0YXRlTm9kZSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwib3B0aW9ucyIsImlkIiwicGF0aCIsInN0YXRlcyIsImhpc3RvcnkiLCJlbnRyeSIsImV4aXQiLCJwYXJlbnQiLCJtYWNoaW5lIiwibWV0YSIsIm91dHB1dCIsIm9yZGVyIiwiZGVzY3JpcHRpb24iLCJ0YWdzIiwidHJhbnNpdGlvbnMiLCJhbHdheXMiLCJfcGFyZW50IiwiX2tleSIsIl9tYWNoaW5lIiwiY29uY2F0IiwiT2JqZWN0Iiwia2V5cyIsImlkTWFwIiwic2l6ZSIsInN0YXRlQ29uZmlnIiwic3RhdGVOb2RlIiwiaW5pdGlhbCIsInNsaWNlIiwidW5kZWZpbmVkIiwiX2luaXRpYWxpemUiLCJtYXAiLCJmb3JFYWNoIiwiZGVmaW5pdGlvbiIsInZlcnNpb24iLCJ0YXJnZXQiLCJzb3VyY2UiLCJhY3Rpb25zIiwiZXZlbnRUeXBlIiwicmVlbnRlciIsInRvSlNPTiIsInN0YXRlIiwib24iLCJ2YWx1ZXMiLCJmbGF0IiwiaW52b2tlIiwiaW52b2tlQ29uZmlnIiwic3JjIiwic3lzdGVtSWQiLCJyZXNvbHZlZElkIiwic291cmNlTmFtZSIsIm9uRG9uZSIsIm9uRXJyb3IiLCJpbnZva2VEZWZWYWx1ZXMiLCJmbGF0TWFwIiwiZGVzY3JpcHRvciIsInJlZHVjZSIsInRyYW5zaXRpb24iLCJwdXNoIiwiYWZ0ZXIiLCJuZXh0Iiwic25hcHNob3QiLCJzZWxlY3RlZFRyYW5zaXRpb24iLCJjYW5kaWRhdGVzIiwiY2FuZGlkYXRlIiwiZ3VhcmQiLCJyZXNvbHZlZENvbnRleHQiLCJjb250ZXh0IiwiZ3VhcmRQYXNzZWQiLCJlcnIiLCJndWFyZFR5cGUiLCJtZXNzYWdlIiwiZXZlbnRzIiwiU2V0Iiwib3duRXZlbnRzIiwic3RhdGVJZCIsImFkZCIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsInNvbWUiLCJTVEFURV9JREVOVElGSUVSIiwiU3RhdGVNYWNoaW5lIiwiaW1wbGVtZW50YXRpb25zIiwic2NoZW1hcyIsIl9feHN0YXRlbm9kZSIsIk1hcCIsInJvb3QiLCJhY3RvcnMiLCJkZWxheXMiLCJndWFyZHMiLCJiaW5kIiwiZ2V0SW5pdGlhbFNuYXBzaG90IiwicmVzdG9yZVNuYXBzaG90Iiwic3RhcnQiLCJjb25zb2xlIiwid2FybiIsInByb3ZpZGUiLCJyZXNvbHZlU3RhdGUiLCJyZXNvbHZlZFN0YXRlVmFsdWUiLCJ2YWx1ZSIsIm5vZGVTZXQiLCJfbm9kZXMiLCJjaGlsZHJlbiIsInN0YXR1cyIsImVycm9yIiwiaGlzdG9yeVZhbHVlIiwiYWN0b3JTY29wZSIsIm1pY3Jvc3RhdGVzIiwiZ2V0VHJhbnNpdGlvbkRhdGEiLCJnZXRQcmVJbml0aWFsU3RhdGUiLCJpbml0RXZlbnQiLCJpbnRlcm5hbFF1ZXVlIiwicHJlSW5pdGlhbCIsImFzc2lnbm1lbnQiLCJzcGF3biIsInNlbGYiLCJpbnB1dCIsInByZUluaXRpYWxTdGF0ZSIsIm5leHRTdGF0ZSIsIm1hY3JvU3RhdGUiLCJjaGlsZCIsImdldFNuYXBzaG90IiwiZ2V0U3RhdGVOb2RlQnlJZCIsImZ1bGxQYXRoIiwicmVsYXRpdmVQYXRoIiwicmVzb2x2ZWRTdGF0ZUlkIiwiX2FjdG9yU2NvcGUiLCJzbmFwc2hvdENoaWxkcmVuIiwiYWN0b3JJZCIsImFjdG9yRGF0YSIsImNoaWxkU3RhdGUiLCJsb2dpYyIsImFjdG9yUmVmIiwic3luY1NuYXBzaG90IiwicmVzb2x2ZUhpc3RvcnlSZWZlcmVuY2VkU3RhdGUiLCJyZWZlcmVuY2VkIiwicmV2aXZlSGlzdG9yeVZhbHVlIiwicmV2aXZlZCIsImFyciIsIml0ZW0iLCJyZXNvbHZlZCIsInJldml2ZWRIaXN0b3J5VmFsdWUiLCJyZXN0b3JlZFNuYXBzaG90Iiwic2VlbiIsInJldml2ZUNvbnRleHQiLCJjb250ZXh0UGFydCIsImhhcyIsInhzdGF0ZSQkdHlwZSIsImNyZWF0ZU1hY2hpbmUiLCJjcmVhdGVJbmVydEFjdG9yU2NvcGUiLCJhY3RvckxvZ2ljIiwiaW5lcnRBY3RvclNjb3BlIiwiZGVmZXIiLCJsb2dnZXIiLCJzZXNzaW9uSWQiLCJzeXN0ZW0iLCJhY3Rpb25FeGVjdXRvciIsImdldE5leHRTbmFwc2hvdCIsIl9zbmFwc2hvdCIsInNldHVwIiwiU2ltdWxhdGVkQ2xvY2siLCJ0aW1lb3V0cyIsIl9ub3ciLCJfaWQiLCJfZmx1c2hpbmciLCJfZmx1c2hpbmdJbnZhbGlkYXRlZCIsIm5vdyIsImdldElkIiwic2V0VGltZW91dCIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJkZWxldGUiLCJ0aW1lIiwiZmx1c2hUaW1lb3V0cyIsInNvcnRlZCIsInNvcnQiLCJfaWRBIiwidGltZW91dEEiLCJfaWRCIiwidGltZW91dEIiLCJlbmRBIiwiZW5kQiIsImNhbGwiLCJpbmNyZW1lbnQiLCJtcyIsInRvUHJvbWlzZSIsImFjdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzdWJzY3JpYmUiLCJjb21wbGV0ZSIsImV4ZWN1dGFibGVBY3Rpb25zIiwibmV4dFNuYXBzaG90IiwiaW5pdGlhbFRyYW5zaXRpb24iLCJkZWZhdWx0V2FpdEZvck9wdGlvbnMiLCJJbmZpbml0eSIsIndhaXRGb3IiLCJwcmVkaWNhdGUiLCJyZXNvbHZlZE9wdGlvbnMiLCJyZXMiLCJyZWoiLCJzaWduYWwiLCJhYm9ydGVkIiwicmVhc29uIiwiZG9uZSIsImhhbmRsZSIsImRpc3Bvc2UiLCJzdWIiLCJ1bnN1YnNjcmliZSIsImFib3J0TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2hlY2tFbWl0dGVkIiwiZW1pdHRlZCIsImFkZEV2ZW50TGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\n");

/***/ })

};
;