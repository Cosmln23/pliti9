/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-compiler-runtime";
exports.ids = ["vendor-chunks/react-compiler-runtime"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-compiler-runtime/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-compiler-runtime/dist/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @lightSyntaxTransform\n * @noflow\n * @nolint\n * @preventMunge\n * @preserve-invariant-messages\n */ \"use no memo\";\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n    $dispatcherGuard: ()=>$dispatcherGuard,\n    $makeReadOnly: ()=>$makeReadOnly,\n    $reset: ()=>$reset,\n    $structuralCheck: ()=>$structuralCheck,\n    c: ()=>c,\n    clearRenderCounterRegistry: ()=>clearRenderCounterRegistry,\n    renderCounterRegistry: ()=>renderCounterRegistry,\n    useRenderCounter: ()=>useRenderCounter\n});\nmodule.exports = __toCommonJS(index_exports);\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar { useRef, useEffect, isValidElement } = React;\nvar _a;\nvar ReactSecretInternals = //@ts-ignore\n(_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nvar $empty = Symbol.for(\"react.memo_cache_sentinel\");\nvar _a2;\nvar c = // @ts-expect-error\ntypeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === \"function\" ? // @ts-expect-error\nReact.__COMPILER_RUNTIME.c : function c2(size) {\n    return React.useMemo(()=>{\n        const $ = new Array(size);\n        for(let ii = 0; ii < size; ii++){\n            $[ii] = $empty;\n        }\n        $[$empty] = true;\n        return $;\n    }, []);\n};\nvar LazyGuardDispatcher = {};\n[\n    \"readContext\",\n    \"useCallback\",\n    \"useContext\",\n    \"useEffect\",\n    \"useImperativeHandle\",\n    \"useInsertionEffect\",\n    \"useLayoutEffect\",\n    \"useMemo\",\n    \"useReducer\",\n    \"useRef\",\n    \"useState\",\n    \"useDebugValue\",\n    \"useDeferredValue\",\n    \"useTransition\",\n    \"useMutableSource\",\n    \"useSyncExternalStore\",\n    \"useId\",\n    \"unstable_isNewReconciler\",\n    \"getCacheSignal\",\n    \"getCacheForType\",\n    \"useCacheRefresh\"\n].forEach((name)=>{\n    LazyGuardDispatcher[name] = ()=>{\n        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `);\n    };\n});\nvar originalDispatcher = null;\nLazyGuardDispatcher[\"useMemoCache\"] = (count)=>{\n    if (originalDispatcher == null) {\n        throw new Error(\"React Compiler internal invariant violation: unexpected null dispatcher\");\n    } else {\n        return originalDispatcher.useMemoCache(count);\n    }\n};\nfunction setCurrent(newDispatcher) {\n    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;\n    return ReactSecretInternals.ReactCurrentDispatcher.current;\n}\nvar guardFrames = [];\nfunction $dispatcherGuard(kind) {\n    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;\n    if (kind === 0 /* PushGuardContext */ ) {\n        guardFrames.push(curr);\n        if (guardFrames.length === 1) {\n            originalDispatcher = curr;\n        }\n        if (curr === LazyGuardDispatcher) {\n            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.`);\n        }\n        setCurrent(LazyGuardDispatcher);\n    } else if (kind === 1 /* PopGuardContext */ ) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error(\"React Compiler internal error: unexpected null in guard stack\");\n        }\n        if (guardFrames.length === 0) {\n            originalDispatcher = null;\n        }\n        setCurrent(lastFrame);\n    } else if (kind === 2 /* PushExpectHook */ ) {\n        guardFrames.push(curr);\n        setCurrent(originalDispatcher);\n    } else if (kind === 3 /* PopExpectHook */ ) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error(\"React Compiler internal error: unexpected null in guard stack\");\n        }\n        setCurrent(lastFrame);\n    } else {\n        throw new Error(\"React Compiler internal error: unreachable block\" + kind);\n    }\n}\nfunction $reset($) {\n    for(let ii = 0; ii < $.length; ii++){\n        $[ii] = $empty;\n    }\n}\nfunction $makeReadOnly() {\n    throw new Error(\"TODO: implement $makeReadOnly in react-compiler-runtime\");\n}\nvar renderCounterRegistry = /* @__PURE__ */ new Map();\nfunction clearRenderCounterRegistry() {\n    for (const counters of renderCounterRegistry.values()){\n        counters.forEach((counter)=>{\n            counter.count = 0;\n        });\n    }\n}\nfunction registerRenderCounter(name, val) {\n    let counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        counters = /* @__PURE__ */ new Set();\n        renderCounterRegistry.set(name, counters);\n    }\n    counters.add(val);\n}\nfunction removeRenderCounter(name, val) {\n    const counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        return;\n    }\n    counters.delete(val);\n}\nfunction useRenderCounter(name) {\n    const val = useRef(null);\n    if (val.current != null) {\n        val.current.count += 1;\n    }\n    useEffect(()=>{\n        if (val.current == null) {\n            const counter = {\n                count: 0\n            };\n            registerRenderCounter(name, counter);\n            val.current = counter;\n        }\n        return ()=>{\n            if (val.current !== null) {\n                removeRenderCounter(name, val.current);\n            }\n        };\n    });\n}\nvar seenErrors = /* @__PURE__ */ new Set();\nfunction $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {\n    function error(l, r, path, depth) {\n        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;\n        if (seenErrors.has(str)) {\n            return;\n        }\n        seenErrors.add(str);\n        console.error(str);\n    }\n    const depthLimit = 2;\n    function recur(oldValue2, newValue2, path, depth) {\n        if (depth > depthLimit) {\n            return;\n        } else if (oldValue2 === newValue2) {\n            return;\n        } else if (typeof oldValue2 !== typeof newValue2) {\n            error(`type ${typeof oldValue2}`, `type ${typeof newValue2}`, path, depth);\n        } else if (typeof oldValue2 === \"object\") {\n            const oldArray = Array.isArray(oldValue2);\n            const newArray = Array.isArray(newValue2);\n            if (oldValue2 === null && newValue2 !== null) {\n                error(\"null\", `type ${typeof newValue2}`, path, depth);\n            } else if (newValue2 === null) {\n                error(`type ${typeof oldValue2}`, \"null\", path, depth);\n            } else if (oldValue2 instanceof Map) {\n                if (!(newValue2 instanceof Map)) {\n                    error(`Map instance`, `other value`, path, depth);\n                } else if (oldValue2.size !== newValue2.size) {\n                    error(`Map instance with size ${oldValue2.size}`, `Map instance with size ${newValue2.size}`, path, depth);\n                } else {\n                    for (const [k, v] of oldValue2){\n                        if (!newValue2.has(k)) {\n                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);\n                        } else {\n                            recur(v, newValue2.get(k), `${path}.get(${k})`, depth + 1);\n                        }\n                    }\n                }\n            } else if (newValue2 instanceof Map) {\n                error(\"other value\", `Map instance`, path, depth);\n            } else if (oldValue2 instanceof Set) {\n                if (!(newValue2 instanceof Set)) {\n                    error(`Set instance`, `other value`, path, depth);\n                } else if (oldValue2.size !== newValue2.size) {\n                    error(`Set instance with size ${oldValue2.size}`, `Set instance with size ${newValue2.size}`, path, depth);\n                } else {\n                    for (const v of newValue2){\n                        if (!oldValue2.has(v)) {\n                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);\n                        }\n                    }\n                }\n            } else if (newValue2 instanceof Set) {\n                error(\"other value\", `Set instance`, path, depth);\n            } else if (oldArray || newArray) {\n                if (oldArray !== newArray) {\n                    error(`type ${oldArray ? \"array\" : \"object\"}`, `type ${newArray ? \"array\" : \"object\"}`, path, depth);\n                } else if (oldValue2.length !== newValue2.length) {\n                    error(`array with length ${oldValue2.length}`, `array with length ${newValue2.length}`, path, depth);\n                } else {\n                    for(let ii = 0; ii < oldValue2.length; ii++){\n                        recur(oldValue2[ii], newValue2[ii], `${path}[${ii}]`, depth + 1);\n                    }\n                }\n            } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {\n                if (isValidElement(oldValue2) !== isValidElement(newValue2)) {\n                    error(`type ${isValidElement(oldValue2) ? \"React element\" : \"object\"}`, `type ${isValidElement(newValue2) ? \"React element\" : \"object\"}`, path, depth);\n                } else if (oldValue2.type !== newValue2.type) {\n                    error(`React element of type ${oldValue2.type}`, `React element of type ${newValue2.type}`, path, depth);\n                } else {\n                    recur(oldValue2.props, newValue2.props, `[props of ${path}]`, depth + 1);\n                }\n            } else {\n                for(const key in newValue2){\n                    if (!(key in oldValue2)) {\n                        error(`object without key ${key}`, `object with key ${key}`, path, depth);\n                    }\n                }\n                for(const key in oldValue2){\n                    if (!(key in newValue2)) {\n                        error(`object with key ${key}`, `object without key ${key}`, path, depth);\n                    } else {\n                        recur(oldValue2[key], newValue2[key], `${path}.${key}`, depth + 1);\n                    }\n                }\n            }\n        } else if (typeof oldValue2 === \"function\") {\n            return;\n        } else if (isNaN(oldValue2) || isNaN(newValue2)) {\n            if (isNaN(oldValue2) !== isNaN(newValue2)) {\n                error(`${isNaN(oldValue2) ? \"NaN\" : \"non-NaN value\"}`, `${isNaN(newValue2) ? \"NaN\" : \"non-NaN value\"}`, path, depth);\n            }\n        } else if (oldValue2 !== newValue2) {\n            error(oldValue2, newValue2, path, depth);\n        }\n    }\n    recur(oldValue, newValue, \"\", 0);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY29tcGlsZXItcnVudGltZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztDQVdDLEdBRUQ7QUFDQTtBQUNBLElBQUlBLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZmIsVUFBVVksUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPbEIsa0JBQWtCZSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNwQixVQUFVa0IsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9uQixpQkFBaUJpQixNQUFNRyxJQUFHLEtBQU1ELEtBQUtMLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxJQUFJTSxVQUFVLENBQUNDLEtBQUtDLFlBQVlkLFNBQVlBLENBQUFBLFNBQVNhLE9BQU8sT0FBTzVCLFNBQVNTLGFBQWFtQixRQUFRLENBQUMsR0FBR1IsWUFDbkcsc0VBQXNFO0lBQ3RFLGlFQUFpRTtJQUNqRSxzRUFBc0U7SUFD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UUFBUSxnQkFBZ0IsQ0FBQyxFQUMvQ1IsTUFDQUM7WUFFSjtRQUNGLE9BQU8sSUFBSU0sY0FBY0MsV0FBVztZQUNsQ1gsTUFBTVUsV0FBV0MsV0FBV1IsTUFBTUM7UUFDcEM7SUFDRjtJQUNBSyxNQUFNZCxVQUFVQyxVQUFVLElBQUk7QUFDaEM7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTXBELENBQUFBLENBU04sR0FDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGlwbGk5LXBhcmFub3JtYWwvLi9ub2RlX21vZHVsZXMvcmVhY3QtY29tcGlsZXItcnVudGltZS9kaXN0L2luZGV4LmpzPzMzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWdodFN5bnRheFRyYW5zZm9ybVxuICogQG5vZmxvd1xuICogQG5vbGludFxuICogQHByZXZlbnRNdW5nZVxuICogQHByZXNlcnZlLWludmFyaWFudC1tZXNzYWdlc1xuICovXG5cblwidXNlIG5vIG1lbW9cIjtcblwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICAkZGlzcGF0Y2hlckd1YXJkOiAoKSA9PiAkZGlzcGF0Y2hlckd1YXJkLFxuICAkbWFrZVJlYWRPbmx5OiAoKSA9PiAkbWFrZVJlYWRPbmx5LFxuICAkcmVzZXQ6ICgpID0+ICRyZXNldCxcbiAgJHN0cnVjdHVyYWxDaGVjazogKCkgPT4gJHN0cnVjdHVyYWxDaGVjayxcbiAgYzogKCkgPT4gYyxcbiAgY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnk6ICgpID0+IGNsZWFyUmVuZGVyQ291bnRlclJlZ2lzdHJ5LFxuICByZW5kZXJDb3VudGVyUmVnaXN0cnk6ICgpID0+IHJlbmRlckNvdW50ZXJSZWdpc3RyeSxcbiAgdXNlUmVuZGVyQ291bnRlcjogKCkgPT4gdXNlUmVuZGVyQ291bnRlclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcbnZhciBSZWFjdCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciB7IHVzZVJlZiwgdXNlRWZmZWN0LCBpc1ZhbGlkRWxlbWVudCB9ID0gUmVhY3Q7XG52YXIgX2E7XG52YXIgUmVhY3RTZWNyZXRJbnRlcm5hbHMgPSAoXG4gIC8vQHRzLWlnbm9yZVxuICAoX2EgPSBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUpICE9IG51bGwgPyBfYSA6IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEXG4pO1xudmFyICRlbXB0eSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpO1xudmFyIF9hMjtcbnZhciBjID0gKFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIHR5cGVvZiAoKF9hMiA9IFJlYWN0Ll9fQ09NUElMRVJfUlVOVElNRSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jKSA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBSZWFjdC5fX0NPTVBJTEVSX1JVTlRJTUUuY1xuICApIDogZnVuY3Rpb24gYzIoc2l6ZSkge1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnN0ICQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgc2l6ZTsgaWkrKykge1xuICAgICAgICAkW2lpXSA9ICRlbXB0eTtcbiAgICAgIH1cbiAgICAgICRbJGVtcHR5XSA9IHRydWU7XG4gICAgICByZXR1cm4gJDtcbiAgICB9LCBbXSk7XG4gIH1cbik7XG52YXIgTGF6eUd1YXJkRGlzcGF0Y2hlciA9IHt9O1xuW1xuICBcInJlYWRDb250ZXh0XCIsXG4gIFwidXNlQ2FsbGJhY2tcIixcbiAgXCJ1c2VDb250ZXh0XCIsXG4gIFwidXNlRWZmZWN0XCIsXG4gIFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiLFxuICBcInVzZUluc2VydGlvbkVmZmVjdFwiLFxuICBcInVzZUxheW91dEVmZmVjdFwiLFxuICBcInVzZU1lbW9cIixcbiAgXCJ1c2VSZWR1Y2VyXCIsXG4gIFwidXNlUmVmXCIsXG4gIFwidXNlU3RhdGVcIixcbiAgXCJ1c2VEZWJ1Z1ZhbHVlXCIsXG4gIFwidXNlRGVmZXJyZWRWYWx1ZVwiLFxuICBcInVzZVRyYW5zaXRpb25cIixcbiAgXCJ1c2VNdXRhYmxlU291cmNlXCIsXG4gIFwidXNlU3luY0V4dGVybmFsU3RvcmVcIixcbiAgXCJ1c2VJZFwiLFxuICBcInVuc3RhYmxlX2lzTmV3UmVjb25jaWxlclwiLFxuICBcImdldENhY2hlU2lnbmFsXCIsXG4gIFwiZ2V0Q2FjaGVGb3JUeXBlXCIsXG4gIFwidXNlQ2FjaGVSZWZyZXNoXCJcbl0uZm9yRWFjaCgobmFtZSkgPT4ge1xuICBMYXp5R3VhcmREaXNwYXRjaGVyW25hbWVdID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBbUmVhY3RdIFVuZXhwZWN0ZWQgUmVhY3QgaG9vayBjYWxsICgke25hbWV9KSBmcm9tIGEgUmVhY3QgY29tcGlsZWQgZnVuY3Rpb24uIENoZWNrIHRoYXQgYWxsIGhvb2tzIGFyZSBjYWxsZWQgZGlyZWN0bHkgYW5kIG5hbWVkIGFjY29yZGluZyB0byBjb252ZW50aW9uICgndXNlW0EtWl0nKSBgXG4gICAgKTtcbiAgfTtcbn0pO1xudmFyIG9yaWdpbmFsRGlzcGF0Y2hlciA9IG51bGw7XG5MYXp5R3VhcmREaXNwYXRjaGVyW1widXNlTWVtb0NhY2hlXCJdID0gKGNvdW50KSA9PiB7XG4gIGlmIChvcmlnaW5hbERpc3BhdGNoZXIgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiUmVhY3QgQ29tcGlsZXIgaW50ZXJuYWwgaW52YXJpYW50IHZpb2xhdGlvbjogdW5leHBlY3RlZCBudWxsIGRpc3BhdGNoZXJcIlxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsRGlzcGF0Y2hlci51c2VNZW1vQ2FjaGUoY291bnQpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0Q3VycmVudChuZXdEaXNwYXRjaGVyKSB7XG4gIFJlYWN0U2VjcmV0SW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG5ld0Rpc3BhdGNoZXI7XG4gIHJldHVybiBSZWFjdFNlY3JldEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG59XG52YXIgZ3VhcmRGcmFtZXMgPSBbXTtcbmZ1bmN0aW9uICRkaXNwYXRjaGVyR3VhcmQoa2luZCkge1xuICBjb25zdCBjdXJyID0gUmVhY3RTZWNyZXRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICBpZiAoa2luZCA9PT0gMCAvKiBQdXNoR3VhcmRDb250ZXh0ICovKSB7XG4gICAgZ3VhcmRGcmFtZXMucHVzaChjdXJyKTtcbiAgICBpZiAoZ3VhcmRGcmFtZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBvcmlnaW5hbERpc3BhdGNoZXIgPSBjdXJyO1xuICAgIH1cbiAgICBpZiAoY3VyciA9PT0gTGF6eUd1YXJkRGlzcGF0Y2hlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgW1JlYWN0XSBVbmV4cGVjdGVkIGNhbGwgdG8gY3VzdG9tIGhvb2sgb3IgY29tcG9uZW50IGZyb20gYSBSZWFjdCBjb21waWxlZCBmdW5jdGlvbi4gQ2hlY2sgdGhhdCAoMSkgYWxsIGhvb2tzIGFyZSBjYWxsZWQgZGlyZWN0bHkgYW5kIG5hbWVkIGFjY29yZGluZyB0byBjb252ZW50aW9uICgndXNlW0EtWl0nKSBhbmQgKDIpIGNvbXBvbmVudHMgYXJlIHJldHVybmVkIGFzIEpTWCBpbnN0ZWFkIG9mIGJlaW5nIGRpcmVjdGx5IGludm9rZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgc2V0Q3VycmVudChMYXp5R3VhcmREaXNwYXRjaGVyKTtcbiAgfSBlbHNlIGlmIChraW5kID09PSAxIC8qIFBvcEd1YXJkQ29udGV4dCAqLykge1xuICAgIGNvbnN0IGxhc3RGcmFtZSA9IGd1YXJkRnJhbWVzLnBvcCgpO1xuICAgIGlmIChsYXN0RnJhbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlJlYWN0IENvbXBpbGVyIGludGVybmFsIGVycm9yOiB1bmV4cGVjdGVkIG51bGwgaW4gZ3VhcmQgc3RhY2tcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGd1YXJkRnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb3JpZ2luYWxEaXNwYXRjaGVyID0gbnVsbDtcbiAgICB9XG4gICAgc2V0Q3VycmVudChsYXN0RnJhbWUpO1xuICB9IGVsc2UgaWYgKGtpbmQgPT09IDIgLyogUHVzaEV4cGVjdEhvb2sgKi8pIHtcbiAgICBndWFyZEZyYW1lcy5wdXNoKGN1cnIpO1xuICAgIHNldEN1cnJlbnQob3JpZ2luYWxEaXNwYXRjaGVyKTtcbiAgfSBlbHNlIGlmIChraW5kID09PSAzIC8qIFBvcEV4cGVjdEhvb2sgKi8pIHtcbiAgICBjb25zdCBsYXN0RnJhbWUgPSBndWFyZEZyYW1lcy5wb3AoKTtcbiAgICBpZiAobGFzdEZyYW1lID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJSZWFjdCBDb21waWxlciBpbnRlcm5hbCBlcnJvcjogdW5leHBlY3RlZCBudWxsIGluIGd1YXJkIHN0YWNrXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHNldEN1cnJlbnQobGFzdEZyYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBDb21waWxlciBpbnRlcm5hbCBlcnJvcjogdW5yZWFjaGFibGUgYmxvY2tcIiArIGtpbmQpO1xuICB9XG59XG5mdW5jdGlvbiAkcmVzZXQoJCkge1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgJC5sZW5ndGg7IGlpKyspIHtcbiAgICAkW2lpXSA9ICRlbXB0eTtcbiAgfVxufVxuZnVuY3Rpb24gJG1ha2VSZWFkT25seSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVE9ETzogaW1wbGVtZW50ICRtYWtlUmVhZE9ubHkgaW4gcmVhY3QtY29tcGlsZXItcnVudGltZVwiKTtcbn1cbnZhciByZW5kZXJDb3VudGVyUmVnaXN0cnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnkoKSB7XG4gIGZvciAoY29uc3QgY291bnRlcnMgb2YgcmVuZGVyQ291bnRlclJlZ2lzdHJ5LnZhbHVlcygpKSB7XG4gICAgY291bnRlcnMuZm9yRWFjaCgoY291bnRlcikgPT4ge1xuICAgICAgY291bnRlci5jb3VudCA9IDA7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVuZGVyQ291bnRlcihuYW1lLCB2YWwpIHtcbiAgbGV0IGNvdW50ZXJzID0gcmVuZGVyQ291bnRlclJlZ2lzdHJ5LmdldChuYW1lKTtcbiAgaWYgKGNvdW50ZXJzID09IG51bGwpIHtcbiAgICBjb3VudGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgcmVuZGVyQ291bnRlclJlZ2lzdHJ5LnNldChuYW1lLCBjb3VudGVycyk7XG4gIH1cbiAgY291bnRlcnMuYWRkKHZhbCk7XG59XG5mdW5jdGlvbiByZW1vdmVSZW5kZXJDb3VudGVyKG5hbWUsIHZhbCkge1xuICBjb25zdCBjb3VudGVycyA9IHJlbmRlckNvdW50ZXJSZWdpc3RyeS5nZXQobmFtZSk7XG4gIGlmIChjb3VudGVycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvdW50ZXJzLmRlbGV0ZSh2YWwpO1xufVxuZnVuY3Rpb24gdXNlUmVuZGVyQ291bnRlcihuYW1lKSB7XG4gIGNvbnN0IHZhbCA9IHVzZVJlZihudWxsKTtcbiAgaWYgKHZhbC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICB2YWwuY3VycmVudC5jb3VudCArPSAxO1xuICB9XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZhbC5jdXJyZW50ID09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNvdW50ZXIgPSB7IGNvdW50OiAwIH07XG4gICAgICByZWdpc3RlclJlbmRlckNvdW50ZXIobmFtZSwgY291bnRlcik7XG4gICAgICB2YWwuY3VycmVudCA9IGNvdW50ZXI7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodmFsLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlUmVuZGVyQ291bnRlcihuYW1lLCB2YWwuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG52YXIgc2VlbkVycm9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiAkc3RydWN0dXJhbENoZWNrKG9sZFZhbHVlLCBuZXdWYWx1ZSwgdmFyaWFibGVOYW1lLCBmbk5hbWUsIGtpbmQsIGxvYykge1xuICBmdW5jdGlvbiBlcnJvcihsLCByLCBwYXRoLCBkZXB0aCkge1xuICAgIGNvbnN0IHN0ciA9IGAke2ZuTmFtZX06JHtsb2N9IFske2tpbmR9XSAke3ZhcmlhYmxlTmFtZX0ke3BhdGh9IGNoYW5nZWQgZnJvbSAke2x9IHRvICR7cn0gYXQgZGVwdGggJHtkZXB0aH1gO1xuICAgIGlmIChzZWVuRXJyb3JzLmhhcyhzdHIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlZW5FcnJvcnMuYWRkKHN0cik7XG4gICAgY29uc29sZS5lcnJvcihzdHIpO1xuICB9XG4gIGNvbnN0IGRlcHRoTGltaXQgPSAyO1xuICBmdW5jdGlvbiByZWN1cihvbGRWYWx1ZTIsIG5ld1ZhbHVlMiwgcGF0aCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPiBkZXB0aExpbWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChvbGRWYWx1ZTIgPT09IG5ld1ZhbHVlMikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9sZFZhbHVlMiAhPT0gdHlwZW9mIG5ld1ZhbHVlMikge1xuICAgICAgZXJyb3IoYHR5cGUgJHt0eXBlb2Ygb2xkVmFsdWUyfWAsIGB0eXBlICR7dHlwZW9mIG5ld1ZhbHVlMn1gLCBwYXRoLCBkZXB0aCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2xkVmFsdWUyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBvbGRBcnJheSA9IEFycmF5LmlzQXJyYXkob2xkVmFsdWUyKTtcbiAgICAgIGNvbnN0IG5ld0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXdWYWx1ZTIpO1xuICAgICAgaWYgKG9sZFZhbHVlMiA9PT0gbnVsbCAmJiBuZXdWYWx1ZTIgIT09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoXCJudWxsXCIsIGB0eXBlICR7dHlwZW9mIG5ld1ZhbHVlMn1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlMiA9PT0gbnVsbCkge1xuICAgICAgICBlcnJvcihgdHlwZSAke3R5cGVvZiBvbGRWYWx1ZTJ9YCwgXCJudWxsXCIsIHBhdGgsIGRlcHRoKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUyIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGlmICghKG5ld1ZhbHVlMiBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgICBlcnJvcihgTWFwIGluc3RhbmNlYCwgYG90aGVyIHZhbHVlYCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlMi5zaXplICE9PSBuZXdWYWx1ZTIuc2l6ZSkge1xuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgYE1hcCBpbnN0YW5jZSB3aXRoIHNpemUgJHtvbGRWYWx1ZTIuc2l6ZX1gLFxuICAgICAgICAgICAgYE1hcCBpbnN0YW5jZSB3aXRoIHNpemUgJHtuZXdWYWx1ZTIuc2l6ZX1gLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBvbGRWYWx1ZTIpIHtcbiAgICAgICAgICAgIGlmICghbmV3VmFsdWUyLmhhcyhrKSkge1xuICAgICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgICBgTWFwIGluc3RhbmNlIHdpdGgga2V5ICR7a31gLFxuICAgICAgICAgICAgICAgIGBNYXAgaW5zdGFuY2Ugd2l0aG91dCBrZXkgJHtrfWAsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjdXIodiwgbmV3VmFsdWUyLmdldChrKSwgYCR7cGF0aH0uZ2V0KCR7a30pYCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUyIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGVycm9yKFwib3RoZXIgdmFsdWVcIiwgYE1hcCBpbnN0YW5jZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUyIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGlmICghKG5ld1ZhbHVlMiBpbnN0YW5jZW9mIFNldCkpIHtcbiAgICAgICAgICBlcnJvcihgU2V0IGluc3RhbmNlYCwgYG90aGVyIHZhbHVlYCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlMi5zaXplICE9PSBuZXdWYWx1ZTIuc2l6ZSkge1xuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgYFNldCBpbnN0YW5jZSB3aXRoIHNpemUgJHtvbGRWYWx1ZTIuc2l6ZX1gLFxuICAgICAgICAgICAgYFNldCBpbnN0YW5jZSB3aXRoIHNpemUgJHtuZXdWYWx1ZTIuc2l6ZX1gLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbmV3VmFsdWUyKSB7XG4gICAgICAgICAgICBpZiAoIW9sZFZhbHVlMi5oYXModikpIHtcbiAgICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgYFNldCBpbnN0YW5jZSB3aXRob3V0IGVsZW1lbnQgJHt2fWAsXG4gICAgICAgICAgICAgICAgYFNldCBpbnN0YW5jZSB3aXRoIGVsZW1lbnQgJHt2fWAsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZTIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgZXJyb3IoXCJvdGhlciB2YWx1ZVwiLCBgU2V0IGluc3RhbmNlYCwgcGF0aCwgZGVwdGgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRBcnJheSB8fCBuZXdBcnJheSkge1xuICAgICAgICBpZiAob2xkQXJyYXkgIT09IG5ld0FycmF5KSB7XG4gICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICBgdHlwZSAke29sZEFycmF5ID8gXCJhcnJheVwiIDogXCJvYmplY3RcIn1gLFxuICAgICAgICAgICAgYHR5cGUgJHtuZXdBcnJheSA/IFwiYXJyYXlcIiA6IFwib2JqZWN0XCJ9YCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUyLmxlbmd0aCAhPT0gbmV3VmFsdWUyLmxlbmd0aCkge1xuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgYGFycmF5IHdpdGggbGVuZ3RoICR7b2xkVmFsdWUyLmxlbmd0aH1gLFxuICAgICAgICAgICAgYGFycmF5IHdpdGggbGVuZ3RoICR7bmV3VmFsdWUyLmxlbmd0aH1gLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgb2xkVmFsdWUyLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgcmVjdXIob2xkVmFsdWUyW2lpXSwgbmV3VmFsdWUyW2lpXSwgYCR7cGF0aH1bJHtpaX1dYCwgZGVwdGggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQob2xkVmFsdWUyKSB8fCBpc1ZhbGlkRWxlbWVudChuZXdWYWx1ZTIpKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChvbGRWYWx1ZTIpICE9PSBpc1ZhbGlkRWxlbWVudChuZXdWYWx1ZTIpKSB7XG4gICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICBgdHlwZSAke2lzVmFsaWRFbGVtZW50KG9sZFZhbHVlMikgPyBcIlJlYWN0IGVsZW1lbnRcIiA6IFwib2JqZWN0XCJ9YCxcbiAgICAgICAgICAgIGB0eXBlICR7aXNWYWxpZEVsZW1lbnQobmV3VmFsdWUyKSA/IFwiUmVhY3QgZWxlbWVudFwiIDogXCJvYmplY3RcIn1gLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZTIudHlwZSAhPT0gbmV3VmFsdWUyLnR5cGUpIHtcbiAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGBSZWFjdCBlbGVtZW50IG9mIHR5cGUgJHtvbGRWYWx1ZTIudHlwZX1gLFxuICAgICAgICAgICAgYFJlYWN0IGVsZW1lbnQgb2YgdHlwZSAke25ld1ZhbHVlMi50eXBlfWAsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3VyKFxuICAgICAgICAgICAgb2xkVmFsdWUyLnByb3BzLFxuICAgICAgICAgICAgbmV3VmFsdWUyLnByb3BzLFxuICAgICAgICAgICAgYFtwcm9wcyBvZiAke3BhdGh9XWAsXG4gICAgICAgICAgICBkZXB0aCArIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdWYWx1ZTIpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gb2xkVmFsdWUyKSkge1xuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIGBvYmplY3Qgd2l0aG91dCBrZXkgJHtrZXl9YCxcbiAgICAgICAgICAgICAgYG9iamVjdCB3aXRoIGtleSAke2tleX1gLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkVmFsdWUyKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIG5ld1ZhbHVlMikpIHtcbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICBgb2JqZWN0IHdpdGgga2V5ICR7a2V5fWAsXG4gICAgICAgICAgICAgIGBvYmplY3Qgd2l0aG91dCBrZXkgJHtrZXl9YCxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY3VyKG9sZFZhbHVlMltrZXldLCBuZXdWYWx1ZTJba2V5XSwgYCR7cGF0aH0uJHtrZXl9YCwgZGVwdGggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvbGRWYWx1ZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNOYU4ob2xkVmFsdWUyKSB8fCBpc05hTihuZXdWYWx1ZTIpKSB7XG4gICAgICBpZiAoaXNOYU4ob2xkVmFsdWUyKSAhPT0gaXNOYU4obmV3VmFsdWUyKSkge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICBgJHtpc05hTihvbGRWYWx1ZTIpID8gXCJOYU5cIiA6IFwibm9uLU5hTiB2YWx1ZVwifWAsXG4gICAgICAgICAgYCR7aXNOYU4obmV3VmFsdWUyKSA/IFwiTmFOXCIgOiBcIm5vbi1OYU4gdmFsdWVcIn1gLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgZGVwdGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZhbHVlMiAhPT0gbmV3VmFsdWUyKSB7XG4gICAgICBlcnJvcihvbGRWYWx1ZTIsIG5ld1ZhbHVlMiwgcGF0aCwgZGVwdGgpO1xuICAgIH1cbiAgfVxuICByZWN1cihvbGRWYWx1ZSwgbmV3VmFsdWUsIFwiXCIsIDApO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICRkaXNwYXRjaGVyR3VhcmQsXG4gICRtYWtlUmVhZE9ubHksXG4gICRyZXNldCxcbiAgJHN0cnVjdHVyYWxDaGVjayxcbiAgYyxcbiAgY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnksXG4gIHJlbmRlckNvdW50ZXJSZWdpc3RyeSxcbiAgdXNlUmVuZGVyQ291bnRlclxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGUiLCJPYmplY3QiLCJjcmVhdGUiLCJfX2RlZlByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2dldFByb3RvT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJfX3RvRVNNIiwibW9kIiwiaXNOb2RlTW9kZSIsIl9fZXNNb2R1bGUiLCJ2YWx1ZSIsIl9fdG9Db21tb25KUyIsImluZGV4X2V4cG9ydHMiLCIkZGlzcGF0Y2hlckd1YXJkIiwiJG1ha2VSZWFkT25seSIsIiRyZXNldCIsIiRzdHJ1Y3R1cmFsQ2hlY2siLCJjIiwiY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnkiLCJyZW5kZXJDb3VudGVyUmVnaXN0cnkiLCJ1c2VSZW5kZXJDb3VudGVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlYWN0IiwicmVxdWlyZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsImlzVmFsaWRFbGVtZW50IiwiX2EiLCJSZWFjdFNlY3JldEludGVybmFscyIsIl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiJGVtcHR5IiwiU3ltYm9sIiwiZm9yIiwiX2EyIiwiX19DT01QSUxFUl9SVU5USU1FIiwiYzIiLCJzaXplIiwidXNlTWVtbyIsIiQiLCJBcnJheSIsImlpIiwiTGF6eUd1YXJkRGlzcGF0Y2hlciIsImZvckVhY2giLCJFcnJvciIsIm9yaWdpbmFsRGlzcGF0Y2hlciIsImNvdW50IiwidXNlTWVtb0NhY2hlIiwic2V0Q3VycmVudCIsIm5ld0Rpc3BhdGNoZXIiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwiY3VycmVudCIsImd1YXJkRnJhbWVzIiwia2luZCIsImN1cnIiLCJwdXNoIiwibGVuZ3RoIiwibGFzdEZyYW1lIiwicG9wIiwiTWFwIiwiY291bnRlcnMiLCJ2YWx1ZXMiLCJjb3VudGVyIiwicmVnaXN0ZXJSZW5kZXJDb3VudGVyIiwidmFsIiwiU2V0Iiwic2V0IiwiYWRkIiwicmVtb3ZlUmVuZGVyQ291bnRlciIsImRlbGV0ZSIsInNlZW5FcnJvcnMiLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwidmFyaWFibGVOYW1lIiwiZm5OYW1lIiwibG9jIiwiZXJyb3IiLCJsIiwiciIsInBhdGgiLCJkZXB0aCIsInN0ciIsImhhcyIsImNvbnNvbGUiLCJkZXB0aExpbWl0IiwicmVjdXIiLCJvbGRWYWx1ZTIiLCJuZXdWYWx1ZTIiLCJvbGRBcnJheSIsImlzQXJyYXkiLCJuZXdBcnJheSIsImsiLCJ2IiwidHlwZSIsInByb3BzIiwiaXNOYU4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-compiler-runtime/dist/index.js\n");

/***/ })

};
;