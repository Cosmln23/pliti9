"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valibot";
exports.ids = ["vendor-chunks/valibot"];
exports.modules = {

/***/ "(ssr)/./node_modules/valibot/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/valibot/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE64_REGEX: () => (/* binding */ BASE64_REGEX),\n/* harmony export */   BIC_REGEX: () => (/* binding */ BIC_REGEX),\n/* harmony export */   CUID2_REGEX: () => (/* binding */ CUID2_REGEX),\n/* harmony export */   DECIMAL_REGEX: () => (/* binding */ DECIMAL_REGEX),\n/* harmony export */   DIGITS_REGEX: () => (/* binding */ DIGITS_REGEX),\n/* harmony export */   EMAIL_REGEX: () => (/* binding */ EMAIL_REGEX),\n/* harmony export */   EMOJI_REGEX: () => (/* binding */ EMOJI_REGEX),\n/* harmony export */   HEXADECIMAL_REGEX: () => (/* binding */ HEXADECIMAL_REGEX),\n/* harmony export */   HEX_COLOR_REGEX: () => (/* binding */ HEX_COLOR_REGEX),\n/* harmony export */   IMEI_REGEX: () => (/* binding */ IMEI_REGEX),\n/* harmony export */   IPV4_REGEX: () => (/* binding */ IPV4_REGEX),\n/* harmony export */   IPV6_REGEX: () => (/* binding */ IPV6_REGEX),\n/* harmony export */   IP_REGEX: () => (/* binding */ IP_REGEX),\n/* harmony export */   ISO_DATE_REGEX: () => (/* binding */ ISO_DATE_REGEX),\n/* harmony export */   ISO_DATE_TIME_REGEX: () => (/* binding */ ISO_DATE_TIME_REGEX),\n/* harmony export */   ISO_TIMESTAMP_REGEX: () => (/* binding */ ISO_TIMESTAMP_REGEX),\n/* harmony export */   ISO_TIME_REGEX: () => (/* binding */ ISO_TIME_REGEX),\n/* harmony export */   ISO_TIME_SECOND_REGEX: () => (/* binding */ ISO_TIME_SECOND_REGEX),\n/* harmony export */   ISO_WEEK_REGEX: () => (/* binding */ ISO_WEEK_REGEX),\n/* harmony export */   MAC48_REGEX: () => (/* binding */ MAC48_REGEX),\n/* harmony export */   MAC64_REGEX: () => (/* binding */ MAC64_REGEX),\n/* harmony export */   MAC_REGEX: () => (/* binding */ MAC_REGEX),\n/* harmony export */   NANO_ID_REGEX: () => (/* binding */ NANO_ID_REGEX),\n/* harmony export */   OCTAL_REGEX: () => (/* binding */ OCTAL_REGEX),\n/* harmony export */   RFC_EMAIL_REGEX: () => (/* binding */ RFC_EMAIL_REGEX),\n/* harmony export */   SLUG_REGEX: () => (/* binding */ SLUG_REGEX),\n/* harmony export */   ULID_REGEX: () => (/* binding */ ULID_REGEX),\n/* harmony export */   UUID_REGEX: () => (/* binding */ UUID_REGEX),\n/* harmony export */   ValiError: () => (/* binding */ ValiError),\n/* harmony export */   _addIssue: () => (/* binding */ _addIssue),\n/* harmony export */   _getByteCount: () => (/* binding */ _getByteCount),\n/* harmony export */   _getGraphemeCount: () => (/* binding */ _getGraphemeCount),\n/* harmony export */   _getLastMetadata: () => (/* binding */ _getLastMetadata),\n/* harmony export */   _getStandardProps: () => (/* binding */ _getStandardProps),\n/* harmony export */   _getWordCount: () => (/* binding */ _getWordCount),\n/* harmony export */   _isLuhnAlgo: () => (/* binding */ _isLuhnAlgo),\n/* harmony export */   _isValidObjectKey: () => (/* binding */ _isValidObjectKey),\n/* harmony export */   _joinExpects: () => (/* binding */ _joinExpects),\n/* harmony export */   _stringify: () => (/* binding */ _stringify),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   args: () => (/* binding */ args),\n/* harmony export */   argsAsync: () => (/* binding */ argsAsync),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayAsync: () => (/* binding */ arrayAsync),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   awaitAsync: () => (/* binding */ awaitAsync),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   bic: () => (/* binding */ bic),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   blob: () => (/* binding */ blob),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   check: () => (/* binding */ check),\n/* harmony export */   checkAsync: () => (/* binding */ checkAsync),\n/* harmony export */   checkItems: () => (/* binding */ checkItems),\n/* harmony export */   checkItemsAsync: () => (/* binding */ checkItemsAsync),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   creditCard: () => (/* binding */ creditCard),\n/* harmony export */   cuid2: () => (/* binding */ cuid2),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   customAsync: () => (/* binding */ customAsync),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   decimal: () => (/* binding */ decimal),\n/* harmony export */   deleteGlobalConfig: () => (/* binding */ deleteGlobalConfig),\n/* harmony export */   deleteGlobalMessage: () => (/* binding */ deleteGlobalMessage),\n/* harmony export */   deleteSchemaMessage: () => (/* binding */ deleteSchemaMessage),\n/* harmony export */   deleteSpecificMessage: () => (/* binding */ deleteSpecificMessage),\n/* harmony export */   description: () => (/* binding */ description),\n/* harmony export */   digits: () => (/* binding */ digits),\n/* harmony export */   email: () => (/* binding */ email),\n/* harmony export */   emoji: () => (/* binding */ emoji),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   entriesFromList: () => (/* binding */ entriesFromList),\n/* harmony export */   entriesFromObjects: () => (/* binding */ entriesFromObjects),\n/* harmony export */   \"enum\": () => (/* binding */ enum_),\n/* harmony export */   enum_: () => (/* binding */ enum_),\n/* harmony export */   everyItem: () => (/* binding */ everyItem),\n/* harmony export */   exactOptional: () => (/* binding */ exactOptional),\n/* harmony export */   exactOptionalAsync: () => (/* binding */ exactOptionalAsync),\n/* harmony export */   excludes: () => (/* binding */ excludes),\n/* harmony export */   fallback: () => (/* binding */ fallback),\n/* harmony export */   fallbackAsync: () => (/* binding */ fallbackAsync),\n/* harmony export */   file: () => (/* binding */ file),\n/* harmony export */   filterItems: () => (/* binding */ filterItems),\n/* harmony export */   findItem: () => (/* binding */ findItem),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   flavor: () => (/* binding */ flavor),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   forwardAsync: () => (/* binding */ forwardAsync),\n/* harmony export */   \"function\": () => (/* binding */ function_),\n/* harmony export */   function_: () => (/* binding */ function_),\n/* harmony export */   getDefault: () => (/* binding */ getDefault),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getDefaultsAsync: () => (/* binding */ getDefaultsAsync),\n/* harmony export */   getDescription: () => (/* binding */ getDescription),\n/* harmony export */   getDotPath: () => (/* binding */ getDotPath),\n/* harmony export */   getFallback: () => (/* binding */ getFallback),\n/* harmony export */   getFallbacks: () => (/* binding */ getFallbacks),\n/* harmony export */   getFallbacksAsync: () => (/* binding */ getFallbacksAsync),\n/* harmony export */   getGlobalConfig: () => (/* binding */ getGlobalConfig),\n/* harmony export */   getGlobalMessage: () => (/* binding */ getGlobalMessage),\n/* harmony export */   getMetadata: () => (/* binding */ getMetadata),\n/* harmony export */   getSchemaMessage: () => (/* binding */ getSchemaMessage),\n/* harmony export */   getSpecificMessage: () => (/* binding */ getSpecificMessage),\n/* harmony export */   getTitle: () => (/* binding */ getTitle),\n/* harmony export */   graphemes: () => (/* binding */ graphemes),\n/* harmony export */   gtValue: () => (/* binding */ gtValue),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   hexColor: () => (/* binding */ hexColor),\n/* harmony export */   hexadecimal: () => (/* binding */ hexadecimal),\n/* harmony export */   imei: () => (/* binding */ imei),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersect: () => (/* binding */ intersect),\n/* harmony export */   intersectAsync: () => (/* binding */ intersectAsync),\n/* harmony export */   ip: () => (/* binding */ ip),\n/* harmony export */   ipv4: () => (/* binding */ ipv4),\n/* harmony export */   ipv6: () => (/* binding */ ipv6),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isOfKind: () => (/* binding */ isOfKind),\n/* harmony export */   isOfType: () => (/* binding */ isOfType),\n/* harmony export */   isValiError: () => (/* binding */ isValiError),\n/* harmony export */   isoDate: () => (/* binding */ isoDate),\n/* harmony export */   isoDateTime: () => (/* binding */ isoDateTime),\n/* harmony export */   isoTime: () => (/* binding */ isoTime),\n/* harmony export */   isoTimeSecond: () => (/* binding */ isoTimeSecond),\n/* harmony export */   isoTimestamp: () => (/* binding */ isoTimestamp),\n/* harmony export */   isoWeek: () => (/* binding */ isoWeek),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   lazyAsync: () => (/* binding */ lazyAsync),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   looseObject: () => (/* binding */ looseObject),\n/* harmony export */   looseObjectAsync: () => (/* binding */ looseObjectAsync),\n/* harmony export */   looseTuple: () => (/* binding */ looseTuple),\n/* harmony export */   looseTupleAsync: () => (/* binding */ looseTupleAsync),\n/* harmony export */   ltValue: () => (/* binding */ ltValue),\n/* harmony export */   mac: () => (/* binding */ mac),\n/* harmony export */   mac48: () => (/* binding */ mac48),\n/* harmony export */   mac64: () => (/* binding */ mac64),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAsync: () => (/* binding */ mapAsync),\n/* harmony export */   mapItems: () => (/* binding */ mapItems),\n/* harmony export */   maxBytes: () => (/* binding */ maxBytes),\n/* harmony export */   maxEntries: () => (/* binding */ maxEntries),\n/* harmony export */   maxGraphemes: () => (/* binding */ maxGraphemes),\n/* harmony export */   maxLength: () => (/* binding */ maxLength),\n/* harmony export */   maxSize: () => (/* binding */ maxSize),\n/* harmony export */   maxValue: () => (/* binding */ maxValue),\n/* harmony export */   maxWords: () => (/* binding */ maxWords),\n/* harmony export */   message: () => (/* binding */ message),\n/* harmony export */   metadata: () => (/* binding */ metadata),\n/* harmony export */   mimeType: () => (/* binding */ mimeType),\n/* harmony export */   minBytes: () => (/* binding */ minBytes),\n/* harmony export */   minEntries: () => (/* binding */ minEntries),\n/* harmony export */   minGraphemes: () => (/* binding */ minGraphemes),\n/* harmony export */   minLength: () => (/* binding */ minLength),\n/* harmony export */   minSize: () => (/* binding */ minSize),\n/* harmony export */   minValue: () => (/* binding */ minValue),\n/* harmony export */   minWords: () => (/* binding */ minWords),\n/* harmony export */   multipleOf: () => (/* binding */ multipleOf),\n/* harmony export */   nan: () => (/* binding */ nan),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonEmpty: () => (/* binding */ nonEmpty),\n/* harmony export */   nonNullable: () => (/* binding */ nonNullable),\n/* harmony export */   nonNullableAsync: () => (/* binding */ nonNullableAsync),\n/* harmony export */   nonNullish: () => (/* binding */ nonNullish),\n/* harmony export */   nonNullishAsync: () => (/* binding */ nonNullishAsync),\n/* harmony export */   nonOptional: () => (/* binding */ nonOptional),\n/* harmony export */   nonOptionalAsync: () => (/* binding */ nonOptionalAsync),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   notBytes: () => (/* binding */ notBytes),\n/* harmony export */   notEntries: () => (/* binding */ notEntries),\n/* harmony export */   notGraphemes: () => (/* binding */ notGraphemes),\n/* harmony export */   notLength: () => (/* binding */ notLength),\n/* harmony export */   notSize: () => (/* binding */ notSize),\n/* harmony export */   notValue: () => (/* binding */ notValue),\n/* harmony export */   notValues: () => (/* binding */ notValues),\n/* harmony export */   notWords: () => (/* binding */ notWords),\n/* harmony export */   \"null\": () => (/* binding */ null_),\n/* harmony export */   null_: () => (/* binding */ null_),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   nullableAsync: () => (/* binding */ nullableAsync),\n/* harmony export */   nullish: () => (/* binding */ nullish),\n/* harmony export */   nullishAsync: () => (/* binding */ nullishAsync),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   objectAsync: () => (/* binding */ objectAsync),\n/* harmony export */   objectWithRest: () => (/* binding */ objectWithRest),\n/* harmony export */   objectWithRestAsync: () => (/* binding */ objectWithRestAsync),\n/* harmony export */   octal: () => (/* binding */ octal),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   optionalAsync: () => (/* binding */ optionalAsync),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseAsync: () => (/* binding */ parseAsync),\n/* harmony export */   parseJson: () => (/* binding */ parseJson),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   parserAsync: () => (/* binding */ parserAsync),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   partialAsync: () => (/* binding */ partialAsync),\n/* harmony export */   partialCheck: () => (/* binding */ partialCheck),\n/* harmony export */   partialCheckAsync: () => (/* binding */ partialCheckAsync),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   picklist: () => (/* binding */ picklist),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   pipeAsync: () => (/* binding */ pipeAsync),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   rawCheck: () => (/* binding */ rawCheck),\n/* harmony export */   rawCheckAsync: () => (/* binding */ rawCheckAsync),\n/* harmony export */   rawTransform: () => (/* binding */ rawTransform),\n/* harmony export */   rawTransformAsync: () => (/* binding */ rawTransformAsync),\n/* harmony export */   readonly: () => (/* binding */ readonly),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recordAsync: () => (/* binding */ recordAsync),\n/* harmony export */   reduceItems: () => (/* binding */ reduceItems),\n/* harmony export */   regex: () => (/* binding */ regex),\n/* harmony export */   required: () => (/* binding */ required),\n/* harmony export */   requiredAsync: () => (/* binding */ requiredAsync),\n/* harmony export */   returns: () => (/* binding */ returns),\n/* harmony export */   returnsAsync: () => (/* binding */ returnsAsync),\n/* harmony export */   rfcEmail: () => (/* binding */ rfcEmail),\n/* harmony export */   safeInteger: () => (/* binding */ safeInteger),\n/* harmony export */   safeParse: () => (/* binding */ safeParse),\n/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync),\n/* harmony export */   safeParser: () => (/* binding */ safeParser),\n/* harmony export */   safeParserAsync: () => (/* binding */ safeParserAsync),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAsync: () => (/* binding */ setAsync),\n/* harmony export */   setGlobalConfig: () => (/* binding */ setGlobalConfig),\n/* harmony export */   setGlobalMessage: () => (/* binding */ setGlobalMessage),\n/* harmony export */   setSchemaMessage: () => (/* binding */ setSchemaMessage),\n/* harmony export */   setSpecificMessage: () => (/* binding */ setSpecificMessage),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slug: () => (/* binding */ slug),\n/* harmony export */   someItem: () => (/* binding */ someItem),\n/* harmony export */   sortItems: () => (/* binding */ sortItems),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   strictObject: () => (/* binding */ strictObject),\n/* harmony export */   strictObjectAsync: () => (/* binding */ strictObjectAsync),\n/* harmony export */   strictTuple: () => (/* binding */ strictTuple),\n/* harmony export */   strictTupleAsync: () => (/* binding */ strictTupleAsync),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   stringifyJson: () => (/* binding */ stringifyJson),\n/* harmony export */   summarize: () => (/* binding */ summarize),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   title: () => (/* binding */ title),\n/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),\n/* harmony export */   toMaxValue: () => (/* binding */ toMaxValue),\n/* harmony export */   toMinValue: () => (/* binding */ toMinValue),\n/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformAsync: () => (/* binding */ transformAsync),\n/* harmony export */   trim: () => (/* binding */ trim),\n/* harmony export */   trimEnd: () => (/* binding */ trimEnd),\n/* harmony export */   trimStart: () => (/* binding */ trimStart),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupleAsync: () => (/* binding */ tupleAsync),\n/* harmony export */   tupleWithRest: () => (/* binding */ tupleWithRest),\n/* harmony export */   tupleWithRestAsync: () => (/* binding */ tupleWithRestAsync),\n/* harmony export */   ulid: () => (/* binding */ ulid),\n/* harmony export */   undefined: () => (/* binding */ undefined_),\n/* harmony export */   undefined_: () => (/* binding */ undefined_),\n/* harmony export */   undefinedable: () => (/* binding */ undefinedable),\n/* harmony export */   undefinedableAsync: () => (/* binding */ undefinedableAsync),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionAsync: () => (/* binding */ unionAsync),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   values: () => (/* binding */ values),\n/* harmony export */   variant: () => (/* binding */ variant),\n/* harmony export */   variantAsync: () => (/* binding */ variantAsync),\n/* harmony export */   \"void\": () => (/* binding */ void_),\n/* harmony export */   void_: () => (/* binding */ void_),\n/* harmony export */   words: () => (/* binding */ words)\n/* harmony export */ });\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n    store = {\n        ...store,\n        ...config2\n    };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n    return {\n        lang: config2?.lang ?? store?.lang,\n        message: config2?.message,\n        abortEarly: config2?.abortEarly ?? store?.abortEarly,\n        abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n    };\n}\nfunction deleteGlobalConfig() {\n    store = void 0;\n}\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message2, lang) {\n    if (!store2) store2 = /* @__PURE__ */ new Map();\n    store2.set(lang, message2);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n    return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n    store2?.delete(lang);\n}\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message2, lang) {\n    if (!store3) store3 = /* @__PURE__ */ new Map();\n    store3.set(lang, message2);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n    return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n    store3?.delete(lang);\n}\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message2, lang) {\n    if (!store4) store4 = /* @__PURE__ */ new Map();\n    if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n    store4.get(reference).set(lang, message2);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n    return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n    store4?.get(reference)?.delete(lang);\n}\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n    const type = typeof input;\n    if (type === \"string\") {\n        return `\"${input}\"`;\n    }\n    if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n        return `${input}`;\n    }\n    if (type === \"object\" || type === \"function\") {\n        return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n    }\n    return type;\n}\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n    const input = other && \"input\" in other ? other.input : dataset.value;\n    const expected = other?.expected ?? context.expects ?? null;\n    const received = other?.received ?? _stringify(input);\n    const issue = {\n        kind: context.kind,\n        type: context.type,\n        input,\n        expected,\n        received,\n        message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n        requirement: context.requirement,\n        path: other?.path,\n        issues: other?.issues,\n        lang: config2.lang,\n        abortEarly: config2.abortEarly,\n        abortPipeEarly: config2.abortPipeEarly\n    };\n    const isSchema = context.kind === \"schema\";\n    const message2 = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n    if (message2 !== void 0) {\n        issue.message = typeof message2 === \"function\" ? // @ts-expect-error\n        message2(issue) : message2;\n    }\n    if (isSchema) {\n        dataset.typed = false;\n    }\n    if (dataset.issues) {\n        dataset.issues.push(issue);\n    } else {\n        dataset.issues = [\n            issue\n        ];\n    }\n}\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n    if (!textEncoder) {\n        textEncoder = new TextEncoder();\n    }\n    return textEncoder.encode(input).length;\n}\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n    if (!segmenter) {\n        segmenter = new Intl.Segmenter();\n    }\n    const segments = segmenter.segment(input);\n    let count = 0;\n    for (const _ of segments){\n        count++;\n    }\n    return count;\n}\n// src/utils/_getLastMetadata/_getLastMetadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getLastMetadata(schema, type) {\n    if (\"pipe\" in schema) {\n        const nestedSchemas = [];\n        for(let index = schema.pipe.length - 1; index >= 0; index--){\n            const item = schema.pipe[index];\n            if (item.kind === \"schema\" && \"pipe\" in item) {\n                nestedSchemas.push(item);\n            } else if (item.kind === \"metadata\" && item.type === type) {\n                return item[type];\n            }\n        }\n        for (const nestedSchema of nestedSchemas){\n            const result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);\n            if (result !== void 0) {\n                return result;\n            }\n        }\n    }\n}\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n    return {\n        version: 1,\n        vendor: \"valibot\",\n        validate (value2) {\n            return context[\"~run\"]({\n                value: value2\n            }, getGlobalConfig());\n        }\n    };\n}\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n    if (!store5) {\n        store5 = /* @__PURE__ */ new Map();\n    }\n    if (!store5.get(locales)) {\n        store5.set(locales, new Intl.Segmenter(locales, {\n            granularity: \"word\"\n        }));\n    }\n    const segments = store5.get(locales).segment(input);\n    let count = 0;\n    for (const segment of segments){\n        if (segment.isWordLike) {\n            count++;\n        }\n    }\n    return count;\n}\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n    const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n    let length2 = number2.length;\n    let bit = 1;\n    let sum = 0;\n    while(length2){\n        const value2 = +number2[--length2];\n        bit ^= 1;\n        sum += bit ? [\n            0,\n            2,\n            4,\n            6,\n            8,\n            1,\n            3,\n            5,\n            7,\n            9\n        ][value2] : value2;\n    }\n    return sum % 10 === 0;\n}\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n    return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values2, separator) {\n    const list = [\n        ...new Set(values2)\n    ];\n    if (list.length > 1) {\n        return `(${list.join(` ${separator} `)})`;\n    }\n    return list[0] ?? \"never\";\n}\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n    const entries2 = {};\n    for (const key of list){\n        entries2[key] = schema;\n    }\n    return entries2;\n}\n// src/utils/entriesFromObjects/entriesFromObjects.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromObjects(schemas) {\n    const entries2 = {};\n    for (const schema of schemas){\n        Object.assign(entries2, schema.entries);\n    }\n    return entries2;\n}\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n    if (issue.path) {\n        let key = \"\";\n        for (const item of issue.path){\n            if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n                if (key) {\n                    key += `.${item.key}`;\n                } else {\n                    key += item.key;\n                }\n            } else {\n                return null;\n            }\n        }\n        return key;\n    }\n    return null;\n}\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n    return object2.kind === kind;\n}\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n    return object2.type === type;\n}\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n    return error instanceof ValiError;\n}\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n    /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */ constructor(issues){\n        super(issues[0].message);\n        this.name = \"ValiError\";\n        this.issues = issues;\n    }\n};\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n    return {\n        kind: \"transformation\",\n        type: \"args\",\n        reference: args,\n        async: false,\n        schema,\n        \"~run\" (dataset, config2) {\n            const func = dataset.value;\n            dataset.value = (...args_)=>{\n                const argsDataset = this.schema[\"~run\"]({\n                    value: args_\n                }, config2);\n                if (argsDataset.issues) {\n                    throw new ValiError(argsDataset.issues);\n                }\n                return func(...argsDataset.value);\n            };\n            return dataset;\n        }\n    };\n}\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n    return {\n        kind: \"transformation\",\n        type: \"args\",\n        reference: argsAsync,\n        async: false,\n        schema,\n        \"~run\" (dataset, config2) {\n            const func = dataset.value;\n            dataset.value = async (...args2)=>{\n                const argsDataset = await schema[\"~run\"]({\n                    value: args2\n                }, config2);\n                if (argsDataset.issues) {\n                    throw new ValiError(argsDataset.issues);\n                }\n                return func(...argsDataset.value);\n            };\n            return dataset;\n        }\n    };\n}\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n    return {\n        kind: \"transformation\",\n        type: \"await\",\n        reference: awaitAsync,\n        async: true,\n        async \"~run\" (dataset) {\n            dataset.value = await dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n/^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n/^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = // eslint-disable-next-line regexp/prefer-w, no-useless-escape, regexp/no-useless-escape, regexp/require-unicode-regexp\n/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message2) {\n    return {\n        kind: \"validation\",\n        type: \"base64\",\n        reference: base64,\n        async: false,\n        expects: null,\n        requirement: BASE64_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"Base64\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message2) {\n    return {\n        kind: \"validation\",\n        type: \"bic\",\n        reference: bic,\n        async: false,\n        expects: null,\n        requirement: BIC_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"BIC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n    return {\n        kind: \"transformation\",\n        type: \"brand\",\n        reference: brand,\n        async: false,\n        name,\n        \"~run\" (dataset) {\n            return dataset;\n        }\n    };\n}\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"bytes\",\n        reference: bytes,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = _getByteCount(dataset.value);\n                if (length2 !== this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"check\",\n        reference: check,\n        async: false,\n        expects: null,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"check\",\n        reference: checkAsync,\n        async: true,\n        expects: null,\n        requirement,\n        message: message2,\n        async \"~run\" (dataset, config2) {\n            if (dataset.typed && !await this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"check_items\",\n        reference: checkItems,\n        async: false,\n        expects: null,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                for(let index = 0; index < dataset.value.length; index++){\n                    const item = dataset.value[index];\n                    if (!this.requirement(item, index, dataset.value)) {\n                        _addIssue(this, \"item\", dataset, config2, {\n                            input: item,\n                            path: [\n                                {\n                                    type: \"array\",\n                                    origin: \"value\",\n                                    input: dataset.value,\n                                    key: index,\n                                    value: item\n                                }\n                            ]\n                        });\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"check_items\",\n        reference: checkItemsAsync,\n        async: true,\n        expects: null,\n        requirement,\n        message: message2,\n        async \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const requirementResults = await Promise.all(dataset.value.map(this.requirement));\n                for(let index = 0; index < dataset.value.length; index++){\n                    if (!requirementResults[index]) {\n                        const item = dataset.value[index];\n                        _addIssue(this, \"item\", dataset, config2, {\n                            input: item,\n                            path: [\n                                {\n                                    type: \"array\",\n                                    origin: \"value\",\n                                    input: dataset.value,\n                                    key: index,\n                                    value: item\n                                }\n                            ]\n                        });\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n    // American Express\n    /^3[47]\\d{13}$/u,\n    // Diners Club\n    /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n    // Discover\n    /^6(?:011|5\\d{2})\\d{12,15}$/u,\n    // JCB\n    /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n    // Mastercard\n    // eslint-disable-next-line redos-detector/no-unsafe-regex\n    /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n    // UnionPay\n    /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n    // Visa\n    /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message2) {\n    return {\n        kind: \"validation\",\n        type: \"credit_card\",\n        reference: creditCard,\n        async: false,\n        expects: null,\n        requirement (input) {\n            let sanitized;\n            return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n            (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n            PROVIDER_REGEX_LIST.some((regex2)=>regex2.test(sanitized)) && // Check if passes luhn algorithm\n            _isLuhnAlgo(sanitized);\n        },\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"credit card\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message2) {\n    return {\n        kind: \"validation\",\n        type: \"cuid2\",\n        reference: cuid2,\n        async: false,\n        expects: null,\n        requirement: CUID2_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"Cuid2\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message2) {\n    return {\n        kind: \"validation\",\n        type: \"decimal\",\n        reference: decimal,\n        async: false,\n        expects: null,\n        requirement: DECIMAL_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"decimal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n    return {\n        kind: \"metadata\",\n        type: \"description\",\n        reference: description,\n        description: description_\n    };\n}\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message2) {\n    return {\n        kind: \"validation\",\n        type: \"digits\",\n        reference: digits,\n        async: false,\n        expects: null,\n        requirement: DIGITS_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"digits\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message2) {\n    return {\n        kind: \"validation\",\n        type: \"email\",\n        reference: email,\n        expects: null,\n        async: false,\n        requirement: EMAIL_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"email\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message2) {\n    return {\n        kind: \"validation\",\n        type: \"emoji\",\n        reference: emoji,\n        async: false,\n        expects: null,\n        requirement: EMOJI_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"emoji\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message2) {\n    return {\n        kind: \"validation\",\n        type: \"empty\",\n        reference: empty,\n        async: false,\n        expects: \"0\",\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.length > 0) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"ends_with\",\n        reference: endsWith,\n        async: false,\n        expects: `\"${requirement}\"`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n                _addIssue(this, \"end\", dataset, config2, {\n                    received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/entries/entries.ts\n// @__NO_SIDE_EFFECTS__\nfunction entries(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"entries\",\n        reference: entries,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (!dataset.typed) return dataset;\n            const count = Object.keys(dataset.value).length;\n            if (dataset.typed && count !== this.requirement) {\n                _addIssue(this, \"entries\", dataset, config2, {\n                    received: `${count}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"every_item\",\n        reference: everyItem,\n        async: false,\n        expects: null,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !dataset.value.every(this.requirement)) {\n                _addIssue(this, \"item\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message2) {\n    const received = _stringify(requirement);\n    return {\n        kind: \"validation\",\n        type: \"excludes\",\n        reference: excludes,\n        async: false,\n        expects: `!${received}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.includes(this.requirement)) {\n                _addIssue(this, \"content\", dataset, config2, {\n                    received\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"filter_items\",\n        reference: filterItems,\n        async: false,\n        operation,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.filter(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"find_item\",\n        reference: findItem,\n        async: false,\n        operation,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.find(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message2) {\n    return {\n        kind: \"validation\",\n        type: \"finite\",\n        reference: finite,\n        async: false,\n        expects: null,\n        requirement: Number.isFinite,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"finite\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/flavor/flavor.ts\n// @__NO_SIDE_EFFECTS__\nfunction flavor(name) {\n    return {\n        kind: \"transformation\",\n        type: \"flavor\",\n        reference: flavor,\n        async: false,\n        name,\n        \"~run\" (dataset) {\n            return dataset;\n        }\n    };\n}\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"graphemes\",\n        reference: graphemes,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const count = _getGraphemeCount(dataset.value);\n                if (count !== this.requirement) {\n                    _addIssue(this, \"graphemes\", dataset, config2, {\n                        received: `${count}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/gtValue/gtValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction gtValue(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"gt_value\",\n        reference: gtValue,\n        async: false,\n        expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !(dataset.value > this.requirement)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n    md4: 32,\n    md5: 32,\n    sha1: 40,\n    sha256: 64,\n    sha384: 96,\n    sha512: 128,\n    ripemd128: 32,\n    ripemd160: 40,\n    tiger128: 32,\n    tiger160: 40,\n    tiger192: 48,\n    crc32: 8,\n    crc32b: 8,\n    adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message2) {\n    return {\n        kind: \"validation\",\n        type: \"hash\",\n        reference: hash,\n        expects: null,\n        async: false,\n        requirement: RegExp(types.map((type)=>`^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hash\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message2) {\n    return {\n        kind: \"validation\",\n        type: \"hexadecimal\",\n        reference: hexadecimal,\n        async: false,\n        expects: null,\n        requirement: HEXADECIMAL_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hexadecimal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message2) {\n    return {\n        kind: \"validation\",\n        type: \"hex_color\",\n        reference: hexColor,\n        async: false,\n        expects: null,\n        requirement: HEX_COLOR_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hex color\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message2) {\n    return {\n        kind: \"validation\",\n        type: \"imei\",\n        reference: imei,\n        async: false,\n        expects: null,\n        requirement (input) {\n            return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n        },\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"IMEI\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message2) {\n    const expects = _stringify(requirement);\n    return {\n        kind: \"validation\",\n        type: \"includes\",\n        reference: includes,\n        async: false,\n        expects,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !dataset.value.includes(this.requirement)) {\n                _addIssue(this, \"content\", dataset, config2, {\n                    received: `!${expects}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message2) {\n    return {\n        kind: \"validation\",\n        type: \"integer\",\n        reference: integer,\n        async: false,\n        expects: null,\n        requirement: Number.isInteger,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"integer\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message2) {\n    return {\n        kind: \"validation\",\n        type: \"ip\",\n        reference: ip,\n        async: false,\n        expects: null,\n        requirement: IP_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IP\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message2) {\n    return {\n        kind: \"validation\",\n        type: \"ipv4\",\n        reference: ipv4,\n        async: false,\n        expects: null,\n        requirement: IPV4_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IPv4\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message2) {\n    return {\n        kind: \"validation\",\n        type: \"ipv6\",\n        reference: ipv6,\n        async: false,\n        expects: null,\n        requirement: IPV6_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IPv6\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message2) {\n    return {\n        kind: \"validation\",\n        type: \"iso_date\",\n        reference: isoDate,\n        async: false,\n        expects: null,\n        requirement: ISO_DATE_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"date\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message2) {\n    return {\n        kind: \"validation\",\n        type: \"iso_date_time\",\n        reference: isoDateTime,\n        async: false,\n        expects: null,\n        requirement: ISO_DATE_TIME_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"date-time\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message2) {\n    return {\n        kind: \"validation\",\n        type: \"iso_time\",\n        reference: isoTime,\n        async: false,\n        expects: null,\n        requirement: ISO_TIME_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"time\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message2) {\n    return {\n        kind: \"validation\",\n        type: \"iso_time_second\",\n        reference: isoTimeSecond,\n        async: false,\n        expects: null,\n        requirement: ISO_TIME_SECOND_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"time-second\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message2) {\n    return {\n        kind: \"validation\",\n        type: \"iso_timestamp\",\n        reference: isoTimestamp,\n        async: false,\n        expects: null,\n        requirement: ISO_TIMESTAMP_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"timestamp\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message2) {\n    return {\n        kind: \"validation\",\n        type: \"iso_week\",\n        reference: isoWeek,\n        async: false,\n        expects: null,\n        requirement: ISO_WEEK_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"week\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"length\",\n        reference: length,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.length !== this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ltValue/ltValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction ltValue(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"lt_value\",\n        reference: ltValue,\n        async: false,\n        expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !(dataset.value < this.requirement)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message2) {\n    return {\n        kind: \"validation\",\n        type: \"mac\",\n        reference: mac,\n        async: false,\n        expects: null,\n        requirement: MAC_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message2) {\n    return {\n        kind: \"validation\",\n        type: \"mac48\",\n        reference: mac48,\n        async: false,\n        expects: null,\n        requirement: MAC48_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"48-bit MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message2) {\n    return {\n        kind: \"validation\",\n        type: \"mac64\",\n        reference: mac64,\n        async: false,\n        expects: null,\n        requirement: MAC64_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"64-bit MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"map_items\",\n        reference: mapItems,\n        async: false,\n        operation,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.map(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"max_bytes\",\n        reference: maxBytes,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = _getByteCount(dataset.value);\n                if (length2 > this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxEntries/maxEntries.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxEntries(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"max_entries\",\n        reference: maxEntries,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (!dataset.typed) return dataset;\n            const count = Object.keys(dataset.value).length;\n            if (dataset.typed && count > this.requirement) {\n                _addIssue(this, \"entries\", dataset, config2, {\n                    received: `${count}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"max_graphemes\",\n        reference: maxGraphemes,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const count = _getGraphemeCount(dataset.value);\n                if (count > this.requirement) {\n                    _addIssue(this, \"graphemes\", dataset, config2, {\n                        received: `${count}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"max_length\",\n        reference: maxLength,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.length > this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"max_size\",\n        reference: maxSize,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.size > this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"max_value\",\n        reference: maxValue,\n        async: false,\n        expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !(dataset.value <= this.requirement)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"max_words\",\n        reference: maxWords,\n        async: false,\n        expects: `<=${requirement}`,\n        locales,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const count = _getWordCount(this.locales, dataset.value);\n                if (count > this.requirement) {\n                    _addIssue(this, \"words\", dataset, config2, {\n                        received: `${count}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n    return {\n        kind: \"metadata\",\n        type: \"metadata\",\n        reference: metadata,\n        metadata: metadata_\n    };\n}\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"mime_type\",\n        reference: mimeType,\n        async: false,\n        expects: _joinExpects(requirement.map((option)=>`\"${option}\"`), \"|\"),\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n                _addIssue(this, \"MIME type\", dataset, config2, {\n                    received: `\"${dataset.value.type}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"min_bytes\",\n        reference: minBytes,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = _getByteCount(dataset.value);\n                if (length2 < this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minEntries/minEntries.ts\n// @__NO_SIDE_EFFECTS__\nfunction minEntries(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"min_entries\",\n        reference: minEntries,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (!dataset.typed) return dataset;\n            const count = Object.keys(dataset.value).length;\n            if (dataset.typed && count < this.requirement) {\n                _addIssue(this, \"entries\", dataset, config2, {\n                    received: `${count}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"min_graphemes\",\n        reference: minGraphemes,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const count = _getGraphemeCount(dataset.value);\n                if (count < this.requirement) {\n                    _addIssue(this, \"graphemes\", dataset, config2, {\n                        received: `${count}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"min_length\",\n        reference: minLength,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.length < this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"min_size\",\n        reference: minSize,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.size < this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"min_value\",\n        reference: minValue,\n        async: false,\n        expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !(dataset.value >= this.requirement)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"min_words\",\n        reference: minWords,\n        async: false,\n        expects: `>=${requirement}`,\n        locales,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const count = _getWordCount(this.locales, dataset.value);\n                if (count < this.requirement) {\n                    _addIssue(this, \"words\", dataset, config2, {\n                        received: `${count}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"multiple_of\",\n        reference: multipleOf,\n        async: false,\n        expects: `%${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value % this.requirement != 0) {\n                _addIssue(this, \"multiple\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message2) {\n    return {\n        kind: \"validation\",\n        type: \"nanoid\",\n        reference: nanoid,\n        async: false,\n        expects: null,\n        requirement: NANO_ID_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"Nano ID\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message2) {\n    return {\n        kind: \"validation\",\n        type: \"non_empty\",\n        reference: nonEmpty,\n        async: false,\n        expects: \"!0\",\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.length === 0) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: \"0\"\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n    return {\n        kind: \"transformation\",\n        type: \"normalize\",\n        reference: normalize,\n        async: false,\n        form,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.normalize(this.form);\n            return dataset;\n        }\n    };\n}\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"not_bytes\",\n        reference: notBytes,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = _getByteCount(dataset.value);\n                if (length2 === this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notEntries/notEntries.ts\n// @__NO_SIDE_EFFECTS__\nfunction notEntries(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"not_entries\",\n        reference: notEntries,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (!dataset.typed) return dataset;\n            const count = Object.keys(dataset.value).length;\n            if (dataset.typed && count === this.requirement) {\n                _addIssue(this, \"entries\", dataset, config2, {\n                    received: `${count}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"not_graphemes\",\n        reference: notGraphemes,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const count = _getGraphemeCount(dataset.value);\n                if (count === this.requirement) {\n                    _addIssue(this, \"graphemes\", dataset, config2, {\n                        received: `${count}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"not_length\",\n        reference: notLength,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.length === this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"not_size\",\n        reference: notSize,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.size === this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"not_value\",\n        reference: notValue,\n        async: false,\n        expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notValues/notValues.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValues(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"not_values\",\n        reference: notValues,\n        async: false,\n        expects: `!${_joinExpects(requirement.map((value2)=>value2 instanceof Date ? value2.toJSON() : _stringify(value2)), \"|\")}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && this.requirement.some((value2)=>value2 <= dataset.value && value2 >= dataset.value)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"not_words\",\n        reference: notWords,\n        async: false,\n        expects: `!${requirement}`,\n        locales,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const count = _getWordCount(this.locales, dataset.value);\n                if (count === this.requirement) {\n                    _addIssue(this, \"words\", dataset, config2, {\n                        received: `${count}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message2) {\n    return {\n        kind: \"validation\",\n        type: \"octal\",\n        reference: octal,\n        async: false,\n        expects: null,\n        requirement: OCTAL_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"octal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/parseJson/parseJson.ts\n// @__NO_SIDE_EFFECTS__\nfunction parseJson(config2, message2) {\n    return {\n        kind: \"transformation\",\n        type: \"parse_json\",\n        reference: parseJson,\n        config: config2,\n        message: message2,\n        async: false,\n        \"~run\" (dataset, config3) {\n            try {\n                dataset.value = JSON.parse(dataset.value, this.config?.reviver);\n            } catch (error) {\n                if (error instanceof Error) {\n                    _addIssue(this, \"JSON\", dataset, config3, {\n                        received: `\"${error.message}\"`\n                    });\n                    dataset.typed = false;\n                } else {\n                    throw error;\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, paths) {\n    if (dataset.issues) {\n        for (const path of paths){\n            for (const issue of dataset.issues){\n                let typed = false;\n                const bound = Math.min(path.length, issue.path?.length ?? 0);\n                for(let index = 0; index < bound; index++){\n                    if (// @ts-expect-error\n                    path[index] !== issue.path[index].key && // @ts-expect-error\n                    (path[index] !== \"$\" || issue.path[index].type !== \"array\")) {\n                        typed = true;\n                        break;\n                    }\n                }\n                if (!typed) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(paths, requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"partial_check\",\n        reference: partialCheck,\n        async: false,\n        expects: null,\n        paths,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n            !this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(paths, requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"partial_check\",\n        reference: partialCheckAsync,\n        async: true,\n        expects: null,\n        paths,\n        requirement,\n        message: message2,\n        async \"~run\" (dataset, config2) {\n            if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n            !await this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n    return {\n        kind: \"validation\",\n        type: \"raw_check\",\n        reference: rawCheck,\n        async: false,\n        expects: null,\n        \"~run\" (dataset, config2) {\n            action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n            });\n            return dataset;\n        }\n    };\n}\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n    return {\n        kind: \"validation\",\n        type: \"raw_check\",\n        reference: rawCheckAsync,\n        async: true,\n        expects: null,\n        async \"~run\" (dataset, config2) {\n            await action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n            });\n            return dataset;\n        }\n    };\n}\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n    return {\n        kind: \"transformation\",\n        type: \"raw_transform\",\n        reference: rawTransform,\n        async: false,\n        \"~run\" (dataset, config2) {\n            const output = action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n                NEVER: null\n            });\n            if (dataset.issues) {\n                dataset.typed = false;\n            } else {\n                dataset.value = output;\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n    return {\n        kind: \"transformation\",\n        type: \"raw_transform\",\n        reference: rawTransformAsync,\n        async: true,\n        async \"~run\" (dataset, config2) {\n            const output = await action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n                NEVER: null\n            });\n            if (dataset.issues) {\n                dataset.typed = false;\n            } else {\n                dataset.value = output;\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n    return {\n        kind: \"transformation\",\n        type: \"readonly\",\n        reference: readonly,\n        async: false,\n        \"~run\" (dataset) {\n            return dataset;\n        }\n    };\n}\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n    return {\n        kind: \"transformation\",\n        type: \"reduce_items\",\n        reference: reduceItems,\n        async: false,\n        operation,\n        initial,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.reduce(this.operation, this.initial);\n            return dataset;\n        }\n    };\n}\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"regex\",\n        reference: regex,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"format\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n    return {\n        kind: \"transformation\",\n        type: \"returns\",\n        reference: returns,\n        async: false,\n        schema,\n        \"~run\" (dataset, config2) {\n            const func = dataset.value;\n            dataset.value = (...args_)=>{\n                const returnsDataset = this.schema[\"~run\"]({\n                    value: func(...args_)\n                }, config2);\n                if (returnsDataset.issues) {\n                    throw new ValiError(returnsDataset.issues);\n                }\n                return returnsDataset.value;\n            };\n            return dataset;\n        }\n    };\n}\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n    return {\n        kind: \"transformation\",\n        type: \"returns\",\n        reference: returnsAsync,\n        async: false,\n        schema,\n        \"~run\" (dataset, config2) {\n            const func = dataset.value;\n            dataset.value = async (...args_)=>{\n                const returnsDataset = await this.schema[\"~run\"]({\n                    value: await func(...args_)\n                }, config2);\n                if (returnsDataset.issues) {\n                    throw new ValiError(returnsDataset.issues);\n                }\n                return returnsDataset.value;\n            };\n            return dataset;\n        }\n    };\n}\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message2) {\n    return {\n        kind: \"validation\",\n        type: \"rfc_email\",\n        reference: rfcEmail,\n        expects: null,\n        async: false,\n        requirement: RFC_EMAIL_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"email\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message2) {\n    return {\n        kind: \"validation\",\n        type: \"safe_integer\",\n        reference: safeInteger,\n        async: false,\n        expects: null,\n        requirement: Number.isSafeInteger,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"safe integer\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"size\",\n        reference: size,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && dataset.value.size !== this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/slug/slug.ts\n// @__NO_SIDE_EFFECTS__\nfunction slug(message2) {\n    return {\n        kind: \"validation\",\n        type: \"slug\",\n        reference: slug,\n        async: false,\n        expects: null,\n        requirement: SLUG_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"slug\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"some_item\",\n        reference: someItem,\n        async: false,\n        expects: null,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !dataset.value.some(this.requirement)) {\n                _addIssue(this, \"item\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"sort_items\",\n        reference: sortItems,\n        async: false,\n        operation,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.sort(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"starts_with\",\n        reference: startsWith,\n        async: false,\n        expects: `\"${requirement}\"`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n                _addIssue(this, \"start\", dataset, config2, {\n                    received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/stringifyJson/stringifyJson.ts\n// @__NO_SIDE_EFFECTS__\nfunction stringifyJson(config2, message2) {\n    return {\n        kind: \"transformation\",\n        type: \"stringify_json\",\n        reference: stringifyJson,\n        message: message2,\n        config: config2,\n        async: false,\n        \"~run\" (dataset, config3) {\n            try {\n                const output = JSON.stringify(dataset.value, // @ts-expect-error\n                this.config?.replacer, this.config?.space);\n                if (output === void 0) {\n                    _addIssue(this, \"JSON\", dataset, config3);\n                    dataset.typed = false;\n                }\n                dataset.value = output;\n            } catch (error) {\n                if (error instanceof Error) {\n                    _addIssue(this, \"JSON\", dataset, config3, {\n                        received: `\"${error.message}\"`\n                    });\n                    dataset.typed = false;\n                } else {\n                    throw error;\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n    return {\n        kind: \"metadata\",\n        type: \"title\",\n        reference: title,\n        title: title_\n    };\n}\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n    return {\n        kind: \"transformation\",\n        type: \"to_lower_case\",\n        reference: toLowerCase,\n        async: false,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.toLowerCase();\n            return dataset;\n        }\n    };\n}\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n    return {\n        kind: \"transformation\",\n        type: \"to_max_value\",\n        reference: toMaxValue,\n        async: false,\n        requirement,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n    return {\n        kind: \"transformation\",\n        type: \"to_min_value\",\n        reference: toMinValue,\n        async: false,\n        requirement,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n    return {\n        kind: \"transformation\",\n        type: \"to_upper_case\",\n        reference: toUpperCase,\n        async: false,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.toUpperCase();\n            return dataset;\n        }\n    };\n}\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"transform\",\n        reference: transform,\n        async: false,\n        operation,\n        \"~run\" (dataset) {\n            dataset.value = this.operation(dataset.value);\n            return dataset;\n        }\n    };\n}\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"transform\",\n        reference: transformAsync,\n        async: true,\n        operation,\n        async \"~run\" (dataset) {\n            dataset.value = await this.operation(dataset.value);\n            return dataset;\n        }\n    };\n}\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n    return {\n        kind: \"transformation\",\n        type: \"trim\",\n        reference: trim,\n        async: false,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.trim();\n            return dataset;\n        }\n    };\n}\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n    return {\n        kind: \"transformation\",\n        type: \"trim_end\",\n        reference: trimEnd,\n        async: false,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.trimEnd();\n            return dataset;\n        }\n    };\n}\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n    return {\n        kind: \"transformation\",\n        type: \"trim_start\",\n        reference: trimStart,\n        async: false,\n        \"~run\" (dataset) {\n            dataset.value = dataset.value.trimStart();\n            return dataset;\n        }\n    };\n}\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message2) {\n    return {\n        kind: \"validation\",\n        type: \"ulid\",\n        reference: ulid,\n        async: false,\n        expects: null,\n        requirement: ULID_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"ULID\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message2) {\n    return {\n        kind: \"validation\",\n        type: \"url\",\n        reference: url,\n        async: false,\n        expects: null,\n        requirement (input) {\n            try {\n                new URL(input);\n                return true;\n            } catch  {\n                return false;\n            }\n        },\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"URL\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message2) {\n    return {\n        kind: \"validation\",\n        type: \"uuid\",\n        reference: uuid,\n        async: false,\n        expects: null,\n        requirement: UUID_REGEX,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"UUID\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"value\",\n        reference: value,\n        async: false,\n        expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/values/values.ts\n// @__NO_SIDE_EFFECTS__\nfunction values(requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"values\",\n        reference: values,\n        async: false,\n        expects: `${_joinExpects(requirement.map((value2)=>value2 instanceof Date ? value2.toJSON() : _stringify(value2)), \"|\")}`,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed && !this.requirement.some((value2)=>value2 <= dataset.value && value2 >= dataset.value)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message2) {\n    return {\n        kind: \"validation\",\n        type: \"words\",\n        reference: words,\n        async: false,\n        expects: `${requirement}`,\n        locales,\n        requirement,\n        message: message2,\n        \"~run\" (dataset, config2) {\n            if (dataset.typed) {\n                const count = _getWordCount(this.locales, dataset.value);\n                if (count !== this.requirement) {\n                    _addIssue(this, \"words\", dataset, config2, {\n                        received: `${count}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n    const issues = schema[\"~run\"]({\n        value: input\n    }, {\n        abortEarly: true\n    }).issues;\n    if (issues) {\n        throw new ValiError(issues);\n    }\n}\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n    return {\n        ...schema,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config_) {\n            return schema[\"~run\"](dataset, {\n                ...config_,\n                ...config2\n            });\n        }\n    };\n}\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n    return typeof schema.fallback === \"function\" ? // @ts-expect-error\n    schema.fallback(dataset, config2) : // @ts-expect-error\n    schema.fallback;\n}\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n    return {\n        ...schema,\n        fallback: fallback2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const outputDataset = schema[\"~run\"](dataset, config2);\n            return outputDataset.issues ? {\n                typed: true,\n                value: getFallback(this, outputDataset, config2)\n            } : outputDataset;\n        }\n    };\n}\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n    return {\n        ...schema,\n        fallback: fallback2,\n        async: true,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const outputDataset = await schema[\"~run\"](dataset, config2);\n            return outputDataset.issues ? {\n                typed: true,\n                value: await getFallback(this, outputDataset, config2)\n            } : outputDataset;\n        }\n    };\n}\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n    const flatErrors = {};\n    for (const issue of issues){\n        if (issue.path) {\n            const dotPath = getDotPath(issue);\n            if (dotPath) {\n                if (!flatErrors.nested) {\n                    flatErrors.nested = {};\n                }\n                if (flatErrors.nested[dotPath]) {\n                    flatErrors.nested[dotPath].push(issue.message);\n                } else {\n                    flatErrors.nested[dotPath] = [\n                        issue.message\n                    ];\n                }\n            } else {\n                if (flatErrors.other) {\n                    flatErrors.other.push(issue.message);\n                } else {\n                    flatErrors.other = [\n                        issue.message\n                    ];\n                }\n            }\n        } else {\n            if (flatErrors.root) {\n                flatErrors.root.push(issue.message);\n            } else {\n                flatErrors.root = [\n                    issue.message\n                ];\n            }\n        }\n    }\n    return flatErrors;\n}\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, path) {\n    return {\n        ...action,\n        \"~run\" (dataset, config2) {\n            const prevIssues = dataset.issues && [\n                ...dataset.issues\n            ];\n            dataset = action[\"~run\"](dataset, config2);\n            if (dataset.issues) {\n                for (const issue of dataset.issues){\n                    if (!prevIssues?.includes(issue)) {\n                        let pathInput = dataset.value;\n                        for (const key of path){\n                            const pathValue = pathInput[key];\n                            const pathItem = {\n                                type: \"unknown\",\n                                origin: \"value\",\n                                input: pathInput,\n                                key,\n                                value: pathValue\n                            };\n                            if (issue.path) {\n                                issue.path.push(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            if (!pathValue) {\n                                break;\n                            }\n                            pathInput = pathValue;\n                        }\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, path) {\n    return {\n        ...action,\n        async: true,\n        async \"~run\" (dataset, config2) {\n            const prevIssues = dataset.issues && [\n                ...dataset.issues\n            ];\n            dataset = await action[\"~run\"](dataset, config2);\n            if (dataset.issues) {\n                for (const issue of dataset.issues){\n                    if (!prevIssues?.includes(issue)) {\n                        let pathInput = dataset.value;\n                        for (const key of path){\n                            const pathValue = pathInput[key];\n                            const pathItem = {\n                                type: \"unknown\",\n                                origin: \"value\",\n                                input: pathInput,\n                                key,\n                                value: pathValue\n                            };\n                            if (issue.path) {\n                                issue.path.push(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            if (!pathValue) {\n                                break;\n                            }\n                            pathInput = pathValue;\n                        }\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n    return typeof schema.default === \"function\" ? // @ts-expect-error\n    schema.default(dataset, config2) : // @ts-expect-error\n    schema.default;\n}\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n    if (\"entries\" in schema) {\n        const object2 = {};\n        for(const key in schema.entries){\n            object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n        }\n        return object2;\n    }\n    if (\"items\" in schema) {\n        return schema.items.map(getDefaults);\n    }\n    return getDefault(schema);\n}\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n    if (\"entries\" in schema) {\n        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[\n                key,\n                await /* @__PURE__ */ getDefaultsAsync(value2)\n            ])));\n    }\n    if (\"items\" in schema) {\n        return Promise.all(schema.items.map(getDefaultsAsync));\n    }\n    return getDefault(schema);\n}\n// src/methods/getDescription/getDescription.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDescription(schema) {\n    return _getLastMetadata(schema, \"description\");\n}\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n    if (\"entries\" in schema) {\n        const object2 = {};\n        for(const key in schema.entries){\n            object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n        }\n        return object2;\n    }\n    if (\"items\" in schema) {\n        return schema.items.map(getFallbacks);\n    }\n    return getFallback(schema);\n}\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n    if (\"entries\" in schema) {\n        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[\n                key,\n                await /* @__PURE__ */ getFallbacksAsync(value2)\n            ])));\n    }\n    if (\"items\" in schema) {\n        return Promise.all(schema.items.map(getFallbacksAsync));\n    }\n    return getFallback(schema);\n}\n// src/methods/getMetadata/getMetadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction getMetadata(schema) {\n    const result = {};\n    function depthFirstMerge(schema2) {\n        if (\"pipe\" in schema2) {\n            for (const item of schema2.pipe){\n                if (item.kind === \"schema\" && \"pipe\" in item) {\n                    depthFirstMerge(item);\n                } else if (item.kind === \"metadata\" && item.type === \"metadata\") {\n                    Object.assign(result, item.metadata);\n                }\n            }\n        }\n    }\n    depthFirstMerge(schema);\n    return result;\n}\n// src/methods/getTitle/getTitle.ts\n// @__NO_SIDE_EFFECTS__\nfunction getTitle(schema) {\n    return _getLastMetadata(schema, \"title\");\n}\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n    return !schema[\"~run\"]({\n        value: input\n    }, {\n        abortEarly: true\n    }).issues;\n}\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n    return {\n        kind: \"schema\",\n        type: \"any\",\n        reference: any,\n        expects: \"any\",\n        async: false,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset) {\n            dataset.typed = true;\n            return dataset;\n        }\n    };\n}\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message2) {\n    return {\n        kind: \"schema\",\n        type: \"array\",\n        reference: array,\n        expects: \"Array\",\n        async: false,\n        item,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < input.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.item[\"~run\"]({\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message2) {\n    return {\n        kind: \"schema\",\n        type: \"array\",\n        reference: arrayAsync,\n        expects: \"Array\",\n        async: true,\n        item,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(input.map((value2)=>this.item[\"~run\"]({\n                        value: value2\n                    }, config2)));\n                for(let key = 0; key < itemDatasets.length; key++){\n                    const itemDataset = itemDatasets[key];\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: input[key]\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message2) {\n    return {\n        kind: \"schema\",\n        type: \"bigint\",\n        reference: bigint,\n        expects: \"bigint\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (typeof dataset.value === \"bigint\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message2) {\n    return {\n        kind: \"schema\",\n        type: \"blob\",\n        reference: blob,\n        expects: \"Blob\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value instanceof Blob) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message2) {\n    return {\n        kind: \"schema\",\n        type: \"boolean\",\n        reference: boolean,\n        expects: \"boolean\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (typeof dataset.value === \"boolean\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"custom\",\n        reference: custom,\n        expects: \"unknown\",\n        async: false,\n        check: check2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (this.check(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"custom\",\n        reference: customAsync,\n        expects: \"unknown\",\n        async: true,\n        check: check2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (await this.check(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message2) {\n    return {\n        kind: \"schema\",\n        type: \"date\",\n        reference: date,\n        expects: \"Date\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value instanceof Date) {\n                if (!isNaN(dataset.value)) {\n                    dataset.typed = true;\n                } else {\n                    _addIssue(this, \"type\", dataset, config2, {\n                        received: '\"Invalid Date\"'\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message2) {\n    const options = [];\n    for(const key in enum__){\n        if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n            options.push(enum__[key]);\n        }\n    }\n    return {\n        kind: \"schema\",\n        type: \"enum\",\n        reference: enum_,\n        expects: _joinExpects(options.map(_stringify), \"|\"),\n        async: false,\n        enum: enum__,\n        options,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (this.options.includes(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"exact_optional\",\n        reference: exactOptional,\n        expects: wrapped.expects,\n        async: false,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"exact_optional\",\n        reference: exactOptionalAsync,\n        expects: wrapped.expects,\n        async: true,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message2) {\n    return {\n        kind: \"schema\",\n        type: \"file\",\n        reference: file,\n        expects: \"File\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value instanceof File) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message2) {\n    return {\n        kind: \"schema\",\n        type: \"function\",\n        reference: function_,\n        expects: \"Function\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (typeof dataset.value === \"function\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message2) {\n    return {\n        kind: \"schema\",\n        type: \"instance\",\n        reference: instance,\n        expects: class_.name,\n        async: false,\n        class: class_,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value instanceof this.class) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n    if (typeof value1 === typeof value2) {\n        if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n            return {\n                value: value1\n            };\n        }\n        if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n            for(const key in value2){\n                if (key in value1) {\n                    const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n                    if (dataset.issue) {\n                        return dataset;\n                    }\n                    value1[key] = dataset.value;\n                } else {\n                    value1[key] = value2[key];\n                }\n            }\n            return {\n                value: value1\n            };\n        }\n        if (Array.isArray(value1) && Array.isArray(value2)) {\n            if (value1.length === value2.length) {\n                for(let index = 0; index < value1.length; index++){\n                    const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n                    if (dataset.issue) {\n                        return dataset;\n                    }\n                    value1[index] = dataset.value;\n                }\n                return {\n                    value: value1\n                };\n            }\n        }\n    }\n    return {\n        issue: true\n    };\n}\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message2) {\n    return {\n        kind: \"schema\",\n        type: \"intersect\",\n        reference: intersect,\n        expects: _joinExpects(options.map((option)=>option.expects), \"&\"),\n        async: false,\n        options,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (this.options.length) {\n                const input = dataset.value;\n                let outputs;\n                dataset.typed = true;\n                for (const schema of this.options){\n                    const optionDataset = schema[\"~run\"]({\n                        value: input\n                    }, config2);\n                    if (optionDataset.issues) {\n                        if (dataset.issues) {\n                            dataset.issues.push(...optionDataset.issues);\n                        } else {\n                            dataset.issues = optionDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!optionDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (dataset.typed) {\n                        if (outputs) {\n                            outputs.push(optionDataset.value);\n                        } else {\n                            outputs = [\n                                optionDataset.value\n                            ];\n                        }\n                    }\n                }\n                if (dataset.typed) {\n                    dataset.value = outputs[0];\n                    for(let index = 1; index < outputs.length; index++){\n                        const mergeDataset = _merge(dataset.value, outputs[index]);\n                        if (mergeDataset.issue) {\n                            _addIssue(this, \"type\", dataset, config2, {\n                                received: \"unknown\"\n                            });\n                            break;\n                        }\n                        dataset.value = mergeDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message2) {\n    return {\n        kind: \"schema\",\n        type: \"intersect\",\n        reference: intersectAsync,\n        expects: _joinExpects(options.map((option)=>option.expects), \"&\"),\n        async: true,\n        options,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (this.options.length) {\n                const input = dataset.value;\n                let outputs;\n                dataset.typed = true;\n                const optionDatasets = await Promise.all(this.options.map((schema)=>schema[\"~run\"]({\n                        value: input\n                    }, config2)));\n                for (const optionDataset of optionDatasets){\n                    if (optionDataset.issues) {\n                        if (dataset.issues) {\n                            dataset.issues.push(...optionDataset.issues);\n                        } else {\n                            dataset.issues = optionDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!optionDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (dataset.typed) {\n                        if (outputs) {\n                            outputs.push(optionDataset.value);\n                        } else {\n                            outputs = [\n                                optionDataset.value\n                            ];\n                        }\n                    }\n                }\n                if (dataset.typed) {\n                    dataset.value = outputs[0];\n                    for(let index = 1; index < outputs.length; index++){\n                        const mergeDataset = _merge(dataset.value, outputs[index]);\n                        if (mergeDataset.issue) {\n                            _addIssue(this, \"type\", dataset, config2, {\n                                received: \"unknown\"\n                            });\n                            break;\n                        }\n                        dataset.value = mergeDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n    return {\n        kind: \"schema\",\n        type: \"lazy\",\n        reference: lazy,\n        expects: \"unknown\",\n        async: false,\n        getter,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            return this.getter(dataset.value)[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n    return {\n        kind: \"schema\",\n        type: \"lazy\",\n        reference: lazyAsync,\n        expects: \"unknown\",\n        async: true,\n        getter,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message2) {\n    return {\n        kind: \"schema\",\n        type: \"literal\",\n        reference: literal,\n        expects: _stringify(literal_),\n        async: false,\n        literal: literal_,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value === this.literal) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"loose_object\",\n        reference: looseObject,\n        expects: \"Object\",\n        async: false,\n        entries: entries2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const valueSchema = this.entries[key];\n                    if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n                    valueSchema.default !== void 0) {\n                        const value2 = key in input ? // @ts-expect-error\n                        input[key] : getDefault(valueSchema);\n                        const valueDataset = valueSchema[\"~run\"]({\n                            value: value2\n                        }, config2);\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    } else if (valueSchema.fallback !== void 0) {\n                        dataset.value[key] = getFallback(valueSchema);\n                    } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n                        _addIssue(this, \"key\", dataset, config2, {\n                            input: void 0,\n                            expected: `\"${key}\"`,\n                            path: [\n                                {\n                                    type: \"object\",\n                                    origin: \"key\",\n                                    input,\n                                    key,\n                                    // @ts-expect-error\n                                    value: input[key]\n                                }\n                            ]\n                        });\n                        if (config2.abortEarly) {\n                            break;\n                        }\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            dataset.value[key] = input[key];\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"loose_object\",\n        reference: looseObjectAsync,\n        expects: \"Object\",\n        async: true,\n        entries: entries2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{\n                    if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n                    valueSchema.default !== void 0) {\n                        const value2 = key in input ? // @ts-expect-error\n                        input[key] : await getDefault(valueSchema);\n                        return [\n                            key,\n                            value2,\n                            valueSchema,\n                            await valueSchema[\"~run\"]({\n                                value: value2\n                            }, config2)\n                        ];\n                    }\n                    return [\n                        key,\n                        // @ts-expect-error\n                        input[key],\n                        valueSchema,\n                        null\n                    ];\n                }));\n                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){\n                    if (valueDataset) {\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    } else if (valueSchema.fallback !== void 0) {\n                        dataset.value[key] = await getFallback(valueSchema);\n                    } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n                        _addIssue(this, \"key\", dataset, config2, {\n                            input: void 0,\n                            expected: `\"${key}\"`,\n                            path: [\n                                {\n                                    type: \"object\",\n                                    origin: \"key\",\n                                    input,\n                                    key,\n                                    value: value2\n                                }\n                            ]\n                        });\n                        if (config2.abortEarly) {\n                            break;\n                        }\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            dataset.value[key] = input[key];\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message2) {\n    return {\n        kind: \"schema\",\n        type: \"loose_tuple\",\n        reference: looseTuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key][\"~run\"]({\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        dataset.value.push(input[key]);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message2) {\n    return {\n        kind: \"schema\",\n        type: \"loose_tuple\",\n        reference: looseTupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item[\"~run\"]({\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        dataset.value.push(input[key]);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"map\",\n        reference: map,\n        expects: \"Map\",\n        async: false,\n        key,\n        value: value2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Map) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Map();\n                for (const [inputKey, inputValue] of input){\n                    const keyDataset = this.key[\"~run\"]({\n                        value: inputKey\n                    }, config2);\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"key\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    const valueDataset = this.value[\"~run\"]({\n                        value: inputValue\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"value\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.set(keyDataset.value, valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"map\",\n        reference: mapAsync,\n        expects: \"Map\",\n        async: true,\n        key,\n        value: value2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Map) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Map();\n                const datasets = await Promise.all([\n                    ...input\n                ].map(([inputKey, inputValue])=>Promise.all([\n                        inputKey,\n                        inputValue,\n                        this.key[\"~run\"]({\n                            value: inputKey\n                        }, config2),\n                        this.value[\"~run\"]({\n                            value: inputValue\n                        }, config2)\n                    ])));\n                for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets){\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"key\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"value\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.set(keyDataset.value, valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message2) {\n    return {\n        kind: \"schema\",\n        type: \"nan\",\n        reference: nan,\n        expects: \"NaN\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (Number.isNaN(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message2) {\n    return {\n        kind: \"schema\",\n        type: \"never\",\n        reference: never,\n        expects: \"never\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            _addIssue(this, \"type\", dataset, config2);\n            return dataset;\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message2) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullable\",\n        reference: nonNullable,\n        expects: \"!null\",\n        async: false,\n        wrapped,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value !== null) {\n                dataset = this.wrapped[\"~run\"](dataset, config2);\n            }\n            if (dataset.value === null) {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message2) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullable\",\n        reference: nonNullableAsync,\n        expects: \"!null\",\n        async: true,\n        wrapped,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (dataset.value !== null) {\n                dataset = await this.wrapped[\"~run\"](dataset, config2);\n            }\n            if (dataset.value === null) {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message2) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullish\",\n        reference: nonNullish,\n        expects: \"(!null & !undefined)\",\n        async: false,\n        wrapped,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (!(dataset.value === null || dataset.value === void 0)) {\n                dataset = this.wrapped[\"~run\"](dataset, config2);\n            }\n            if (dataset.value === null || dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message2) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullish\",\n        reference: nonNullishAsync,\n        expects: \"(!null & !undefined)\",\n        async: true,\n        wrapped,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (!(dataset.value === null || dataset.value === void 0)) {\n                dataset = await this.wrapped[\"~run\"](dataset, config2);\n            }\n            if (dataset.value === null || dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message2) {\n    return {\n        kind: \"schema\",\n        type: \"non_optional\",\n        reference: nonOptional,\n        expects: \"!undefined\",\n        async: false,\n        wrapped,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value !== void 0) {\n                dataset = this.wrapped[\"~run\"](dataset, config2);\n            }\n            if (dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message2) {\n    return {\n        kind: \"schema\",\n        type: \"non_optional\",\n        reference: nonOptionalAsync,\n        expects: \"!undefined\",\n        async: true,\n        wrapped,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (dataset.value !== void 0) {\n                dataset = await this.wrapped[\"~run\"](dataset, config2);\n            }\n            if (dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message2) {\n    return {\n        kind: \"schema\",\n        type: \"null\",\n        reference: null_,\n        expects: \"null\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value === null) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"nullable\",\n        reference: nullable,\n        expects: `(${wrapped.expects} | null)`,\n        async: false,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value === null) {\n                if (this.default !== void 0) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"nullable\",\n        reference: nullableAsync,\n        expects: `(${wrapped.expects} | null)`,\n        async: true,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (dataset.value === null) {\n                if (this.default !== void 0) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"nullish\",\n        reference: nullish,\n        expects: `(${wrapped.expects} | null | undefined)`,\n        async: false,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                if (this.default !== void 0) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null || dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"nullish\",\n        reference: nullishAsync,\n        expects: `(${wrapped.expects} | null | undefined)`,\n        async: true,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                if (this.default !== void 0) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null || dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message2) {\n    return {\n        kind: \"schema\",\n        type: \"number\",\n        reference: number,\n        expects: \"number\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"object\",\n        reference: object,\n        expects: \"Object\",\n        async: false,\n        entries: entries2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const valueSchema = this.entries[key];\n                    if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n                    valueSchema.default !== void 0) {\n                        const value2 = key in input ? // @ts-expect-error\n                        input[key] : getDefault(valueSchema);\n                        const valueDataset = valueSchema[\"~run\"]({\n                            value: value2\n                        }, config2);\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    } else if (valueSchema.fallback !== void 0) {\n                        dataset.value[key] = getFallback(valueSchema);\n                    } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n                        _addIssue(this, \"key\", dataset, config2, {\n                            input: void 0,\n                            expected: `\"${key}\"`,\n                            path: [\n                                {\n                                    type: \"object\",\n                                    origin: \"key\",\n                                    input,\n                                    key,\n                                    // @ts-expect-error\n                                    value: input[key]\n                                }\n                            ]\n                        });\n                        if (config2.abortEarly) {\n                            break;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"object\",\n        reference: objectAsync,\n        expects: \"Object\",\n        async: true,\n        entries: entries2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{\n                    if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n                    valueSchema.default !== void 0) {\n                        const value2 = key in input ? // @ts-expect-error\n                        input[key] : await getDefault(valueSchema);\n                        return [\n                            key,\n                            value2,\n                            valueSchema,\n                            await valueSchema[\"~run\"]({\n                                value: value2\n                            }, config2)\n                        ];\n                    }\n                    return [\n                        key,\n                        // @ts-expect-error\n                        input[key],\n                        valueSchema,\n                        null\n                    ];\n                }));\n                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){\n                    if (valueDataset) {\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    } else if (valueSchema.fallback !== void 0) {\n                        dataset.value[key] = await getFallback(valueSchema);\n                    } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n                        _addIssue(this, \"key\", dataset, config2, {\n                            input: void 0,\n                            expected: `\"${key}\"`,\n                            path: [\n                                {\n                                    type: \"object\",\n                                    origin: \"key\",\n                                    input,\n                                    key,\n                                    value: value2\n                                }\n                            ]\n                        });\n                        if (config2.abortEarly) {\n                            break;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries2, rest, message2) {\n    return {\n        kind: \"schema\",\n        type: \"object_with_rest\",\n        reference: objectWithRest,\n        expects: \"Object\",\n        async: false,\n        entries: entries2,\n        rest,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const valueSchema = this.entries[key];\n                    if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n                    valueSchema.default !== void 0) {\n                        const value2 = key in input ? // @ts-expect-error\n                        input[key] : getDefault(valueSchema);\n                        const valueDataset = valueSchema[\"~run\"]({\n                            value: value2\n                        }, config2);\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    } else if (valueSchema.fallback !== void 0) {\n                        dataset.value[key] = getFallback(valueSchema);\n                    } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n                        _addIssue(this, \"key\", dataset, config2, {\n                            input: void 0,\n                            expected: `\"${key}\"`,\n                            path: [\n                                {\n                                    type: \"object\",\n                                    origin: \"key\",\n                                    input,\n                                    key,\n                                    // @ts-expect-error\n                                    value: input[key]\n                                }\n                            ]\n                        });\n                        if (config2.abortEarly) {\n                            break;\n                        }\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            const valueDataset = this.rest[\"~run\"](// @ts-expect-error\n                            {\n                                value: input[key]\n                            }, config2);\n                            if (valueDataset.issues) {\n                                const pathItem = {\n                                    type: \"object\",\n                                    origin: \"value\",\n                                    input,\n                                    key,\n                                    // @ts-expect-error\n                                    value: input[key]\n                                };\n                                for (const issue of valueDataset.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    dataset.issues?.push(issue);\n                                }\n                                if (!dataset.issues) {\n                                    dataset.issues = valueDataset.issues;\n                                }\n                                if (config2.abortEarly) {\n                                    dataset.typed = false;\n                                    break;\n                                }\n                            }\n                            if (!valueDataset.typed) {\n                                dataset.typed = false;\n                            }\n                            dataset.value[key] = valueDataset.value;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries2, rest, message2) {\n    return {\n        kind: \"schema\",\n        type: \"object_with_rest\",\n        reference: objectWithRestAsync,\n        expects: \"Object\",\n        async: true,\n        entries: entries2,\n        rest,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const [normalDatasets, restDatasets] = await Promise.all([\n                    // If key is present or its an optional schema with a default value,\n                    // parse input of key or default value asynchronously\n                    Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{\n                        if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n                        valueSchema.default !== void 0) {\n                            const value2 = key in input ? // @ts-expect-error\n                            input[key] : await getDefault(valueSchema);\n                            return [\n                                key,\n                                value2,\n                                valueSchema,\n                                await valueSchema[\"~run\"]({\n                                    value: value2\n                                }, config2)\n                            ];\n                        }\n                        return [\n                            key,\n                            // @ts-expect-error\n                            input[key],\n                            valueSchema,\n                            null\n                        ];\n                    })),\n                    // Parse other entries with rest schema asynchronously\n                    // Hint: We exclude specific keys for security reasons\n                    Promise.all(Object.entries(input).filter(([key])=>_isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value2])=>[\n                            key,\n                            value2,\n                            await this.rest[\"~run\"]({\n                                value: value2\n                            }, config2)\n                        ]))\n                ]);\n                for (const [key, value2, valueSchema, valueDataset] of normalDatasets){\n                    if (valueDataset) {\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    } else if (valueSchema.fallback !== void 0) {\n                        dataset.value[key] = await getFallback(valueSchema);\n                    } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n                        _addIssue(this, \"key\", dataset, config2, {\n                            input: void 0,\n                            expected: `\"${key}\"`,\n                            path: [\n                                {\n                                    type: \"object\",\n                                    origin: \"key\",\n                                    input,\n                                    key,\n                                    value: value2\n                                }\n                            ]\n                        });\n                        if (config2.abortEarly) {\n                            break;\n                        }\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for (const [key, value2, valueDataset] of restDatasets){\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"optional\",\n        reference: optional,\n        expects: `(${wrapped.expects} | undefined)`,\n        async: false,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value === void 0) {\n                if (this.default !== void 0) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"optional\",\n        reference: optionalAsync,\n        expects: `(${wrapped.expects} | undefined)`,\n        async: true,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (dataset.value === void 0) {\n                if (this.default !== void 0) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message2) {\n    return {\n        kind: \"schema\",\n        type: \"picklist\",\n        reference: picklist,\n        expects: _joinExpects(options.map(_stringify), \"|\"),\n        async: false,\n        options,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (this.options.includes(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message2) {\n    return {\n        kind: \"schema\",\n        type: \"promise\",\n        reference: promise,\n        expects: \"Promise\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value instanceof Promise) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"record\",\n        reference: record,\n        expects: \"Object\",\n        async: false,\n        key,\n        value: value2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const entryKey in input){\n                    if (_isValidObjectKey(input, entryKey)) {\n                        const entryValue = input[entryKey];\n                        const keyDataset = this.key[\"~run\"]({\n                            value: entryKey\n                        }, config2);\n                        if (keyDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"key\",\n                                input,\n                                key: entryKey,\n                                value: entryValue\n                            };\n                            for (const issue of keyDataset.issues){\n                                issue.path = [\n                                    pathItem\n                                ];\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = keyDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        const valueDataset = this.value[\"~run\"]({\n                            value: entryValue\n                        }, config2);\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key: entryKey,\n                                value: entryValue\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!keyDataset.typed || !valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        if (keyDataset.typed) {\n                            dataset.value[keyDataset.value] = valueDataset.value;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"record\",\n        reference: recordAsync,\n        expects: \"Object\",\n        async: true,\n        key,\n        value: value2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const datasets = await Promise.all(Object.entries(input).filter(([key2])=>_isValidObjectKey(input, key2)).map(([entryKey, entryValue])=>Promise.all([\n                        entryKey,\n                        entryValue,\n                        this.key[\"~run\"]({\n                            value: entryKey\n                        }, config2),\n                        this.value[\"~run\"]({\n                            value: entryValue\n                        }, config2)\n                    ])));\n                for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets){\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"key\",\n                            input,\n                            key: entryKey,\n                            value: entryValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            issue.path = [\n                                pathItem\n                            ];\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: entryKey,\n                            value: entryValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (keyDataset.typed) {\n                        dataset.value[keyDataset.value] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"set\",\n        reference: set,\n        expects: \"Set\",\n        async: false,\n        value: value2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Set) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Set();\n                for (const inputValue of input){\n                    const valueDataset = this.value[\"~run\"]({\n                        value: inputValue\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"set\",\n                            origin: \"value\",\n                            input,\n                            key: null,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.add(valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"set\",\n        reference: setAsync,\n        expects: \"Set\",\n        async: true,\n        value: value2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Set) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Set();\n                const valueDatasets = await Promise.all([\n                    ...input\n                ].map(async (inputValue)=>[\n                        inputValue,\n                        await this.value[\"~run\"]({\n                            value: inputValue\n                        }, config2)\n                    ]));\n                for (const [inputValue, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"set\",\n                            origin: \"value\",\n                            input,\n                            key: null,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.add(valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"strict_object\",\n        reference: strictObject,\n        expects: \"Object\",\n        async: false,\n        entries: entries2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const valueSchema = this.entries[key];\n                    if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n                    valueSchema.default !== void 0) {\n                        const value2 = key in input ? // @ts-expect-error\n                        input[key] : getDefault(valueSchema);\n                        const valueDataset = valueSchema[\"~run\"]({\n                            value: value2\n                        }, config2);\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    } else if (valueSchema.fallback !== void 0) {\n                        dataset.value[key] = getFallback(valueSchema);\n                    } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n                        _addIssue(this, \"key\", dataset, config2, {\n                            input: void 0,\n                            expected: `\"${key}\"`,\n                            path: [\n                                {\n                                    type: \"object\",\n                                    origin: \"key\",\n                                    input,\n                                    key,\n                                    // @ts-expect-error\n                                    value: input[key]\n                                }\n                            ]\n                        });\n                        if (config2.abortEarly) {\n                            break;\n                        }\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (!(key in this.entries)) {\n                            _addIssue(this, \"key\", dataset, config2, {\n                                input: key,\n                                expected: \"never\",\n                                path: [\n                                    {\n                                        type: \"object\",\n                                        origin: \"key\",\n                                        input,\n                                        key,\n                                        // @ts-expect-error\n                                        value: input[key]\n                                    }\n                                ]\n                            });\n                            break;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries2, message2) {\n    return {\n        kind: \"schema\",\n        type: \"strict_object\",\n        reference: strictObjectAsync,\n        expects: \"Object\",\n        async: true,\n        entries: entries2,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema])=>{\n                    if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n                    valueSchema.default !== void 0) {\n                        const value2 = key in input ? // @ts-expect-error\n                        input[key] : await getDefault(valueSchema);\n                        return [\n                            key,\n                            value2,\n                            valueSchema,\n                            await valueSchema[\"~run\"]({\n                                value: value2\n                            }, config2)\n                        ];\n                    }\n                    return [\n                        key,\n                        // @ts-expect-error\n                        input[key],\n                        valueSchema,\n                        null\n                    ];\n                }));\n                for (const [key, value2, valueSchema, valueDataset] of valueDatasets){\n                    if (valueDataset) {\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    } else if (valueSchema.fallback !== void 0) {\n                        dataset.value[key] = await getFallback(valueSchema);\n                    } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n                        _addIssue(this, \"key\", dataset, config2, {\n                            input: void 0,\n                            expected: `\"${key}\"`,\n                            path: [\n                                {\n                                    type: \"object\",\n                                    origin: \"key\",\n                                    input,\n                                    key,\n                                    value: value2\n                                }\n                            ]\n                        });\n                        if (config2.abortEarly) {\n                            break;\n                        }\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (!(key in this.entries)) {\n                            _addIssue(this, \"key\", dataset, config2, {\n                                input: key,\n                                expected: \"never\",\n                                path: [\n                                    {\n                                        type: \"object\",\n                                        origin: \"key\",\n                                        input,\n                                        key,\n                                        // @ts-expect-error\n                                        value: input[key]\n                                    }\n                                ]\n                            });\n                            break;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message2) {\n    return {\n        kind: \"schema\",\n        type: \"strict_tuple\",\n        reference: strictTuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key][\"~run\"]({\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n                    _addIssue(this, \"type\", dataset, config2, {\n                        input: input[this.items.length],\n                        expected: \"never\",\n                        path: [\n                            {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key: this.items.length,\n                                value: input[this.items.length]\n                            }\n                        ]\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message2) {\n    return {\n        kind: \"schema\",\n        type: \"strict_tuple\",\n        reference: strictTupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item[\"~run\"]({\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n                    _addIssue(this, \"type\", dataset, config2, {\n                        input: input[this.items.length],\n                        expected: \"never\",\n                        path: [\n                            {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key: this.items.length,\n                                value: input[this.items.length]\n                            }\n                        ]\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message2) {\n    return {\n        kind: \"schema\",\n        type: \"string\",\n        reference: string,\n        expects: \"string\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (typeof dataset.value === \"string\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message2) {\n    return {\n        kind: \"schema\",\n        type: \"symbol\",\n        reference: symbol,\n        expects: \"symbol\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (typeof dataset.value === \"symbol\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message2) {\n    return {\n        kind: \"schema\",\n        type: \"tuple\",\n        reference: tuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key][\"~run\"]({\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message2) {\n    return {\n        kind: \"schema\",\n        type: \"tuple\",\n        reference: tupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item[\"~run\"]({\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message2) {\n    return {\n        kind: \"schema\",\n        type: \"tuple_with_rest\",\n        reference: tupleWithRest,\n        expects: \"Array\",\n        async: false,\n        items,\n        rest,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key][\"~run\"]({\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        const value2 = input[key];\n                        const itemDataset = this.rest[\"~run\"]({\n                            value: value2\n                        }, config2);\n                        if (itemDataset.issues) {\n                            const pathItem = {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of itemDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = itemDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!itemDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value.push(itemDataset.value);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message2) {\n    return {\n        kind: \"schema\",\n        type: \"tuple_with_rest\",\n        reference: tupleWithRestAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        rest,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const [normalDatasets, restDatasets] = await Promise.all([\n                    // Parse schema of each normal item\n                    Promise.all(this.items.map(async (item, key)=>{\n                        const value2 = input[key];\n                        return [\n                            key,\n                            value2,\n                            await item[\"~run\"]({\n                                value: value2\n                            }, config2)\n                        ];\n                    })),\n                    // Parse other items with rest schema\n                    Promise.all(input.slice(this.items.length).map(async (value2, key)=>{\n                        return [\n                            key + this.items.length,\n                            value2,\n                            await this.rest[\"~run\"]({\n                                value: value2\n                            }, config2)\n                        ];\n                    }))\n                ]);\n                for (const [key, value2, itemDataset] of normalDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for (const [key, value2, itemDataset] of restDatasets){\n                        if (itemDataset.issues) {\n                            const pathItem = {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of itemDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = itemDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!itemDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value.push(itemDataset.value);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message2) {\n    return {\n        kind: \"schema\",\n        type: \"undefined\",\n        reference: undefined_,\n        expects: \"undefined\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value === void 0) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"undefinedable\",\n        reference: undefinedable,\n        expects: `(${wrapped.expects} | undefined)`,\n        async: false,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value === void 0) {\n                if (this.default !== void 0) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n    return {\n        kind: \"schema\",\n        type: \"undefinedable\",\n        reference: undefinedableAsync,\n        expects: `(${wrapped.expects} | undefined)`,\n        async: true,\n        wrapped,\n        default: default_,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            if (dataset.value === void 0) {\n                if (this.default !== void 0) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped[\"~run\"](dataset, config2);\n        }\n    };\n}\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n    let issues;\n    if (datasets) {\n        for (const dataset of datasets){\n            if (issues) {\n                issues.push(...dataset.issues);\n            } else {\n                issues = dataset.issues;\n            }\n        }\n    }\n    return issues;\n}\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message2) {\n    return {\n        kind: \"schema\",\n        type: \"union\",\n        reference: union,\n        expects: _joinExpects(options.map((option)=>option.expects), \"|\"),\n        async: false,\n        options,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            let validDataset;\n            let typedDatasets;\n            let untypedDatasets;\n            for (const schema of this.options){\n                const optionDataset = schema[\"~run\"]({\n                    value: dataset.value\n                }, config2);\n                if (optionDataset.typed) {\n                    if (optionDataset.issues) {\n                        if (typedDatasets) {\n                            typedDatasets.push(optionDataset);\n                        } else {\n                            typedDatasets = [\n                                optionDataset\n                            ];\n                        }\n                    } else {\n                        validDataset = optionDataset;\n                        break;\n                    }\n                } else {\n                    if (untypedDatasets) {\n                        untypedDatasets.push(optionDataset);\n                    } else {\n                        untypedDatasets = [\n                            optionDataset\n                        ];\n                    }\n                }\n            }\n            if (validDataset) {\n                return validDataset;\n            }\n            if (typedDatasets) {\n                if (typedDatasets.length === 1) {\n                    return typedDatasets[0];\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(typedDatasets)\n                });\n                dataset.typed = true;\n            } else if (untypedDatasets?.length === 1) {\n                return untypedDatasets[0];\n            } else {\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(untypedDatasets)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message2) {\n    return {\n        kind: \"schema\",\n        type: \"union\",\n        reference: unionAsync,\n        expects: _joinExpects(options.map((option)=>option.expects), \"|\"),\n        async: true,\n        options,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            let validDataset;\n            let typedDatasets;\n            let untypedDatasets;\n            for (const schema of this.options){\n                const optionDataset = await schema[\"~run\"]({\n                    value: dataset.value\n                }, config2);\n                if (optionDataset.typed) {\n                    if (optionDataset.issues) {\n                        if (typedDatasets) {\n                            typedDatasets.push(optionDataset);\n                        } else {\n                            typedDatasets = [\n                                optionDataset\n                            ];\n                        }\n                    } else {\n                        validDataset = optionDataset;\n                        break;\n                    }\n                } else {\n                    if (untypedDatasets) {\n                        untypedDatasets.push(optionDataset);\n                    } else {\n                        untypedDatasets = [\n                            optionDataset\n                        ];\n                    }\n                }\n            }\n            if (validDataset) {\n                return validDataset;\n            }\n            if (typedDatasets) {\n                if (typedDatasets.length === 1) {\n                    return typedDatasets[0];\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(typedDatasets)\n                });\n                dataset.typed = true;\n            } else if (untypedDatasets?.length === 1) {\n                return untypedDatasets[0];\n            } else {\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(untypedDatasets)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n    return {\n        kind: \"schema\",\n        type: \"unknown\",\n        reference: unknown,\n        expects: \"unknown\",\n        async: false,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset) {\n            dataset.typed = true;\n            return dataset;\n        }\n    };\n}\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message2) {\n    return {\n        kind: \"schema\",\n        type: \"variant\",\n        reference: variant,\n        expects: \"Object\",\n        async: false,\n        key,\n        options,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                let outputDataset;\n                let maxDiscriminatorPriority = 0;\n                let invalidDiscriminatorKey = this.key;\n                let expectedDiscriminators = [];\n                const parseOptions = (variant2, allKeys)=>{\n                    for (const schema of variant2.options){\n                        if (schema.type === \"variant\") {\n                            parseOptions(schema, new Set(allKeys).add(schema.key));\n                        } else {\n                            let keysAreValid = true;\n                            let currentPriority = 0;\n                            for (const currentKey of allKeys){\n                                const discriminatorSchema = schema.entries[currentKey];\n                                if (currentKey in input ? discriminatorSchema[\"~run\"](// @ts-expect-error\n                                {\n                                    typed: false,\n                                    value: input[currentKey]\n                                }, {\n                                    abortEarly: true\n                                }).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                                    keysAreValid = false;\n                                    if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                                        maxDiscriminatorPriority = currentPriority;\n                                        invalidDiscriminatorKey = currentKey;\n                                        expectedDiscriminators = [];\n                                    }\n                                    if (invalidDiscriminatorKey === currentKey) {\n                                        expectedDiscriminators.push(schema.entries[currentKey].expects);\n                                    }\n                                    break;\n                                }\n                                currentPriority++;\n                            }\n                            if (keysAreValid) {\n                                const optionDataset = schema[\"~run\"]({\n                                    value: input\n                                }, config2);\n                                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                                    outputDataset = optionDataset;\n                                }\n                            }\n                        }\n                        if (outputDataset && !outputDataset.issues) {\n                            break;\n                        }\n                    }\n                };\n                parseOptions(this, /* @__PURE__ */ new Set([\n                    this.key\n                ]));\n                if (outputDataset) {\n                    return outputDataset;\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    // @ts-expect-error\n                    input: input[invalidDiscriminatorKey],\n                    expected: _joinExpects(expectedDiscriminators, \"|\"),\n                    path: [\n                        {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: invalidDiscriminatorKey,\n                            // @ts-expect-error\n                            value: input[invalidDiscriminatorKey]\n                        }\n                    ]\n                });\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message2) {\n    return {\n        kind: \"schema\",\n        type: \"variant\",\n        reference: variantAsync,\n        expects: \"Object\",\n        async: true,\n        key,\n        options,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                let outputDataset;\n                let maxDiscriminatorPriority = 0;\n                let invalidDiscriminatorKey = this.key;\n                let expectedDiscriminators = [];\n                const parseOptions = async (variant2, allKeys)=>{\n                    for (const schema of variant2.options){\n                        if (schema.type === \"variant\") {\n                            await parseOptions(schema, new Set(allKeys).add(schema.key));\n                        } else {\n                            let keysAreValid = true;\n                            let currentPriority = 0;\n                            for (const currentKey of allKeys){\n                                const discriminatorSchema = schema.entries[currentKey];\n                                if (currentKey in input ? (await discriminatorSchema[\"~run\"](// @ts-expect-error\n                                {\n                                    typed: false,\n                                    value: input[currentKey]\n                                }, {\n                                    abortEarly: true\n                                })).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                                    keysAreValid = false;\n                                    if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                                        maxDiscriminatorPriority = currentPriority;\n                                        invalidDiscriminatorKey = currentKey;\n                                        expectedDiscriminators = [];\n                                    }\n                                    if (invalidDiscriminatorKey === currentKey) {\n                                        expectedDiscriminators.push(schema.entries[currentKey].expects);\n                                    }\n                                    break;\n                                }\n                                currentPriority++;\n                            }\n                            if (keysAreValid) {\n                                const optionDataset = await schema[\"~run\"]({\n                                    value: input\n                                }, config2);\n                                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                                    outputDataset = optionDataset;\n                                }\n                            }\n                        }\n                        if (outputDataset && !outputDataset.issues) {\n                            break;\n                        }\n                    }\n                };\n                await parseOptions(this, /* @__PURE__ */ new Set([\n                    this.key\n                ]));\n                if (outputDataset) {\n                    return outputDataset;\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    // @ts-expect-error\n                    input: input[invalidDiscriminatorKey],\n                    expected: _joinExpects(expectedDiscriminators, \"|\"),\n                    path: [\n                        {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: invalidDiscriminatorKey,\n                            // @ts-expect-error\n                            value: input[invalidDiscriminatorKey]\n                        }\n                    ]\n                });\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message2) {\n    return {\n        kind: \"schema\",\n        type: \"void\",\n        reference: void_,\n        expects: \"void\",\n        async: false,\n        message: message2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            if (dataset.value === void 0) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message2) {\n    return picklist(Object.keys(schema.entries), message2);\n}\n// src/methods/message/message.ts\n// @__NO_SIDE_EFFECTS__\nfunction message(schema, message_) {\n    return {\n        ...schema,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            return schema[\"~run\"](dataset, {\n                ...config2,\n                message: message_\n            });\n        }\n    };\n}\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n    const entries2 = {\n        ...schema.entries\n    };\n    for (const key of keys){\n        delete entries2[key];\n    }\n    return {\n        ...schema,\n        entries: entries2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        }\n    };\n}\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n    const dataset = schema[\"~run\"]({\n        value: input\n    }, getGlobalConfig(config2));\n    if (dataset.issues) {\n        throw new ValiError(dataset.issues);\n    }\n    return dataset.value;\n}\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n    const dataset = await schema[\"~run\"]({\n        value: input\n    }, getGlobalConfig(config2));\n    if (dataset.issues) {\n        throw new ValiError(dataset.issues);\n    }\n    return dataset.value;\n}\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n    const func = (input)=>parse(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n    const func = (input)=>parseAsync(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n    const entries2 = {};\n    for(const key in schema.entries){\n        entries2[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries: entries2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        }\n    };\n}\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n    const entries2 = {};\n    for(const key in schema.entries){\n        entries2[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries: entries2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        }\n    };\n}\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n    const entries2 = {};\n    for (const key of keys){\n        entries2[key] = schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries: entries2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        }\n    };\n}\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n    return {\n        ...pipe2[0],\n        pipe: pipe2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        \"~run\" (dataset, config2) {\n            for (const item of pipe2){\n                if (item.kind !== \"metadata\") {\n                    if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n                        dataset.typed = false;\n                        break;\n                    }\n                    if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n                        dataset = item[\"~run\"](dataset, config2);\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n    return {\n        ...pipe2[0],\n        pipe: pipe2,\n        async: true,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        },\n        async \"~run\" (dataset, config2) {\n            for (const item of pipe2){\n                if (item.kind !== \"metadata\") {\n                    if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n                        dataset.typed = false;\n                        break;\n                    }\n                    if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n                        dataset = await item[\"~run\"](dataset, config2);\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n    const keys = Array.isArray(arg2) ? arg2 : void 0;\n    const message2 = Array.isArray(arg2) ? arg3 : arg2;\n    const entries2 = {};\n    for(const key in schema.entries){\n        entries2[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message2) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries: entries2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        }\n    };\n}\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n    const keys = Array.isArray(arg2) ? arg2 : void 0;\n    const message2 = Array.isArray(arg2) ? arg3 : arg2;\n    const entries2 = {};\n    for(const key in schema.entries){\n        entries2[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message2) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries: entries2,\n        get \"~standard\" () {\n            return _getStandardProps(this);\n        }\n    };\n}\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n    const dataset = schema[\"~run\"]({\n        value: input\n    }, getGlobalConfig(config2));\n    return {\n        typed: dataset.typed,\n        success: !dataset.issues,\n        output: dataset.value,\n        issues: dataset.issues\n    };\n}\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n    const dataset = await schema[\"~run\"]({\n        value: input\n    }, getGlobalConfig(config2));\n    return {\n        typed: dataset.typed,\n        success: !dataset.issues,\n        output: dataset.value,\n        issues: dataset.issues\n    };\n}\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n    const func = (input)=>safeParse(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n    const func = (input)=>safeParseAsync(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/summarize/summarize.ts\n// @__NO_SIDE_EFFECTS__\nfunction summarize(issues) {\n    let summary = \"\";\n    for (const issue of issues){\n        if (summary) {\n            summary += \"\\n\";\n        }\n        summary += `\\xD7 ${issue.message}`;\n        const dotPath = getDotPath(issue);\n        if (dotPath) {\n            summary += `\n  \\u2192 at ${dotPath}`;\n        }\n    }\n    return summary;\n}\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n    return schema.wrapped;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsaWJvdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDRDQUE0QztBQUM1QyxJQUFJQTtBQUNKLFNBQVNDLGdCQUFnQkMsT0FBTztJQUM5QkYsUUFBUTtRQUFFLEdBQUdBLEtBQUs7UUFBRSxHQUFHRSxPQUFPO0lBQUM7QUFDakM7QUFDQSx1QkFBdUI7QUFDdkIsU0FBU0MsZ0JBQWdCRCxPQUFPO0lBQzlCLE9BQU87UUFDTEUsTUFBTUYsU0FBU0UsUUFBUUosT0FBT0k7UUFDOUJDLFNBQVNILFNBQVNHO1FBQ2xCQyxZQUFZSixTQUFTSSxjQUFjTixPQUFPTTtRQUMxQ0MsZ0JBQWdCTCxTQUFTSyxrQkFBa0JQLE9BQU9PO0lBQ3BEO0FBQ0Y7QUFDQSxTQUFTQztJQUNQUixRQUFRLEtBQUs7QUFDZjtBQUVBLDhDQUE4QztBQUM5QyxJQUFJUztBQUNKLFNBQVNDLGlCQUFpQkMsUUFBUSxFQUFFUCxJQUFJO0lBQ3RDLElBQUksQ0FBQ0ssUUFBUUEsU0FBUyxhQUFhLEdBQUcsSUFBSUc7SUFDMUNILE9BQU9JLEdBQUcsQ0FBQ1QsTUFBTU87QUFDbkI7QUFDQSx1QkFBdUI7QUFDdkIsU0FBU0csaUJBQWlCVixJQUFJO0lBQzVCLE9BQU9LLFFBQVFNLElBQUlYO0FBQ3JCO0FBQ0EsU0FBU1ksb0JBQW9CWixJ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LEdBQUcxUTtJQUNkLE9BQU9nSDtBQUNUO0FBRUEsNENBQTRDO0FBQzVDLHVCQUF1QjtBQUN2QixTQUFTZ1ksZ0JBQWdCamIsTUFBTSxFQUFFL0QsT0FBTztJQUN0QyxNQUFNZ0gsT0FBTyxDQUFDdEYsUUFBVW9kLGVBQWUvYSxRQUFRckMsT0FBTzFCO0lBQ3REZ0gsS0FBS2pELE1BQU0sR0FBR0E7SUFDZGlELEtBQUswSixNQUFNLEdBQUcxUTtJQUNkLE9BQU9nSDtBQUNUO0FBRUEscUNBQXFDO0FBQ3JDLHVCQUF1QjtBQUN2QixTQUFTaVksVUFBVXBjLE1BQU07SUFDdkIsSUFBSXFjLFVBQVU7SUFDZCxLQUFLLE1BQU16YyxTQUFTSSxPQUFRO1FBQzFCLElBQUlxYyxTQUFTO1lBQ1hBLFdBQVc7UUFDYjtRQUNBQSxXQUFXLENBQUMsS0FBSyxFQUFFemMsTUFBTXRDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLE1BQU0wVSxVQUFVdE8sV0FBVzlEO1FBQzNCLElBQUlvUyxTQUFTO1lBQ1hxSyxXQUFXLENBQUM7WUFDTixFQUFFckssUUFBUSxDQUFDO1FBQ25CO0lBQ0Y7SUFDQSxPQUFPcUs7QUFDVDtBQUVBLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkIsU0FBU0MsT0FBT3BiLE1BQU07SUFDcEIsT0FBT0EsT0FBTzJULE9BQU87QUFDdkI7QUErUkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGlwbGk5LXBhcmFub3JtYWwvLi9ub2RlX21vZHVsZXMvdmFsaWJvdC9kaXN0L2luZGV4LmpzPzQ4ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N0b3JhZ2VzL2dsb2JhbENvbmZpZy9nbG9iYWxDb25maWcudHNcbnZhciBzdG9yZTtcbmZ1bmN0aW9uIHNldEdsb2JhbENvbmZpZyhjb25maWcyKSB7XG4gIHN0b3JlID0geyAuLi5zdG9yZSwgLi4uY29uZmlnMiB9O1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGdldEdsb2JhbENvbmZpZyhjb25maWcyKSB7XG4gIHJldHVybiB7XG4gICAgbGFuZzogY29uZmlnMj8ubGFuZyA/PyBzdG9yZT8ubGFuZyxcbiAgICBtZXNzYWdlOiBjb25maWcyPy5tZXNzYWdlLFxuICAgIGFib3J0RWFybHk6IGNvbmZpZzI/LmFib3J0RWFybHkgPz8gc3RvcmU/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGNvbmZpZzI/LmFib3J0UGlwZUVhcmx5ID8/IHN0b3JlPy5hYm9ydFBpcGVFYXJseVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlR2xvYmFsQ29uZmlnKCkge1xuICBzdG9yZSA9IHZvaWQgMDtcbn1cblxuLy8gc3JjL3N0b3JhZ2VzL2dsb2JhbE1lc3NhZ2UvZ2xvYmFsTWVzc2FnZS50c1xudmFyIHN0b3JlMjtcbmZ1bmN0aW9uIHNldEdsb2JhbE1lc3NhZ2UobWVzc2FnZTIsIGxhbmcpIHtcbiAgaWYgKCFzdG9yZTIpIHN0b3JlMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0b3JlMi5zZXQobGFuZywgbWVzc2FnZTIpO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGdldEdsb2JhbE1lc3NhZ2UobGFuZykge1xuICByZXR1cm4gc3RvcmUyPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVHbG9iYWxNZXNzYWdlKGxhbmcpIHtcbiAgc3RvcmUyPy5kZWxldGUobGFuZyk7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9zY2hlbWFNZXNzYWdlL3NjaGVtYU1lc3NhZ2UudHNcbnZhciBzdG9yZTM7XG5mdW5jdGlvbiBzZXRTY2hlbWFNZXNzYWdlKG1lc3NhZ2UyLCBsYW5nKSB7XG4gIGlmICghc3RvcmUzKSBzdG9yZTMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdG9yZTMuc2V0KGxhbmcsIG1lc3NhZ2UyKTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBnZXRTY2hlbWFNZXNzYWdlKGxhbmcpIHtcbiAgcmV0dXJuIHN0b3JlMz8uZ2V0KGxhbmcpO1xufVxuZnVuY3Rpb24gZGVsZXRlU2NoZW1hTWVzc2FnZShsYW5nKSB7XG4gIHN0b3JlMz8uZGVsZXRlKGxhbmcpO1xufVxuXG4vLyBzcmMvc3RvcmFnZXMvc3BlY2lmaWNNZXNzYWdlL3NwZWNpZmljTWVzc2FnZS50c1xudmFyIHN0b3JlNDtcbmZ1bmN0aW9uIHNldFNwZWNpZmljTWVzc2FnZShyZWZlcmVuY2UsIG1lc3NhZ2UyLCBsYW5nKSB7XG4gIGlmICghc3RvcmU0KSBzdG9yZTQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAoIXN0b3JlNC5nZXQocmVmZXJlbmNlKSkgc3RvcmU0LnNldChyZWZlcmVuY2UsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBzdG9yZTQuZ2V0KHJlZmVyZW5jZSkuc2V0KGxhbmcsIG1lc3NhZ2UyKTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBnZXRTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHJldHVybiBzdG9yZTQ/LmdldChyZWZlcmVuY2UpPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHN0b3JlND8uZ2V0KHJlZmVyZW5jZSk/LmRlbGV0ZShsYW5nKTtcbn1cblxuLy8gc3JjL3V0aWxzL19zdHJpbmdpZnkvX3N0cmluZ2lmeS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9zdHJpbmdpZnkoaW5wdXQpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYFwiJHtpbnB1dH1cImA7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBgJHtpbnB1dH1gO1xuICB9XG4gIGlmICh0eXBlID09PSBcIm9iamVjdFwiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAoaW5wdXQgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KT8uY29uc3RydWN0b3I/Lm5hbWUpID8/IFwibnVsbFwiO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuXG4vLyBzcmMvdXRpbHMvX2FkZElzc3VlL19hZGRJc3N1ZS50c1xuZnVuY3Rpb24gX2FkZElzc3VlKGNvbnRleHQsIGxhYmVsLCBkYXRhc2V0LCBjb25maWcyLCBvdGhlcikge1xuICBjb25zdCBpbnB1dCA9IG90aGVyICYmIFwiaW5wdXRcIiBpbiBvdGhlciA/IG90aGVyLmlucHV0IDogZGF0YXNldC52YWx1ZTtcbiAgY29uc3QgZXhwZWN0ZWQgPSBvdGhlcj8uZXhwZWN0ZWQgPz8gY29udGV4dC5leHBlY3RzID8/IG51bGw7XG4gIGNvbnN0IHJlY2VpdmVkID0gb3RoZXI/LnJlY2VpdmVkID8/IF9zdHJpbmdpZnkoaW5wdXQpO1xuICBjb25zdCBpc3N1ZSA9IHtcbiAgICBraW5kOiBjb250ZXh0LmtpbmQsXG4gICAgdHlwZTogY29udGV4dC50eXBlLFxuICAgIGlucHV0LFxuICAgIGV4cGVjdGVkLFxuICAgIHJlY2VpdmVkLFxuICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bGFiZWx9OiAke2V4cGVjdGVkID8gYEV4cGVjdGVkICR7ZXhwZWN0ZWR9IGJ1dCByYCA6IFwiUlwifWVjZWl2ZWQgJHtyZWNlaXZlZH1gLFxuICAgIHJlcXVpcmVtZW50OiBjb250ZXh0LnJlcXVpcmVtZW50LFxuICAgIHBhdGg6IG90aGVyPy5wYXRoLFxuICAgIGlzc3Vlczogb3RoZXI/Lmlzc3VlcyxcbiAgICBsYW5nOiBjb25maWcyLmxhbmcsXG4gICAgYWJvcnRFYXJseTogY29uZmlnMi5hYm9ydEVhcmx5LFxuICAgIGFib3J0UGlwZUVhcmx5OiBjb25maWcyLmFib3J0UGlwZUVhcmx5XG4gIH07XG4gIGNvbnN0IGlzU2NoZW1hID0gY29udGV4dC5raW5kID09PSBcInNjaGVtYVwiO1xuICBjb25zdCBtZXNzYWdlMiA9IG90aGVyPy5tZXNzYWdlID8/IGNvbnRleHQubWVzc2FnZSA/PyBnZXRTcGVjaWZpY01lc3NhZ2UoY29udGV4dC5yZWZlcmVuY2UsIGlzc3VlLmxhbmcpID8/IChpc1NjaGVtYSA/IGdldFNjaGVtYU1lc3NhZ2UoaXNzdWUubGFuZykgOiBudWxsKSA/PyBjb25maWcyLm1lc3NhZ2UgPz8gZ2V0R2xvYmFsTWVzc2FnZShpc3N1ZS5sYW5nKTtcbiAgaWYgKG1lc3NhZ2UyICE9PSB2b2lkIDApIHtcbiAgICBpc3N1ZS5tZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UyID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBtZXNzYWdlMihpc3N1ZSlcbiAgICApIDogbWVzc2FnZTI7XG4gIH1cbiAgaWYgKGlzU2NoZW1hKSB7XG4gICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICB9XG4gIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgIGRhdGFzZXQuaXNzdWVzLnB1c2goaXNzdWUpO1xuICB9IGVsc2Uge1xuICAgIGRhdGFzZXQuaXNzdWVzID0gW2lzc3VlXTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvX2dldEJ5dGVDb3VudC9fZ2V0Qnl0ZUNvdW50LnRzXG52YXIgdGV4dEVuY29kZXI7XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gX2dldEJ5dGVDb3VudChpbnB1dCkge1xuICBpZiAoIXRleHRFbmNvZGVyKSB7XG4gICAgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgfVxuICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKGlucHV0KS5sZW5ndGg7XG59XG5cbi8vIHNyYy91dGlscy9fZ2V0R3JhcGhlbWVDb3VudC9fZ2V0R3JhcGhlbWVDb3VudC50c1xudmFyIHNlZ21lbnRlcjtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBfZ2V0R3JhcGhlbWVDb3VudChpbnB1dCkge1xuICBpZiAoIXNlZ21lbnRlcikge1xuICAgIHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcigpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gc2VnbWVudGVyLnNlZ21lbnQoaW5wdXQpO1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGNvbnN0IF8gb2Ygc2VnbWVudHMpIHtcbiAgICBjb3VudCsrO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLy8gc3JjL3V0aWxzL19nZXRMYXN0TWV0YWRhdGEvX2dldExhc3RNZXRhZGF0YS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9nZXRMYXN0TWV0YWRhdGEoc2NoZW1hLCB0eXBlKSB7XG4gIGlmIChcInBpcGVcIiBpbiBzY2hlbWEpIHtcbiAgICBjb25zdCBuZXN0ZWRTY2hlbWFzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSBzY2hlbWEucGlwZS5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBpdGVtID0gc2NoZW1hLnBpcGVbaW5kZXhdO1xuICAgICAgaWYgKGl0ZW0ua2luZCA9PT0gXCJzY2hlbWFcIiAmJiBcInBpcGVcIiBpbiBpdGVtKSB7XG4gICAgICAgIG5lc3RlZFNjaGVtYXMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5raW5kID09PSBcIm1ldGFkYXRhXCIgJiYgaXRlbS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIHJldHVybiBpdGVtW3R5cGVdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5lc3RlZFNjaGVtYSBvZiBuZXN0ZWRTY2hlbWFzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gX2dldExhc3RNZXRhZGF0YShuZXN0ZWRTY2hlbWEsIHR5cGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy91dGlscy9fZ2V0U3RhbmRhcmRQcm9wcy9fZ2V0U3RhbmRhcmRQcm9wcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9nZXRTdGFuZGFyZFByb3BzKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHZlbmRvcjogXCJ2YWxpYm90XCIsXG4gICAgdmFsaWRhdGUodmFsdWUyKSB7XG4gICAgICByZXR1cm4gY29udGV4dFtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGdldEdsb2JhbENvbmZpZygpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9fZ2V0V29yZENvdW50L19nZXRXb3JkQ291bnQudHNcbnZhciBzdG9yZTU7XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gX2dldFdvcmRDb3VudChsb2NhbGVzLCBpbnB1dCkge1xuICBpZiAoIXN0b3JlNSkge1xuICAgIHN0b3JlNSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgaWYgKCFzdG9yZTUuZ2V0KGxvY2FsZXMpKSB7XG4gICAgc3RvcmU1LnNldChsb2NhbGVzLCBuZXcgSW50bC5TZWdtZW50ZXIobG9jYWxlcywgeyBncmFudWxhcml0eTogXCJ3b3JkXCIgfSkpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gc3RvcmU1LmdldChsb2NhbGVzKS5zZWdtZW50KGlucHV0KTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnQuaXNXb3JkTGlrZSkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBzcmMvdXRpbHMvX2lzTHVobkFsZ28vX2lzTHVobkFsZ28udHNcbnZhciBOT05fRElHSVRfUkVHRVggPSAvXFxEL2d1O1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9pc0x1aG5BbGdvKGlucHV0KSB7XG4gIGNvbnN0IG51bWJlcjIgPSBpbnB1dC5yZXBsYWNlKE5PTl9ESUdJVF9SRUdFWCwgXCJcIik7XG4gIGxldCBsZW5ndGgyID0gbnVtYmVyMi5sZW5ndGg7XG4gIGxldCBiaXQgPSAxO1xuICBsZXQgc3VtID0gMDtcbiAgd2hpbGUgKGxlbmd0aDIpIHtcbiAgICBjb25zdCB2YWx1ZTIgPSArbnVtYmVyMlstLWxlbmd0aDJdO1xuICAgIGJpdCBePSAxO1xuICAgIHN1bSArPSBiaXQgPyBbMCwgMiwgNCwgNiwgOCwgMSwgMywgNSwgNywgOV1bdmFsdWUyXSA6IHZhbHVlMjtcbiAgfVxuICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG59XG5cbi8vIHNyYy91dGlscy9faXNWYWxpZE9iamVjdEtleS9faXNWYWxpZE9iamVjdEtleS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9pc1ZhbGlkT2JqZWN0S2V5KG9iamVjdDIsIGtleSkge1xuICByZXR1cm4gT2JqZWN0Lmhhc093bihvYmplY3QyLCBrZXkpICYmIGtleSAhPT0gXCJfX3Byb3RvX19cIiAmJiBrZXkgIT09IFwicHJvdG90eXBlXCIgJiYga2V5ICE9PSBcImNvbnN0cnVjdG9yXCI7XG59XG5cbi8vIHNyYy91dGlscy9fam9pbkV4cGVjdHMvX2pvaW5FeHBlY3RzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gX2pvaW5FeHBlY3RzKHZhbHVlczIsIHNlcGFyYXRvcikge1xuICBjb25zdCBsaXN0ID0gWy4uLm5ldyBTZXQodmFsdWVzMildO1xuICBpZiAobGlzdC5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGAoJHtsaXN0LmpvaW4oYCAke3NlcGFyYXRvcn0gYCl9KWA7XG4gIH1cbiAgcmV0dXJuIGxpc3RbMF0gPz8gXCJuZXZlclwiO1xufVxuXG4vLyBzcmMvdXRpbHMvZW50cmllc0Zyb21MaXN0L2VudHJpZXNGcm9tTGlzdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGVudHJpZXNGcm9tTGlzdChsaXN0LCBzY2hlbWEpIHtcbiAgY29uc3QgZW50cmllczIgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgbGlzdCkge1xuICAgIGVudHJpZXMyW2tleV0gPSBzY2hlbWE7XG4gIH1cbiAgcmV0dXJuIGVudHJpZXMyO1xufVxuXG4vLyBzcmMvdXRpbHMvZW50cmllc0Zyb21PYmplY3RzL2VudHJpZXNGcm9tT2JqZWN0cy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGVudHJpZXNGcm9tT2JqZWN0cyhzY2hlbWFzKSB7XG4gIGNvbnN0IGVudHJpZXMyID0ge307XG4gIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICBPYmplY3QuYXNzaWduKGVudHJpZXMyLCBzY2hlbWEuZW50cmllcyk7XG4gIH1cbiAgcmV0dXJuIGVudHJpZXMyO1xufVxuXG4vLyBzcmMvdXRpbHMvZ2V0RG90UGF0aC9nZXREb3RQYXRoLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ2V0RG90UGF0aChpc3N1ZSkge1xuICBpZiAoaXNzdWUucGF0aCkge1xuICAgIGxldCBrZXkgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpc3N1ZS5wYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW0ua2V5ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpdGVtLmtleSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAga2V5ICs9IGAuJHtpdGVtLmtleX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSArPSBpdGVtLmtleTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy91dGlscy9pc09mS2luZC9pc09mS2luZC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGlzT2ZLaW5kKGtpbmQsIG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIua2luZCA9PT0ga2luZDtcbn1cblxuLy8gc3JjL3V0aWxzL2lzT2ZUeXBlL2lzT2ZUeXBlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXNPZlR5cGUodHlwZSwgb2JqZWN0Mikge1xuICByZXR1cm4gb2JqZWN0Mi50eXBlID09PSB0eXBlO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNWYWxpRXJyb3IvaXNWYWxpRXJyb3IudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpc1ZhbGlFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBWYWxpRXJyb3I7XG59XG5cbi8vIHNyYy91dGlscy9WYWxpRXJyb3IvVmFsaUVycm9yLnRzXG52YXIgVmFsaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgVmFsaWJvdCBlcnJvciB3aXRoIHVzZWZ1bCBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlzc3VlcyBUaGUgZXJyb3IgaXNzdWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoaXNzdWVzWzBdLm1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiVmFsaUVycm9yXCI7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9hY3Rpb25zL2FyZ3MvYXJncy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGFyZ3Moc2NoZW1hKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwiYXJnc1wiLFxuICAgIHJlZmVyZW5jZTogYXJncyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgc2NoZW1hLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGZ1bmMgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgZGF0YXNldC52YWx1ZSA9ICguLi5hcmdzXykgPT4ge1xuICAgICAgICBjb25zdCBhcmdzRGF0YXNldCA9IHRoaXMuc2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiBhcmdzXyB9LCBjb25maWcyKTtcbiAgICAgICAgaWYgKGFyZ3NEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgIHRocm93IG5ldyBWYWxpRXJyb3IoYXJnc0RhdGFzZXQuaXNzdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyguLi5hcmdzRGF0YXNldC52YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9hcmdzL2FyZ3NBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGFyZ3NBc3luYyhzY2hlbWEpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJhcmdzXCIsXG4gICAgcmVmZXJlbmNlOiBhcmdzQXN5bmMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHNjaGVtYSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBmdW5jID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBhc3luYyAoLi4uYXJnczIpID0+IHtcbiAgICAgICAgY29uc3QgYXJnc0RhdGFzZXQgPSBhd2FpdCBzY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IGFyZ3MyIH0sIGNvbmZpZzIpO1xuICAgICAgICBpZiAoYXJnc0RhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbGlFcnJvcihhcmdzRGF0YXNldC5pc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKC4uLmFyZ3NEYXRhc2V0LnZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2F3YWl0L2F3YWl0QXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBhd2FpdEFzeW5jKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImF3YWl0XCIsXG4gICAgcmVmZXJlbmNlOiBhd2FpdEFzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBhd2FpdCBkYXRhc2V0LnZhbHVlO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvcmVnZXgudHNcbnZhciBCQVNFNjRfUkVHRVggPSAvXig/OltcXGRhLXorL117NH0pKig/OltcXGRhLXorL117Mn09PXxbXFxkYS16Ky9dezN9PSk/JC9pdTtcbnZhciBCSUNfUkVHRVggPSAvXltBLVpdezZ9KD8hMDApW1xcZEEtWl17Mn0oPzpbXFxkQS1aXXszfSk/JC91O1xudmFyIENVSUQyX1JFR0VYID0gL15bYS16XVtcXGRhLXpdKiQvdTtcbnZhciBERUNJTUFMX1JFR0VYID0gL15bKy1dPyg/OlxcZCpcXC4pP1xcZCskL3U7XG52YXIgRElHSVRTX1JFR0VYID0gL15cXGQrJC91O1xudmFyIEVNQUlMX1JFR0VYID0gL15bXFx3Ky1dKyg/OlxcLltcXHcrLV0rKSpAW1xcZGEtel0rKD86Wy4tXVtcXGRhLXpdKykqXFwuW2Etel17Mix9JC9pdTtcbnZhciBFTU9KSV9SRUdFWCA9IChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zLWRldGVjdG9yL25vLXVuc2FmZS1yZWdleCwgcmVnZXhwL25vLWR1cGUtZGlzanVuY3Rpb25zIC0tIGZhbHNlIHBvc2l0aXZlc1xuICAvXig/OltcXHV7MUYxRTZ9LVxcdXsxRjFGRn1dezJ9fFxcdXsxRjNGNH1bXFx1e0UwMDYxfS1cXHV7RTAwN0F9XXsyfVtcXHV7RTAwMzB9LVxcdXtFMDAzOX1cXHV7RTAwNjF9LVxcdXtFMDA3QX1dezEsM31cXHV7RTAwN0Z9fCg/OlxccHtFbW9qaX1cXHVGRTBGXFx1MjBFMz98XFxwe0Vtb2ppX01vZGlmaWVyX0Jhc2V9XFxwe0Vtb2ppX01vZGlmaWVyfT98XFxwe0Vtb2ppX1ByZXNlbnRhdGlvbn0pKD86XFx1MjAwRCg/OlxccHtFbW9qaX1cXHVGRTBGXFx1MjBFMz98XFxwe0Vtb2ppX01vZGlmaWVyX0Jhc2V9XFxwe0Vtb2ppX01vZGlmaWVyfT98XFxwe0Vtb2ppX1ByZXNlbnRhdGlvbn0pKSopKyQvdVxuKTtcbnZhciBIRVhBREVDSU1BTF9SRUdFWCA9IC9eKD86MFtoeF0pP1tcXGRhLWZBLUZdKyQvdTtcbnZhciBIRVhfQ09MT1JfUkVHRVggPSAvXiMoPzpbXFxkYS1mQS1GXXszLDR9fFtcXGRhLWZBLUZdezZ9fFtcXGRhLWZBLUZdezh9KSQvdTtcbnZhciBJTUVJX1JFR0VYID0gL15cXGR7MTV9JHxeXFxkezJ9LVxcZHs2fS1cXGR7Nn0tXFxkJC91O1xudmFyIElQVjRfUkVHRVggPSAoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy1kZXRlY3Rvci9uby11bnNhZmUtcmVnZXggLS0gZmFsc2UgcG9zaXRpdmVcbiAgL14oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKD86XFwuKD86KD86WzEtOV18MVxcZHwyWzAtNF0pP1xcZHwyNVswLTVdKSl7M30kL3Vcbik7XG52YXIgSVBWNl9SRUdFWCA9IC9eKD86KD86W1xcZGEtZl17MSw0fTopezd9W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw3fTp8KD86W1xcZGEtZl17MSw0fTopezEsNn06W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw1fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDJ9fCg/OltcXGRhLWZdezEsNH06KXsxLDR9KD86OltcXGRhLWZdezEsNH0pezEsM318KD86W1xcZGEtZl17MSw0fTopezEsM30oPzo6W1xcZGEtZl17MSw0fSl7MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSwyfSg/OjpbXFxkYS1mXXsxLDR9KXsxLDV9fFtcXGRhLWZdezEsNH06KD86OltcXGRhLWZdezEsNH0pezEsNn18Oig/Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDd9fDopfGZlODA6KD86OltcXGRhLWZdezAsNH0pezAsNH0lW1xcZGEtel0rfDo6KD86Zns0fSg/OjowezEsNH0pPzopPyg/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpfCg/OltcXGRhLWZdezEsNH06KXsxLDR9Oig/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpKSQvaXU7XG52YXIgSVBfUkVHRVggPSAvXig/Oig/OlsxLTldfDFcXGR8MlswLTRdKT9cXGR8MjVbMC01XSkoPzpcXC4oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKXszfSR8Xig/Oig/OltcXGRhLWZdezEsNH06KXs3fVtcXGRhLWZdezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsN306fCg/OltcXGRhLWZdezEsNH06KXsxLDZ9OltcXGRhLWZdezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsNX0oPzo6W1xcZGEtZl17MSw0fSl7MSwyfXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw0fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDN9fCg/OltcXGRhLWZdezEsNH06KXsxLDN9KD86OltcXGRhLWZdezEsNH0pezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsMn0oPzo6W1xcZGEtZl17MSw0fSl7MSw1fXxbXFxkYS1mXXsxLDR9Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDZ9fDooPzooPzo6W1xcZGEtZl17MSw0fSl7MSw3fXw6KXxmZTgwOig/OjpbXFxkYS1mXXswLDR9KXswLDR9JVtcXGRhLXpdK3w6Oig/OmZ7NH0oPzo6MHsxLDR9KT86KT8oPzooPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKVxcLil7M30oPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw0fTooPzooPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKVxcLil7M30oPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKSkkL2l1O1xudmFyIElTT19EQVRFX1JFR0VYID0gL15cXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86WzEyXVxcZHwwWzEtOV18M1swMV0pJC91O1xudmFyIElTT19EQVRFX1RJTUVfUkVHRVggPSAvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMTJdXFxkfDBbMS05XXwzWzAxXSlbVCBdKD86MFxcZHwxXFxkfDJbMC0zXSk6WzAtNV1cXGQkL3U7XG52YXIgSVNPX1RJTUVfUkVHRVggPSAvXig/OjBcXGR8MVxcZHwyWzAtM10pOlswLTVdXFxkJC91O1xudmFyIElTT19USU1FX1NFQ09ORF9SRUdFWCA9IC9eKD86MFxcZHwxXFxkfDJbMC0zXSkoPzo6WzAtNV1cXGQpezJ9JC91O1xudmFyIElTT19USU1FU1RBTVBfUkVHRVggPSAvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMTJdXFxkfDBbMS05XXwzWzAxXSlbVCBdKD86MFxcZHwxXFxkfDJbMC0zXSkoPzo6WzAtNV1cXGQpezJ9KD86XFwuXFxkezEsOX0pPyg/Olp8WystXSg/OjBcXGR8MVxcZHwyWzAtM10pKD86Oj9bMC01XVxcZCk/KSQvdTtcbnZhciBJU09fV0VFS19SRUdFWCA9IC9eXFxkezR9LVcoPzowWzEtOV18WzEtNF1cXGR8NVswLTNdKSQvdTtcbnZhciBNQUM0OF9SRUdFWCA9IC9eKD86W1xcZGEtZl17Mn06KXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17Mn0tKXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17NH1cXC4pezJ9W1xcZGEtZl17NH0kL2l1O1xudmFyIE1BQzY0X1JFR0VYID0gL14oPzpbXFxkYS1mXXsyfTopezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7M31bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezR9Oil7M31bXFxkYS1mXXs0fSQvaXU7XG52YXIgTUFDX1JFR0VYID0gL14oPzpbXFxkYS1mXXsyfTopezV9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezV9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7Mn1bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezJ9Oil7N31bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezJ9LSl7N31bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezR9XFwuKXszfVtcXGRhLWZdezR9JHxeKD86W1xcZGEtZl17NH06KXszfVtcXGRhLWZdezR9JC9pdTtcbnZhciBOQU5PX0lEX1JFR0VYID0gL15bXFx3LV0rJC91O1xudmFyIE9DVEFMX1JFR0VYID0gL14oPzowbyk/WzAtN10rJC91O1xudmFyIFJGQ19FTUFJTF9SRUdFWCA9IChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9wcmVmZXItdywgbm8tdXNlbGVzcy1lc2NhcGUsIHJlZ2V4cC9uby11c2VsZXNzLWVzY2FwZSwgcmVnZXhwL3JlcXVpcmUtdW5pY29kZS1yZWdleHBcbiAgL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC9cbik7XG52YXIgU0xVR19SRUdFWCA9IC9eW1xcZGEtel0rKD86Wy1fXVtcXGRhLXpdKykqJC91O1xudmFyIFVMSURfUkVHRVggPSAvXltcXGRhLWhqa21ucC10di16QS1ISktNTlAtVFYtWl17MjZ9JC91O1xudmFyIFVVSURfUkVHRVggPSAvXltcXGRhLWZdezh9KD86LVtcXGRhLWZdezR9KXszfS1bXFxkYS1mXXsxMn0kL2l1O1xuXG4vLyBzcmMvYWN0aW9ucy9iYXNlNjQvYmFzZTY0LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYmFzZTY0KG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJiYXNlNjRcIixcbiAgICByZWZlcmVuY2U6IGJhc2U2NCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogQkFTRTY0X1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiQmFzZTY0XCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9iaWMvYmljLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYmljKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJiaWNcIixcbiAgICByZWZlcmVuY2U6IGJpYyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogQklDX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiQklDXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9icmFuZC9icmFuZC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGJyYW5kKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJicmFuZFwiLFxuICAgIHJlZmVyZW5jZTogYnJhbmQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG5hbWUsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ieXRlcy9ieXRlcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICByZWZlcmVuY2U6IGJ5dGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aDIgPSBfZ2V0Qnl0ZUNvdW50KGRhdGFzZXQudmFsdWUpO1xuICAgICAgICBpZiAobGVuZ3RoMiAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImJ5dGVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtsZW5ndGgyfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jaGVjay9jaGVjay50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGNoZWNrKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiY2hlY2tcIixcbiAgICByZWZlcmVuY2U6IGNoZWNrLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jaGVjay9jaGVja0FzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY2hlY2tBc3luYyhyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImNoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiBjaGVja0FzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWF3YWl0IHRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2NoZWNrSXRlbXMvY2hlY2tJdGVtcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGNoZWNrSXRlbXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjaGVja19pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogY2hlY2tJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGF0YXNldC52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YXNldC52YWx1ZVtpbmRleF07XG4gICAgICAgICAgaWYgKCF0aGlzLnJlcXVpcmVtZW50KGl0ZW0sIGluZGV4LCBkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaXRlbVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgIGlucHV0OiBpdGVtLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogZGF0YXNldC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2NoZWNrSXRlbXMvY2hlY2tJdGVtc0FzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY2hlY2tJdGVtc0FzeW5jKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiY2hlY2tfaXRlbXNcIixcbiAgICByZWZlcmVuY2U6IGNoZWNrSXRlbXNBc3luYyxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVtZW50UmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIGRhdGFzZXQudmFsdWUubWFwKHRoaXMucmVxdWlyZW1lbnQpXG4gICAgICAgICk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkYXRhc2V0LnZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmICghcmVxdWlyZW1lbnRSZXN1bHRzW2luZGV4XSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRhdGFzZXQudmFsdWVbaW5kZXhdO1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaXRlbVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgIGlucHV0OiBpdGVtLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogZGF0YXNldC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2NyZWRpdENhcmQvY3JlZGl0Q2FyZC50c1xudmFyIENSRURJVF9DQVJEX1JFR0VYID0gL14oPzpcXGR7MTQsMTl9fFxcZHs0fSg/OiBcXGR7Myw2fSl7Miw0fXxcXGR7NH0oPzotXFxkezMsNn0pezIsNH0pJC91O1xudmFyIFNBTklUSVpFX1JFR0VYID0gL1stIF0vZ3U7XG52YXIgUFJPVklERVJfUkVHRVhfTElTVCA9IFtcbiAgLy8gQW1lcmljYW4gRXhwcmVzc1xuICAvXjNbNDddXFxkezEzfSQvdSxcbiAgLy8gRGluZXJzIENsdWJcbiAgL14zKD86MFswLTVdfFs2OF1cXGQpXFxkezExLDEzfSQvdSxcbiAgLy8gRGlzY292ZXJcbiAgL142KD86MDExfDVcXGR7Mn0pXFxkezEyLDE1fSQvdSxcbiAgLy8gSkNCXG4gIC9eKD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX0kL3UsXG4gIC8vIE1hc3RlcmNhcmRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zLWRldGVjdG9yL25vLXVuc2FmZS1yZWdleFxuICAvXjVbMS01XVxcZHsyfXwoPzoyMjJcXGR8MjJbMy05XVxcZHwyWzMtNl1cXGR7Mn18MjdbMDFdXFxkfDI3MjApXFxkezEyfSQvdSxcbiAgLy8gVW5pb25QYXlcbiAgL14oPzo2WzI3XVxcZHsxNCwxN318ODFcXGR7MTQsMTd9KSQvdSxcbiAgLy8gVmlzYVxuICAvXjRcXGR7MTJ9KD86XFxkezMsNn0pPyQvdVxuXTtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBjcmVkaXRDYXJkKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjcmVkaXRfY2FyZFwiLFxuICAgIHJlZmVyZW5jZTogY3JlZGl0Q2FyZCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudChpbnB1dCkge1xuICAgICAgbGV0IHNhbml0aXplZDtcbiAgICAgIHJldHVybiBDUkVESVRfQ0FSRF9SRUdFWC50ZXN0KGlucHV0KSAmJiAvLyBSZW1vdmUgYW55IGh5cGhlbnMgYW5kIGJsYW5rc1xuICAgICAgKHNhbml0aXplZCA9IGlucHV0LnJlcGxhY2UoU0FOSVRJWkVfUkVHRVgsIFwiXCIpKSAmJiAvLyBDaGVjayBpZiBpdCBtYXRjaGVzIGEgcHJvdmlkZXJcbiAgICAgIFBST1ZJREVSX1JFR0VYX0xJU1Quc29tZSgocmVnZXgyKSA9PiByZWdleDIudGVzdChzYW5pdGl6ZWQpKSAmJiAvLyBDaGVjayBpZiBwYXNzZXMgbHVobiBhbGdvcml0aG1cbiAgICAgIF9pc0x1aG5BbGdvKHNhbml0aXplZCk7XG4gICAgfSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJjcmVkaXQgY2FyZFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvY3VpZDIvY3VpZDIudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBjdWlkMihtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiY3VpZDJcIixcbiAgICByZWZlcmVuY2U6IGN1aWQyLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBDVUlEMl9SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIkN1aWQyXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9kZWNpbWFsL2RlY2ltYWwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWNpbWFsKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJkZWNpbWFsXCIsXG4gICAgcmVmZXJlbmNlOiBkZWNpbWFsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBERUNJTUFMX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZGVjaW1hbFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZGVzY3JpcHRpb24vZGVzY3JpcHRpb24udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbl8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcIm1ldGFkYXRhXCIsXG4gICAgdHlwZTogXCJkZXNjcmlwdGlvblwiLFxuICAgIHJlZmVyZW5jZTogZGVzY3JpcHRpb24sXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uX1xuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9kaWdpdHMvZGlnaXRzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGlnaXRzKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJkaWdpdHNcIixcbiAgICByZWZlcmVuY2U6IGRpZ2l0cyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogRElHSVRTX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZGlnaXRzXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9lbWFpbC9lbWFpbC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGVtYWlsKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJlbWFpbFwiLFxuICAgIHJlZmVyZW5jZTogZW1haWwsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQ6IEVNQUlMX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZW1haWxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2Vtb2ppL2Vtb2ppLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZW1vamkobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImVtb2ppXCIsXG4gICAgcmVmZXJlbmNlOiBlbW9qaSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogRU1PSklfUkVHRVgsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJlbW9qaVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZW1wdHkvZW1wdHkudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBlbXB0eShtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZW1wdHlcIixcbiAgICByZWZlcmVuY2U6IGVtcHR5LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBcIjBcIixcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibGVuZ3RoXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5sZW5ndGh9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZW5kc1dpdGgvZW5kc1dpdGgudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBlbmRzV2l0aChyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImVuZHNfd2l0aFwiLFxuICAgIHJlZmVyZW5jZTogZW5kc1dpdGgsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGBcIiR7cmVxdWlyZW1lbnR9XCJgLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICFkYXRhc2V0LnZhbHVlLmVuZHNXaXRoKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImVuZFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGBcIiR7ZGF0YXNldC52YWx1ZS5zbGljZSgtdGhpcy5yZXF1aXJlbWVudC5sZW5ndGgpfVwiYFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZW50cmllcy9lbnRyaWVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZW50cmllcyhyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImVudHJpZXNcIixcbiAgICByZWZlcmVuY2U6IGVudHJpZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKCFkYXRhc2V0LnR5cGVkKSByZXR1cm4gZGF0YXNldDtcbiAgICAgIGNvbnN0IGNvdW50ID0gT2JqZWN0LmtleXMoZGF0YXNldC52YWx1ZSkubGVuZ3RoO1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgY291bnQgIT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZW50cmllc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2NvdW50fWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2V2ZXJ5SXRlbS9ldmVyeUl0ZW0udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBldmVyeUl0ZW0ocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJldmVyeV9pdGVtXCIsXG4gICAgcmVmZXJlbmNlOiBldmVyeUl0ZW0sXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuZXZlcnkodGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaXRlbVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZXhjbHVkZXMvZXhjbHVkZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBleGNsdWRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgY29uc3QgcmVjZWl2ZWQgPSBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImV4Y2x1ZGVzXCIsXG4gICAgcmVmZXJlbmNlOiBleGNsdWRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlY2VpdmVkfWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5pbmNsdWRlcyh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJjb250ZW50XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHsgcmVjZWl2ZWQgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2ZpbHRlckl0ZW1zL2ZpbHRlckl0ZW1zLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZmlsdGVySXRlbXMob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwiZmlsdGVyX2l0ZW1zXCIsXG4gICAgcmVmZXJlbmNlOiBmaWx0ZXJJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLmZpbHRlcih0aGlzLm9wZXJhdGlvbik7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2ZpbmRJdGVtL2ZpbmRJdGVtLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZmluZEl0ZW0ob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwiZmluZF9pdGVtXCIsXG4gICAgcmVmZXJlbmNlOiBmaW5kSXRlbSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLmZpbmQodGhpcy5vcGVyYXRpb24pO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9maW5pdGUvZmluaXRlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZmluaXRlKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJmaW5pdGVcIixcbiAgICByZWZlcmVuY2U6IGZpbml0ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTnVtYmVyLmlzRmluaXRlLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImZpbml0ZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZmxhdm9yL2ZsYXZvci50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGZsYXZvcihuYW1lKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwiZmxhdm9yXCIsXG4gICAgcmVmZXJlbmNlOiBmbGF2b3IsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG5hbWUsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ncmFwaGVtZXMvZ3JhcGhlbWVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ3JhcGhlbWVzKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZ3JhcGhlbWVzXCIsXG4gICAgcmVmZXJlbmNlOiBncmFwaGVtZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBfZ2V0R3JhcGhlbWVDb3VudChkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGNvdW50ICE9PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZ3JhcGhlbWVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtjb3VudH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZ3RWYWx1ZS9ndFZhbHVlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ3RWYWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImd0X3ZhbHVlXCIsXG4gICAgcmVmZXJlbmNlOiBndFZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPiR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICEoZGF0YXNldC52YWx1ZSA+IHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInZhbHVlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRhc2V0LnZhbHVlLnRvSlNPTigpIDogX3N0cmluZ2lmeShkYXRhc2V0LnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaGFzaC9oYXNoLnRzXG52YXIgSEFTSF9MRU5HVEhTID0ge1xuICBtZDQ6IDMyLFxuICBtZDU6IDMyLFxuICBzaGExOiA0MCxcbiAgc2hhMjU2OiA2NCxcbiAgc2hhMzg0OiA5NixcbiAgc2hhNTEyOiAxMjgsXG4gIHJpcGVtZDEyODogMzIsXG4gIHJpcGVtZDE2MDogNDAsXG4gIHRpZ2VyMTI4OiAzMixcbiAgdGlnZXIxNjA6IDQwLFxuICB0aWdlcjE5MjogNDgsXG4gIGNyYzMyOiA4LFxuICBjcmMzMmI6IDgsXG4gIGFkbGVyMzI6IDhcbn07XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaGFzaCh0eXBlcywgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImhhc2hcIixcbiAgICByZWZlcmVuY2U6IGhhc2gsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQ6IFJlZ0V4cChcbiAgICAgIHR5cGVzLm1hcCgodHlwZSkgPT4gYF5bYS1mMC05XXske0hBU0hfTEVOR1RIU1t0eXBlXX19JGApLmpvaW4oXCJ8XCIpLFxuICAgICAgXCJpdVwiXG4gICAgKSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImhhc2hcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2hleGFkZWNpbWFsL2hleGFkZWNpbWFsLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaGV4YWRlY2ltYWwobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImhleGFkZWNpbWFsXCIsXG4gICAgcmVmZXJlbmNlOiBoZXhhZGVjaW1hbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSEVYQURFQ0lNQUxfUkVHRVgsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJoZXhhZGVjaW1hbFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaGV4Q29sb3IvaGV4Q29sb3IudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBoZXhDb2xvcihtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaGV4X2NvbG9yXCIsXG4gICAgcmVmZXJlbmNlOiBoZXhDb2xvcixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSEVYX0NPTE9SX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaGV4IGNvbG9yXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pbWVpL2ltZWkudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpbWVpKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpbWVpXCIsXG4gICAgcmVmZXJlbmNlOiBpbWVpLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50KGlucHV0KSB7XG4gICAgICByZXR1cm4gSU1FSV9SRUdFWC50ZXN0KGlucHV0KSAmJiBfaXNMdWhuQWxnbyhpbnB1dCk7XG4gICAgfSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJJTUVJXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pbmNsdWRlcy9pbmNsdWRlcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGluY2x1ZGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICBjb25zdCBleHBlY3RzID0gX3N0cmluZ2lmeShyZXF1aXJlbWVudCk7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpbmNsdWRlc1wiLFxuICAgIHJlZmVyZW5jZTogaW5jbHVkZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHMsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuaW5jbHVkZXModGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiY29udGVudFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAhJHtleHBlY3RzfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2ludGVnZXIvaW50ZWdlci50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGludGVnZXIobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICByZWZlcmVuY2U6IGludGVnZXIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IE51bWJlci5pc0ludGVnZXIsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW50ZWdlclwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXAvaXAudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpcChtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXBcIixcbiAgICByZWZlcmVuY2U6IGlwLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJUF9SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIklQXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pcHY0L2lwdjQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpcHY0KG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpcHY0XCIsXG4gICAgcmVmZXJlbmNlOiBpcHY0LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJUFY0X1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiSVB2NFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXB2Ni9pcHY2LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXB2NihtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXB2NlwiLFxuICAgIHJlZmVyZW5jZTogaXB2NixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVBWNl9SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIklQdjZcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb0RhdGUvaXNvRGF0ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGlzb0RhdGUobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb19kYXRlXCIsXG4gICAgcmVmZXJlbmNlOiBpc29EYXRlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fREFURV9SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImRhdGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb0RhdGVUaW1lL2lzb0RhdGVUaW1lLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXNvRGF0ZVRpbWUobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb19kYXRlX3RpbWVcIixcbiAgICByZWZlcmVuY2U6IGlzb0RhdGVUaW1lLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fREFURV9USU1FX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZGF0ZS10aW1lXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29UaW1lL2lzb1RpbWUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpc29UaW1lKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fdGltZVwiLFxuICAgIHJlZmVyZW5jZTogaXNvVGltZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVNPX1RJTUVfUkVHRVgsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0aW1lXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29UaW1lU2Vjb25kL2lzb1RpbWVTZWNvbmQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpc29UaW1lU2Vjb25kKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fdGltZV9zZWNvbmRcIixcbiAgICByZWZlcmVuY2U6IGlzb1RpbWVTZWNvbmQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19USU1FX1NFQ09ORF9SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInRpbWUtc2Vjb25kXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29UaW1lc3RhbXAvaXNvVGltZXN0YW1wLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXNvVGltZXN0YW1wKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fdGltZXN0YW1wXCIsXG4gICAgcmVmZXJlbmNlOiBpc29UaW1lc3RhbXAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19USU1FU1RBTVBfUkVHRVgsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0aW1lc3RhbXBcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb1dlZWsvaXNvV2Vlay50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGlzb1dlZWsobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb193ZWVrXCIsXG4gICAgcmVmZXJlbmNlOiBpc29XZWVrLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fV0VFS19SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIndlZWtcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2xlbmd0aC9sZW5ndGgudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBsZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJsZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IGxlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmxlbmd0aCAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9sdFZhbHVlL2x0VmFsdWUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBsdFZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibHRfdmFsdWVcIixcbiAgICByZWZlcmVuY2U6IGx0VmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA8JHtyZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IF9zdHJpbmdpZnkocmVxdWlyZW1lbnQpfWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIShkYXRhc2V0LnZhbHVlIDwgdGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidmFsdWVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGFzZXQudmFsdWUudG9KU09OKCkgOiBfc3RyaW5naWZ5KGRhdGFzZXQudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYWMvbWFjLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFjKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYWNcIixcbiAgICByZWZlcmVuY2U6IG1hYyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTUFDX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiTUFDXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYWM0OC9tYWM0OC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1hYzQ4KG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYWM0OFwiLFxuICAgIHJlZmVyZW5jZTogbWFjNDgsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IE1BQzQ4X1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiNDgtYml0IE1BQ1wiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWFjNjQvbWFjNjQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWM2NChtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWFjNjRcIixcbiAgICByZWZlcmVuY2U6IG1hYzY0LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBNQUM2NF9SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIjY0LWJpdCBNQUNcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21hcEl0ZW1zL21hcEl0ZW1zLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFwSXRlbXMob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwibWFwX2l0ZW1zXCIsXG4gICAgcmVmZXJlbmNlOiBtYXBJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLm1hcCh0aGlzLm9wZXJhdGlvbik7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heEJ5dGVzL21heEJ5dGVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWF4Qnl0ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYXhfYnl0ZXNcIixcbiAgICByZWZlcmVuY2U6IG1heEJ5dGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoMiA9IF9nZXRCeXRlQ291bnQoZGF0YXNldC52YWx1ZSk7XG4gICAgICAgIGlmIChsZW5ndGgyID4gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImJ5dGVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtsZW5ndGgyfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYXhFbnRyaWVzL21heEVudHJpZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYXhFbnRyaWVzKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWF4X2VudHJpZXNcIixcbiAgICByZWZlcmVuY2U6IG1heEVudHJpZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoIWRhdGFzZXQudHlwZWQpIHJldHVybiBkYXRhc2V0O1xuICAgICAgY29uc3QgY291bnQgPSBPYmplY3Qua2V5cyhkYXRhc2V0LnZhbHVlKS5sZW5ndGg7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBjb3VudCA+IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZW50cmllc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2NvdW50fWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heEdyYXBoZW1lcy9tYXhHcmFwaGVtZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYXhHcmFwaGVtZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYXhfZ3JhcGhlbWVzXCIsXG4gICAgcmVmZXJlbmNlOiBtYXhHcmFwaGVtZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IF9nZXRHcmFwaGVtZUNvdW50KGRhdGFzZXQudmFsdWUpO1xuICAgICAgICBpZiAoY291bnQgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZ3JhcGhlbWVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtjb3VudH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWF4TGVuZ3RoL21heExlbmd0aC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1heExlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1heF9sZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IG1heExlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYDw9JHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoID4gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYXhTaXplL21heFNpemUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYXhTaXplKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWF4X3NpemVcIixcbiAgICByZWZlcmVuY2U6IG1heFNpemUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLnNpemUgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInNpemVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLnNpemV9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWF4VmFsdWUvbWF4VmFsdWUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYXhWYWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1heF92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogbWF4VmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICEoZGF0YXNldC52YWx1ZSA8PSB0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heFdvcmRzL21heFdvcmRzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWF4V29yZHMobG9jYWxlcywgcmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYXhfd29yZHNcIixcbiAgICByZWZlcmVuY2U6IG1heFdvcmRzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgbG9jYWxlcyxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IF9nZXRXb3JkQ291bnQodGhpcy5sb2NhbGVzLCBkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGNvdW50ID4gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIndvcmRzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtjb3VudH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWV0YWRhdGEvbWV0YWRhdGEudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YV8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcIm1ldGFkYXRhXCIsXG4gICAgdHlwZTogXCJtZXRhZGF0YVwiLFxuICAgIHJlZmVyZW5jZTogbWV0YWRhdGEsXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhX1xuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9taW1lVHlwZS9taW1lVHlwZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1pbWVUeXBlKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWltZV90eXBlXCIsXG4gICAgcmVmZXJlbmNlOiBtaW1lVHlwZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogX2pvaW5FeHBlY3RzKFxuICAgICAgcmVxdWlyZW1lbnQubWFwKChvcHRpb24pID0+IGBcIiR7b3B0aW9ufVwiYCksXG4gICAgICBcInxcIlxuICAgICksXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQuaW5jbHVkZXMoZGF0YXNldC52YWx1ZS50eXBlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJNSU1FIHR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgXCIke2RhdGFzZXQudmFsdWUudHlwZX1cImBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbkJ5dGVzL21pbkJ5dGVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWluQnl0ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtaW5fYnl0ZXNcIixcbiAgICByZWZlcmVuY2U6IG1pbkJ5dGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoMiA9IF9nZXRCeXRlQ291bnQoZGF0YXNldC52YWx1ZSk7XG4gICAgICAgIGlmIChsZW5ndGgyIDwgdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImJ5dGVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtsZW5ndGgyfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9taW5FbnRyaWVzL21pbkVudHJpZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtaW5FbnRyaWVzKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWluX2VudHJpZXNcIixcbiAgICByZWZlcmVuY2U6IG1pbkVudHJpZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoIWRhdGFzZXQudHlwZWQpIHJldHVybiBkYXRhc2V0O1xuICAgICAgY29uc3QgY291bnQgPSBPYmplY3Qua2V5cyhkYXRhc2V0LnZhbHVlKS5sZW5ndGg7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBjb3VudCA8IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZW50cmllc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2NvdW50fWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbkdyYXBoZW1lcy9taW5HcmFwaGVtZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtaW5HcmFwaGVtZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtaW5fZ3JhcGhlbWVzXCIsXG4gICAgcmVmZXJlbmNlOiBtaW5HcmFwaGVtZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IF9nZXRHcmFwaGVtZUNvdW50KGRhdGFzZXQudmFsdWUpO1xuICAgICAgICBpZiAoY291bnQgPCB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZ3JhcGhlbWVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtjb3VudH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWluTGVuZ3RoL21pbkxlbmd0aC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1pbkxlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbl9sZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IG1pbkxlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYD49JHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoIDwgdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9taW5TaXplL21pblNpemUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtaW5TaXplKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWluX3NpemVcIixcbiAgICByZWZlcmVuY2U6IG1pblNpemUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLnNpemUgPCB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInNpemVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLnNpemV9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWluVmFsdWUvbWluVmFsdWUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtaW5WYWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbl92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogbWluVmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICEoZGF0YXNldC52YWx1ZSA+PSB0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbldvcmRzL21pbldvcmRzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWluV29yZHMobG9jYWxlcywgcmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtaW5fd29yZHNcIixcbiAgICByZWZlcmVuY2U6IG1pbldvcmRzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgbG9jYWxlcyxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IF9nZXRXb3JkQ291bnQodGhpcy5sb2NhbGVzLCBkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGNvdW50IDwgdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIndvcmRzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtjb3VudH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbXVsdGlwbGVPZi9tdWx0aXBsZU9mLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbXVsdGlwbGVPZihyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm11bHRpcGxlX29mXCIsXG4gICAgcmVmZXJlbmNlOiBtdWx0aXBsZU9mLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlICUgdGhpcy5yZXF1aXJlbWVudCAhPSAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIm11bHRpcGxlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9uYW5vaWQvbmFub2lkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbmFub2lkKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJuYW5vaWRcIixcbiAgICByZWZlcmVuY2U6IG5hbm9pZCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTkFOT19JRF9SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIk5hbm8gSURcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vbkVtcHR5L25vbkVtcHR5LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm9uRW1wdHkobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vbl9lbXB0eVwiLFxuICAgIHJlZmVyZW5jZTogbm9uRW1wdHksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IFwiITBcIixcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBcIjBcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm9ybWFsaXplL25vcm1hbGl6ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmb3JtKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwibm9ybWFsaXplXCIsXG4gICAgcmVmZXJlbmNlOiBub3JtYWxpemUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGZvcm0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUubm9ybWFsaXplKHRoaXMuZm9ybSk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vdEJ5dGVzL25vdEJ5dGVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm90Qnl0ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJub3RfYnl0ZXNcIixcbiAgICByZWZlcmVuY2U6IG5vdEJ5dGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBsZW5ndGgyID0gX2dldEJ5dGVDb3VudChkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGxlbmd0aDIgPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJieXRlc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7bGVuZ3RoMn1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90RW50cmllcy9ub3RFbnRyaWVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm90RW50cmllcyhyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF9lbnRyaWVzXCIsXG4gICAgcmVmZXJlbmNlOiBub3RFbnRyaWVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoIWRhdGFzZXQudHlwZWQpIHJldHVybiBkYXRhc2V0O1xuICAgICAgY29uc3QgY291bnQgPSBPYmplY3Qua2V5cyhkYXRhc2V0LnZhbHVlKS5sZW5ndGg7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBjb3VudCA9PT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJlbnRyaWVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7Y291bnR9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90R3JhcGhlbWVzL25vdEdyYXBoZW1lcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vdEdyYXBoZW1lcyhyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF9ncmFwaGVtZXNcIixcbiAgICByZWZlcmVuY2U6IG5vdEdyYXBoZW1lcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBfZ2V0R3JhcGhlbWVDb3VudChkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZ3JhcGhlbWVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtjb3VudH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90TGVuZ3RoL25vdExlbmd0aC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vdExlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF9sZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IG5vdExlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5sZW5ndGggPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibGVuZ3RoXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5sZW5ndGh9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90U2l6ZS9ub3RTaXplLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm90U2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF9zaXplXCIsXG4gICAgcmVmZXJlbmNlOiBub3RTaXplLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLnNpemUgPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2l6ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUuc2l6ZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub3RWYWx1ZS9ub3RWYWx1ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vdFZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibm90X3ZhbHVlXCIsXG4gICAgcmVmZXJlbmNlOiBub3RWYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogcmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gYCEke3JlcXVpcmVtZW50LnRvSlNPTigpfWAgOiBgISR7X3N0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiB0aGlzLnJlcXVpcmVtZW50IDw9IGRhdGFzZXQudmFsdWUgJiYgdGhpcy5yZXF1aXJlbWVudCA+PSBkYXRhc2V0LnZhbHVlKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInZhbHVlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRhc2V0LnZhbHVlLnRvSlNPTigpIDogX3N0cmluZ2lmeShkYXRhc2V0LnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90VmFsdWVzL25vdFZhbHVlcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vdFZhbHVlcyhyZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF92YWx1ZXNcIixcbiAgICByZWZlcmVuY2U6IG5vdFZhbHVlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke19qb2luRXhwZWN0cyhcbiAgICAgIHJlcXVpcmVtZW50Lm1hcChcbiAgICAgICAgKHZhbHVlMikgPT4gdmFsdWUyIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlMi50b0pTT04oKSA6IF9zdHJpbmdpZnkodmFsdWUyKVxuICAgICAgKSxcbiAgICAgIFwifFwiXG4gICAgKX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIHRoaXMucmVxdWlyZW1lbnQuc29tZShcbiAgICAgICAgKHZhbHVlMikgPT4gdmFsdWUyIDw9IGRhdGFzZXQudmFsdWUgJiYgdmFsdWUyID49IGRhdGFzZXQudmFsdWVcbiAgICAgICkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidmFsdWVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGFzZXQudmFsdWUudG9KU09OKCkgOiBfc3RyaW5naWZ5KGRhdGFzZXQudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub3RXb3Jkcy9ub3RXb3Jkcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vdFdvcmRzKGxvY2FsZXMsIHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibm90X3dvcmRzXCIsXG4gICAgcmVmZXJlbmNlOiBub3RXb3JkcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgbG9jYWxlcyxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IF9nZXRXb3JkQ291bnQodGhpcy5sb2NhbGVzLCBkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwid29yZHNcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGAke2NvdW50fWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9vY3RhbC9vY3RhbC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG9jdGFsKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJvY3RhbFwiLFxuICAgIHJlZmVyZW5jZTogb2N0YWwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IE9DVEFMX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwib2N0YWxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3BhcnNlSnNvbi9wYXJzZUpzb24udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBwYXJzZUpzb24oY29uZmlnMiwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJwYXJzZV9qc29uXCIsXG4gICAgcmVmZXJlbmNlOiBwYXJzZUpzb24sXG4gICAgY29uZmlnOiBjb25maWcyLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWczKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gSlNPTi5wYXJzZShkYXRhc2V0LnZhbHVlLCB0aGlzLmNvbmZpZz8ucmV2aXZlcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIkpTT05cIiwgZGF0YXNldCwgY29uZmlnMywge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGBcIiR7ZXJyb3IubWVzc2FnZX1cImBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcGFydGlhbENoZWNrL3V0aWxzL19pc1BhcnRpYWxseVR5cGVkL19pc1BhcnRpYWxseVR5cGVkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gX2lzUGFydGlhbGx5VHlwZWQoZGF0YXNldCwgcGF0aHMpIHtcbiAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBib3VuZCA9IE1hdGgubWluKHBhdGgubGVuZ3RoLCBpc3N1ZS5wYXRoPy5sZW5ndGggPz8gMCk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBib3VuZDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHBhdGhbaW5kZXhdICE9PSBpc3N1ZS5wYXRoW2luZGV4XS5rZXkgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgKHBhdGhbaW5kZXhdICE9PSBcIiRcIiB8fCBpc3N1ZS5wYXRoW2luZGV4XS50eXBlICE9PSBcImFycmF5XCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0eXBlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcGFydGlhbENoZWNrL3BhcnRpYWxDaGVjay50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHBhcnRpYWxDaGVjayhwYXRocywgcmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJwYXJ0aWFsX2NoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiBwYXJ0aWFsQ2hlY2ssXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcGF0aHMsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKChkYXRhc2V0LnR5cGVkIHx8IF9pc1BhcnRpYWxseVR5cGVkKGRhdGFzZXQsIHBhdGhzKSkgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3BhcnRpYWxDaGVjay9wYXJ0aWFsQ2hlY2tBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHBhcnRpYWxDaGVja0FzeW5jKHBhdGhzLCByZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInBhcnRpYWxfY2hlY2tcIixcbiAgICByZWZlcmVuY2U6IHBhcnRpYWxDaGVja0FzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcGF0aHMsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKChkYXRhc2V0LnR5cGVkIHx8IF9pc1BhcnRpYWxseVR5cGVkKGRhdGFzZXQsIHBhdGhzKSkgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgIWF3YWl0IHRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3Jhd0NoZWNrL3Jhd0NoZWNrLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcmF3Q2hlY2soYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJyYXdfY2hlY2tcIixcbiAgICByZWZlcmVuY2U6IHJhd0NoZWNrLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGFjdGlvbih7XG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIGNvbmZpZzogY29uZmlnMixcbiAgICAgICAgYWRkSXNzdWU6IChpbmZvKSA9PiBfYWRkSXNzdWUodGhpcywgaW5mbz8ubGFiZWwgPz8gXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyLCBpbmZvKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3Jhd0NoZWNrL3Jhd0NoZWNrQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByYXdDaGVja0FzeW5jKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwicmF3X2NoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiByYXdDaGVja0FzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgYXdhaXQgYWN0aW9uKHtcbiAgICAgICAgZGF0YXNldCxcbiAgICAgICAgY29uZmlnOiBjb25maWcyLFxuICAgICAgICBhZGRJc3N1ZTogKGluZm8pID0+IF9hZGRJc3N1ZSh0aGlzLCBpbmZvPy5sYWJlbCA/PyBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIsIGluZm8pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmF3VHJhbnNmb3JtL3Jhd1RyYW5zZm9ybS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJhd1RyYW5zZm9ybShhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJyYXdfdHJhbnNmb3JtXCIsXG4gICAgcmVmZXJlbmNlOiByYXdUcmFuc2Zvcm0sXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGFjdGlvbih7XG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIGNvbmZpZzogY29uZmlnMixcbiAgICAgICAgYWRkSXNzdWU6IChpbmZvKSA9PiBfYWRkSXNzdWUodGhpcywgaW5mbz8ubGFiZWwgPz8gXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyLCBpbmZvKSxcbiAgICAgICAgTkVWRVI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBvdXRwdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3Jhd1RyYW5zZm9ybS9yYXdUcmFuc2Zvcm1Bc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJhd1RyYW5zZm9ybUFzeW5jKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInJhd190cmFuc2Zvcm1cIixcbiAgICByZWZlcmVuY2U6IHJhd1RyYW5zZm9ybUFzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGFjdGlvbih7XG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIGNvbmZpZzogY29uZmlnMixcbiAgICAgICAgYWRkSXNzdWU6IChpbmZvKSA9PiBfYWRkSXNzdWUodGhpcywgaW5mbz8ubGFiZWwgPz8gXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyLCBpbmZvKSxcbiAgICAgICAgTkVWRVI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBvdXRwdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3JlYWRvbmx5L3JlYWRvbmx5LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcmVhZG9ubHkoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwicmVhZG9ubHlcIixcbiAgICByZWZlcmVuY2U6IHJlYWRvbmx5LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3JlZHVjZUl0ZW1zL3JlZHVjZUl0ZW1zLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcmVkdWNlSXRlbXMob3BlcmF0aW9uLCBpbml0aWFsKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwicmVkdWNlX2l0ZW1zXCIsXG4gICAgcmVmZXJlbmNlOiByZWR1Y2VJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIGluaXRpYWwsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUucmVkdWNlKHRoaXMub3BlcmF0aW9uLCB0aGlzLmluaXRpYWwpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yZWdleC9yZWdleC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJlZ2V4KHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwicmVnZXhcIixcbiAgICByZWZlcmVuY2U6IHJlZ2V4LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZm9ybWF0XCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yZXR1cm5zL3JldHVybnMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByZXR1cm5zKHNjaGVtYSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInJldHVybnNcIixcbiAgICByZWZlcmVuY2U6IHJldHVybnMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHNjaGVtYSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBmdW5jID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSAoLi4uYXJnc18pID0+IHtcbiAgICAgICAgY29uc3QgcmV0dXJuc0RhdGFzZXQgPSB0aGlzLnNjaGVtYVtcIn5ydW5cIl0oXG4gICAgICAgICAgeyB2YWx1ZTogZnVuYyguLi5hcmdzXykgfSxcbiAgICAgICAgICBjb25maWcyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyZXR1cm5zRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsaUVycm9yKHJldHVybnNEYXRhc2V0Lmlzc3Vlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybnNEYXRhc2V0LnZhbHVlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmV0dXJucy9yZXR1cm5zQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByZXR1cm5zQXN5bmMoc2NoZW1hKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwicmV0dXJuc1wiLFxuICAgIHJlZmVyZW5jZTogcmV0dXJuc0FzeW5jLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBzY2hlbWEsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgZnVuYyA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gYXN5bmMgKC4uLmFyZ3NfKSA9PiB7XG4gICAgICAgIGNvbnN0IHJldHVybnNEYXRhc2V0ID0gYXdhaXQgdGhpcy5zY2hlbWFbXCJ+cnVuXCJdKFxuICAgICAgICAgIHsgdmFsdWU6IGF3YWl0IGZ1bmMoLi4uYXJnc18pIH0sXG4gICAgICAgICAgY29uZmlnMlxuICAgICAgICApO1xuICAgICAgICBpZiAocmV0dXJuc0RhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbGlFcnJvcihyZXR1cm5zRGF0YXNldC5pc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5zRGF0YXNldC52YWx1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3JmY0VtYWlsL3JmY0VtYWlsLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcmZjRW1haWwobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInJmY19lbWFpbFwiLFxuICAgIHJlZmVyZW5jZTogcmZjRW1haWwsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQ6IFJGQ19FTUFJTF9SRUdFWCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImVtYWlsXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zYWZlSW50ZWdlci9zYWZlSW50ZWdlci50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNhZmVJbnRlZ2VyKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzYWZlX2ludGVnZXJcIixcbiAgICByZWZlcmVuY2U6IHNhZmVJbnRlZ2VyLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBOdW1iZXIuaXNTYWZlSW50ZWdlcixcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJzYWZlIGludGVnZXJcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3NpemUvc2l6ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNpemUocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzaXplXCIsXG4gICAgcmVmZXJlbmNlOiBzaXplLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUuc2l6ZSAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJzaXplXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5zaXplfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3NsdWcvc2x1Zy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNsdWcobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInNsdWdcIixcbiAgICByZWZlcmVuY2U6IHNsdWcsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IFNMVUdfUkVHRVgsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJzbHVnXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zb21lSXRlbS9zb21lSXRlbS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNvbWVJdGVtKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwic29tZV9pdGVtXCIsXG4gICAgcmVmZXJlbmNlOiBzb21lSXRlbSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhZGF0YXNldC52YWx1ZS5zb21lKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIml0ZW1cIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3NvcnRJdGVtcy9zb3J0SXRlbXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzb3J0SXRlbXMob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwic29ydF9pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogc29ydEl0ZW1zLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcGVyYXRpb24sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUuc29ydCh0aGlzLm9wZXJhdGlvbik7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3N0YXJ0c1dpdGgvc3RhcnRzV2l0aC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzdGFydHNfd2l0aFwiLFxuICAgIHJlZmVyZW5jZTogc3RhcnRzV2l0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYFwiJHtyZXF1aXJlbWVudH1cImAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuc3RhcnRzV2l0aCh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJzdGFydFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGBcIiR7ZGF0YXNldC52YWx1ZS5zbGljZSgwLCB0aGlzLnJlcXVpcmVtZW50Lmxlbmd0aCl9XCJgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zdHJpbmdpZnlKc29uL3N0cmluZ2lmeUpzb24udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzdHJpbmdpZnlKc29uKGNvbmZpZzIsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwic3RyaW5naWZ5X2pzb25cIixcbiAgICByZWZlcmVuY2U6IHN0cmluZ2lmeUpzb24sXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgY29uZmlnOiBjb25maWcyLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWczKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICB0aGlzLmNvbmZpZz8ucmVwbGFjZXIsXG4gICAgICAgICAgdGhpcy5jb25maWc/LnNwYWNlXG4gICAgICAgICk7XG4gICAgICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIkpTT05cIiwgZGF0YXNldCwgY29uZmlnMyk7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBvdXRwdXQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIkpTT05cIiwgZGF0YXNldCwgY29uZmlnMywge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGBcIiR7ZXJyb3IubWVzc2FnZX1cImBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdGl0bGUvdGl0bGUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0aXRsZSh0aXRsZV8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcIm1ldGFkYXRhXCIsXG4gICAgdHlwZTogXCJ0aXRsZVwiLFxuICAgIHJlZmVyZW5jZTogdGl0bGUsXG4gICAgdGl0bGU6IHRpdGxlX1xuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90b0xvd2VyQ2FzZS90b0xvd2VyQ2FzZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRvX2xvd2VyX2Nhc2VcIixcbiAgICByZWZlcmVuY2U6IHRvTG93ZXJDYXNlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90b01heFZhbHVlL3RvTWF4VmFsdWUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0b01heFZhbHVlKHJlcXVpcmVtZW50KSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidG9fbWF4X3ZhbHVlXCIsXG4gICAgcmVmZXJlbmNlOiB0b01heFZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZSA+IHRoaXMucmVxdWlyZW1lbnQgPyB0aGlzLnJlcXVpcmVtZW50IDogZGF0YXNldC52YWx1ZTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdG9NaW5WYWx1ZS90b01pblZhbHVlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdG9NaW5WYWx1ZShyZXF1aXJlbWVudCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRvX21pbl92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogdG9NaW5WYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUgPCB0aGlzLnJlcXVpcmVtZW50ID8gdGhpcy5yZXF1aXJlbWVudCA6IGRhdGFzZXQudmFsdWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RvVXBwZXJDYXNlL3RvVXBwZXJDYXNlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdG9VcHBlckNhc2UoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidG9fdXBwZXJfY2FzZVwiLFxuICAgIHJlZmVyZW5jZTogdG9VcHBlckNhc2UsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyYW5zZm9ybS90cmFuc2Zvcm0udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0cmFuc2Zvcm0ob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidHJhbnNmb3JtXCIsXG4gICAgcmVmZXJlbmNlOiB0cmFuc2Zvcm0sXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gdGhpcy5vcGVyYXRpb24oZGF0YXNldC52YWx1ZSk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyYW5zZm9ybS90cmFuc2Zvcm1Bc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHRyYW5zZm9ybUFzeW5jKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRyYW5zZm9ybVwiLFxuICAgIHJlZmVyZW5jZTogdHJhbnNmb3JtQXN5bmMsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgb3BlcmF0aW9uLFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBhd2FpdCB0aGlzLm9wZXJhdGlvbihkYXRhc2V0LnZhbHVlKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdHJpbS90cmltLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdHJpbSgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0cmltXCIsXG4gICAgcmVmZXJlbmNlOiB0cmltLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50cmltKCk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyaW1FbmQvdHJpbUVuZC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHRyaW1FbmQoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidHJpbV9lbmRcIixcbiAgICByZWZlcmVuY2U6IHRyaW1FbmQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnRyaW1FbmQoKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdHJpbVN0YXJ0L3RyaW1TdGFydC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHRyaW1TdGFydCgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0cmltX3N0YXJ0XCIsXG4gICAgcmVmZXJlbmNlOiB0cmltU3RhcnQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnRyaW1TdGFydCgpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy91bGlkL3VsaWQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB1bGlkKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJ1bGlkXCIsXG4gICAgcmVmZXJlbmNlOiB1bGlkLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBVTElEX1JFR0VYLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiVUxJRFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdXJsL3VybC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHVybChtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwidXJsXCIsXG4gICAgcmVmZXJlbmNlOiB1cmwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQoaW5wdXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBVUkwoaW5wdXQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJVUkxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3V1aWQvdXVpZC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHV1aWQobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInV1aWRcIixcbiAgICByZWZlcmVuY2U6IHV1aWQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IFVVSURfUkVHRVgsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJVVUlEXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy92YWx1ZS92YWx1ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICByZWZlcmVuY2U6IHZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiByZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IF9zdHJpbmdpZnkocmVxdWlyZW1lbnQpLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICEodGhpcy5yZXF1aXJlbWVudCA8PSBkYXRhc2V0LnZhbHVlICYmIHRoaXMucmVxdWlyZW1lbnQgPj0gZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidmFsdWVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGFzZXQudmFsdWUudG9KU09OKCkgOiBfc3RyaW5naWZ5KGRhdGFzZXQudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy92YWx1ZXMvdmFsdWVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdmFsdWVzKHJlcXVpcmVtZW50LCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwidmFsdWVzXCIsXG4gICAgcmVmZXJlbmNlOiB2YWx1ZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAke19qb2luRXhwZWN0cyhcbiAgICAgIHJlcXVpcmVtZW50Lm1hcChcbiAgICAgICAgKHZhbHVlMikgPT4gdmFsdWUyIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlMi50b0pTT04oKSA6IF9zdHJpbmdpZnkodmFsdWUyKVxuICAgICAgKSxcbiAgICAgIFwifFwiXG4gICAgKX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnNvbWUoXG4gICAgICAgICh2YWx1ZTIpID0+IHZhbHVlMiA8PSBkYXRhc2V0LnZhbHVlICYmIHZhbHVlMiA+PSBkYXRhc2V0LnZhbHVlXG4gICAgICApKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInZhbHVlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRhc2V0LnZhbHVlLnRvSlNPTigpIDogX3N0cmluZ2lmeShkYXRhc2V0LnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvd29yZHMvd29yZHMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB3b3Jkcyhsb2NhbGVzLCByZXF1aXJlbWVudCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIndvcmRzXCIsXG4gICAgcmVmZXJlbmNlOiB3b3JkcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCR7cmVxdWlyZW1lbnR9YCxcbiAgICBsb2NhbGVzLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gX2dldFdvcmRDb3VudCh0aGlzLmxvY2FsZXMsIGRhdGFzZXQudmFsdWUpO1xuICAgICAgICBpZiAoY291bnQgIT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ3b3Jkc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7Y291bnR9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2Fzc2VydC9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydChzY2hlbWEsIGlucHV0KSB7XG4gIGNvbnN0IGlzc3VlcyA9IHNjaGVtYVtcIn5ydW5cIl0oeyB2YWx1ZTogaW5wdXQgfSwgeyBhYm9ydEVhcmx5OiB0cnVlIH0pLmlzc3VlcztcbiAgaWYgKGlzc3Vlcykge1xuICAgIHRocm93IG5ldyBWYWxpRXJyb3IoaXNzdWVzKTtcbiAgfVxufVxuXG4vLyBzcmMvbWV0aG9kcy9jb25maWcvY29uZmlnLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY29uZmlnKHNjaGVtYSwgY29uZmlnMikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZ18pIHtcbiAgICAgIHJldHVybiBzY2hlbWFbXCJ+cnVuXCJdKGRhdGFzZXQsIHsgLi4uY29uZmlnXywgLi4uY29uZmlnMiB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrL2dldEZhbGxiYWNrLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2soc2NoZW1hLCBkYXRhc2V0LCBjb25maWcyKSB7XG4gIHJldHVybiB0eXBlb2Ygc2NoZW1hLmZhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHNjaGVtYS5mYWxsYmFjayhkYXRhc2V0LCBjb25maWcyKVxuICApIDogKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBzY2hlbWEuZmFsbGJhY2tcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZmFsbGJhY2svZmFsbGJhY2sudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBmYWxsYmFjayhzY2hlbWEsIGZhbGxiYWNrMikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBmYWxsYmFjazogZmFsbGJhY2syLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3Qgb3V0cHV0RGF0YXNldCA9IHNjaGVtYVtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICByZXR1cm4gb3V0cHV0RGF0YXNldC5pc3N1ZXMgPyB7IHR5cGVkOiB0cnVlLCB2YWx1ZTogZ2V0RmFsbGJhY2sodGhpcywgb3V0cHV0RGF0YXNldCwgY29uZmlnMikgfSA6IG91dHB1dERhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mYWxsYmFjay9mYWxsYmFja0FzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZmFsbGJhY2tBc3luYyhzY2hlbWEsIGZhbGxiYWNrMikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBmYWxsYmFjazogZmFsbGJhY2syLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3Qgb3V0cHV0RGF0YXNldCA9IGF3YWl0IHNjaGVtYVtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICByZXR1cm4gb3V0cHV0RGF0YXNldC5pc3N1ZXMgPyB7XG4gICAgICAgIHR5cGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogYXdhaXQgZ2V0RmFsbGJhY2sodGhpcywgb3V0cHV0RGF0YXNldCwgY29uZmlnMilcbiAgICAgIH0gOiBvdXRwdXREYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZmxhdHRlbi9mbGF0dGVuLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZmxhdHRlbihpc3N1ZXMpIHtcbiAgY29uc3QgZmxhdEVycm9ycyA9IHt9O1xuICBmb3IgKGNvbnN0IGlzc3VlIG9mIGlzc3Vlcykge1xuICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICBjb25zdCBkb3RQYXRoID0gZ2V0RG90UGF0aChpc3N1ZSk7XG4gICAgICBpZiAoZG90UGF0aCkge1xuICAgICAgICBpZiAoIWZsYXRFcnJvcnMubmVzdGVkKSB7XG4gICAgICAgICAgZmxhdEVycm9ycy5uZXN0ZWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhdEVycm9ycy5uZXN0ZWRbZG90UGF0aF0pIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtkb3RQYXRoXS5wdXNoKGlzc3VlLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXRFcnJvcnMubmVzdGVkW2RvdFBhdGhdID0gW2lzc3VlLm1lc3NhZ2VdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmxhdEVycm9ycy5vdGhlcikge1xuICAgICAgICAgIGZsYXRFcnJvcnMub3RoZXIucHVzaChpc3N1ZS5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLm90aGVyID0gW2lzc3VlLm1lc3NhZ2VdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmbGF0RXJyb3JzLnJvb3QpIHtcbiAgICAgICAgZmxhdEVycm9ycy5yb290LnB1c2goaXNzdWUubWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0RXJyb3JzLnJvb3QgPSBbaXNzdWUubWVzc2FnZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmbGF0RXJyb3JzO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mb3J3YXJkL2ZvcndhcmQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBmb3J3YXJkKGFjdGlvbiwgcGF0aCkge1xuICByZXR1cm4ge1xuICAgIC4uLmFjdGlvbixcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBwcmV2SXNzdWVzID0gZGF0YXNldC5pc3N1ZXMgJiYgWy4uLmRhdGFzZXQuaXNzdWVzXTtcbiAgICAgIGRhdGFzZXQgPSBhY3Rpb25bXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICBpZiAoIXByZXZJc3N1ZXM/LmluY2x1ZGVzKGlzc3VlKSkge1xuICAgICAgICAgICAgbGV0IHBhdGhJbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXRoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhWYWx1ZSA9IHBhdGhJbnB1dFtrZXldO1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF0aElucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC5wdXNoKHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXBhdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhdGhJbnB1dCA9IHBhdGhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZm9yd2FyZC9mb3J3YXJkQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBmb3J3YXJkQXN5bmMoYWN0aW9uLCBwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgLi4uYWN0aW9uLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IHByZXZJc3N1ZXMgPSBkYXRhc2V0Lmlzc3VlcyAmJiBbLi4uZGF0YXNldC5pc3N1ZXNdO1xuICAgICAgZGF0YXNldCA9IGF3YWl0IGFjdGlvbltcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgIGlmICghcHJldklzc3Vlcz8uaW5jbHVkZXMoaXNzdWUpKSB7XG4gICAgICAgICAgICBsZXQgcGF0aElucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhdGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aFZhbHVlID0gcGF0aElucHV0W2tleV07XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXRoSW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXRoVmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnB1c2gocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGF0aElucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0L2dldERlZmF1bHQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBnZXREZWZhdWx0KHNjaGVtYSwgZGF0YXNldCwgY29uZmlnMikge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHNjaGVtYS5kZWZhdWx0KGRhdGFzZXQsIGNvbmZpZzIpXG4gICkgOiAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHNjaGVtYS5kZWZhdWx0XG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHRzL2dldERlZmF1bHRzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ2V0RGVmYXVsdHMoc2NoZW1hKSB7XG4gIGlmIChcImVudHJpZXNcIiBpbiBzY2hlbWEpIHtcbiAgICBjb25zdCBvYmplY3QyID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICAgIG9iamVjdDJba2V5XSA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0cyhzY2hlbWEuZW50cmllc1trZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDI7XG4gIH1cbiAgaWYgKFwiaXRlbXNcIiBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm1hcChnZXREZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGdldERlZmF1bHQoc2NoZW1hKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RGVmYXVsdHMvZ2V0RGVmYXVsdHNBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmFzeW5jIGZ1bmN0aW9uIGdldERlZmF1bHRzQXN5bmMoc2NoZW1hKSB7XG4gIGlmIChcImVudHJpZXNcIiBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXdhaXQgLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRzQXN5bmModmFsdWUyKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgaWYgKFwiaXRlbXNcIiBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2NoZW1hLml0ZW1zLm1hcChnZXREZWZhdWx0c0FzeW5jKSk7XG4gIH1cbiAgcmV0dXJuIGdldERlZmF1bHQoc2NoZW1hKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RGVzY3JpcHRpb24vZ2V0RGVzY3JpcHRpb24udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBnZXREZXNjcmlwdGlvbihzY2hlbWEpIHtcbiAgcmV0dXJuIF9nZXRMYXN0TWV0YWRhdGEoc2NoZW1hLCBcImRlc2NyaXB0aW9uXCIpO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFja3MvZ2V0RmFsbGJhY2tzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tzKHNjaGVtYSkge1xuICBpZiAoXCJlbnRyaWVzXCIgaW4gc2NoZW1hKSB7XG4gICAgY29uc3Qgb2JqZWN0MiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5lbnRyaWVzKSB7XG4gICAgICBvYmplY3QyW2tleV0gPSAvKiBAX19QVVJFX18gKi8gZ2V0RmFsbGJhY2tzKHNjaGVtYS5lbnRyaWVzW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0MjtcbiAgfVxuICBpZiAoXCJpdGVtc1wiIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEuaXRlbXMubWFwKGdldEZhbGxiYWNrcyk7XG4gIH1cbiAgcmV0dXJuIGdldEZhbGxiYWNrKHNjaGVtYSk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrcy9nZXRGYWxsYmFja3NBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmFzeW5jIGZ1bmN0aW9uIGdldEZhbGxiYWNrc0FzeW5jKHNjaGVtYSkge1xuICBpZiAoXCJlbnRyaWVzXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykubWFwKGFzeW5jIChba2V5LCB2YWx1ZTJdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGF3YWl0IC8qIEBfX1BVUkVfXyAqLyBnZXRGYWxsYmFja3NBc3luYyh2YWx1ZTIpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBpZiAoXCJpdGVtc1wiIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChzY2hlbWEuaXRlbXMubWFwKGdldEZhbGxiYWNrc0FzeW5jKSk7XG4gIH1cbiAgcmV0dXJuIGdldEZhbGxiYWNrKHNjaGVtYSk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldE1ldGFkYXRhL2dldE1ldGFkYXRhLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ2V0TWV0YWRhdGEoc2NoZW1hKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBkZXB0aEZpcnN0TWVyZ2Uoc2NoZW1hMikge1xuICAgIGlmIChcInBpcGVcIiBpbiBzY2hlbWEyKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2NoZW1hMi5waXBlKSB7XG4gICAgICAgIGlmIChpdGVtLmtpbmQgPT09IFwic2NoZW1hXCIgJiYgXCJwaXBlXCIgaW4gaXRlbSkge1xuICAgICAgICAgIGRlcHRoRmlyc3RNZXJnZShpdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLmtpbmQgPT09IFwibWV0YWRhdGFcIiAmJiBpdGVtLnR5cGUgPT09IFwibWV0YWRhdGFcIikge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCBpdGVtLm1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXB0aEZpcnN0TWVyZ2Uoc2NoZW1hKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0VGl0bGUvZ2V0VGl0bGUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBnZXRUaXRsZShzY2hlbWEpIHtcbiAgcmV0dXJuIF9nZXRMYXN0TWV0YWRhdGEoc2NoZW1hLCBcInRpdGxlXCIpO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9pcy9pcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGlzKHNjaGVtYSwgaW5wdXQpIHtcbiAgcmV0dXJuICFzY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0IH0sIHsgYWJvcnRFYXJseTogdHJ1ZSB9KS5pc3N1ZXM7XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FueS9hbnkudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBhbnkoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImFueVwiLFxuICAgIHJlZmVyZW5jZTogYW55LFxuICAgIGV4cGVjdHM6IFwiYW55XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FycmF5L2FycmF5LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYXJyYXkoaXRlbSwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICByZWZlcmVuY2U6IGFycmF5LFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBpbnB1dC5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IHRoaXMuaXRlbVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpO1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYXJyYXkvYXJyYXlBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGFycmF5QXN5bmMoaXRlbSwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICByZWZlcmVuY2U6IGFycmF5QXN5bmMsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGl0ZW0sXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlbURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgaW5wdXQubWFwKCh2YWx1ZTIpID0+IHRoaXMuaXRlbVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBpdGVtRGF0YXNldHMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gaXRlbURhdGFzZXRzW2tleV07XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmlnaW50L2JpZ2ludC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGJpZ2ludChtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICByZWZlcmVuY2U6IGJpZ2ludCxcbiAgICBleHBlY3RzOiBcImJpZ2ludFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2Jsb2IvYmxvYi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGJsb2IobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiYmxvYlwiLFxuICAgIHJlZmVyZW5jZTogYmxvYixcbiAgICBleHBlY3RzOiBcIkJsb2JcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ib29sZWFuL2Jvb2xlYW4udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBib29sZWFuKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICByZWZlcmVuY2U6IGJvb2xlYW4sXG4gICAgZXhwZWN0czogXCJib29sZWFuXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2N1c3RvbS9jdXN0b20udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBjdXN0b20oY2hlY2syLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJjdXN0b21cIixcbiAgICByZWZlcmVuY2U6IGN1c3RvbSxcbiAgICBleHBlY3RzOiBcInVua25vd25cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgY2hlY2s6IGNoZWNrMixcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrKGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvY3VzdG9tL2N1c3RvbUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY3VzdG9tQXN5bmMoY2hlY2syLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJjdXN0b21cIixcbiAgICByZWZlcmVuY2U6IGN1c3RvbUFzeW5jLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGNoZWNrOiBjaGVjazIsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoYXdhaXQgdGhpcy5jaGVjayhkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2RhdGUvZGF0ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRhdGUobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgIHJlZmVyZW5jZTogZGF0ZSxcbiAgICBleHBlY3RzOiBcIkRhdGVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgaWYgKCFpc05hTihkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6ICdcIkludmFsaWQgRGF0ZVwiJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9lbnVtL2VudW0udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBlbnVtXyhlbnVtX18sIG1lc3NhZ2UyKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZW51bV9fKSB7XG4gICAgaWYgKGAkeytrZXl9YCAhPT0ga2V5IHx8IHR5cGVvZiBlbnVtX19ba2V5XSAhPT0gXCJzdHJpbmdcIiB8fCAhT2JqZWN0LmlzKGVudW1fX1tlbnVtX19ba2V5XV0sICtrZXkpKSB7XG4gICAgICBvcHRpb25zLnB1c2goZW51bV9fW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgcmVmZXJlbmNlOiBlbnVtXyxcbiAgICBleHBlY3RzOiBfam9pbkV4cGVjdHMob3B0aW9ucy5tYXAoX3N0cmluZ2lmeSksIFwifFwiKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW51bTogZW51bV9fLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmluY2x1ZGVzKGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvZXhhY3RPcHRpb25hbC9leGFjdE9wdGlvbmFsLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZXhhY3RPcHRpb25hbCh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJleGFjdF9vcHRpb25hbFwiLFxuICAgIHJlZmVyZW5jZTogZXhhY3RPcHRpb25hbCxcbiAgICBleHBlY3RzOiB3cmFwcGVkLmV4cGVjdHMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2V4YWN0T3B0aW9uYWwvZXhhY3RPcHRpb25hbEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZXhhY3RPcHRpb25hbEFzeW5jKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImV4YWN0X29wdGlvbmFsXCIsXG4gICAgcmVmZXJlbmNlOiBleGFjdE9wdGlvbmFsQXN5bmMsXG4gICAgZXhwZWN0czogd3JhcHBlZC5leHBlY3RzLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ZpbGUvZmlsZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGZpbGUobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgIHJlZmVyZW5jZTogZmlsZSxcbiAgICBleHBlY3RzOiBcIkZpbGVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9mdW5jdGlvbi9mdW5jdGlvbi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGZ1bmN0aW9uXyhtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIHJlZmVyZW5jZTogZnVuY3Rpb25fLFxuICAgIGV4cGVjdHM6IFwiRnVuY3Rpb25cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFzZXQudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2luc3RhbmNlL2luc3RhbmNlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaW5zdGFuY2UoY2xhc3NfLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJpbnN0YW5jZVwiLFxuICAgIHJlZmVyZW5jZTogaW5zdGFuY2UsXG4gICAgZXhwZWN0czogY2xhc3NfLm5hbWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGNsYXNzOiBjbGFzc18sXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIHRoaXMuY2xhc3MpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9pbnRlcnNlY3QvdXRpbHMvX21lcmdlL19tZXJnZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9tZXJnZSh2YWx1ZTEsIHZhbHVlMikge1xuICBpZiAodHlwZW9mIHZhbHVlMSA9PT0gdHlwZW9mIHZhbHVlMikge1xuICAgIGlmICh2YWx1ZTEgPT09IHZhbHVlMiB8fCB2YWx1ZTEgaW5zdGFuY2VvZiBEYXRlICYmIHZhbHVlMiBpbnN0YW5jZW9mIERhdGUgJiYgK3ZhbHVlMSA9PT0gK3ZhbHVlMikge1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlMSB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUxICYmIHZhbHVlMiAmJiB2YWx1ZTEuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiB2YWx1ZTIuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUyKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdmFsdWUxKSB7XG4gICAgICAgICAgY29uc3QgZGF0YXNldCA9IC8qIEBfX1BVUkVfXyAqLyBfbWVyZ2UodmFsdWUxW2tleV0sIHZhbHVlMltrZXldKTtcbiAgICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlMVtrZXldID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZTFba2V5XSA9IHZhbHVlMltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUxIH07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpKSB7XG4gICAgICBpZiAodmFsdWUxLmxlbmd0aCA9PT0gdmFsdWUyLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdmFsdWUxLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSAvKiBAX19QVVJFX18gKi8gX21lcmdlKHZhbHVlMVtpbmRleF0sIHZhbHVlMltpbmRleF0pO1xuICAgICAgICAgIGlmIChkYXRhc2V0Lmlzc3VlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUxW2luZGV4XSA9IGRhdGFzZXQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlMSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBpc3N1ZTogdHJ1ZSB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9pbnRlcnNlY3QvaW50ZXJzZWN0LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaW50ZXJzZWN0KG9wdGlvbnMsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImludGVyc2VjdFwiLFxuICAgIHJlZmVyZW5jZTogaW50ZXJzZWN0LFxuICAgIGV4cGVjdHM6IF9qb2luRXhwZWN0cyhcbiAgICAgIG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSxcbiAgICAgIFwiJlwiXG4gICAgKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBvcHRpb25EYXRhc2V0ID0gc2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiBpbnB1dCB9LCBjb25maWcyKTtcbiAgICAgICAgICBpZiAob3B0aW9uRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcy5wdXNoKC4uLm9wdGlvbkRhdGFzZXQuaXNzdWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gb3B0aW9uRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3B0aW9uRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgaWYgKG91dHB1dHMpIHtcbiAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKG9wdGlvbkRhdGFzZXQudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0cyA9IFtvcHRpb25EYXRhc2V0LnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gb3V0cHV0c1swXTtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgb3V0cHV0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlRGF0YXNldCA9IF9tZXJnZShkYXRhc2V0LnZhbHVlLCBvdXRwdXRzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAobWVyZ2VEYXRhc2V0Lmlzc3VlKSB7XG4gICAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcInVua25vd25cIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gbWVyZ2VEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW50ZXJzZWN0L2ludGVyc2VjdEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaW50ZXJzZWN0QXN5bmMob3B0aW9ucywgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiaW50ZXJzZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBpbnRlcnNlY3RBc3luYyxcbiAgICBleHBlY3RzOiBfam9pbkV4cGVjdHMoXG4gICAgICBvcHRpb25zLm1hcCgob3B0aW9uKSA9PiBvcHRpb24uZXhwZWN0cyksXG4gICAgICBcIiZcIlxuICAgICksXG4gICAgYXN5bmM6IHRydWUsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBvcHRpb25EYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXAoKHNjaGVtYSkgPT4gc2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiBpbnB1dCB9LCBjb25maWcyKSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25EYXRhc2V0IG9mIG9wdGlvbkRhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMucHVzaCguLi5vcHRpb25EYXRhc2V0Lmlzc3Vlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IG9wdGlvbkRhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdGlvbkRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXRzKSB7XG4gICAgICAgICAgICAgIG91dHB1dHMucHVzaChvcHRpb25EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dHMgPSBbb3B0aW9uRGF0YXNldC52YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IG91dHB1dHNbMF07XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IG91dHB1dHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZURhdGFzZXQgPSBfbWVyZ2UoZGF0YXNldC52YWx1ZSwgb3V0cHV0c1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKG1lcmdlRGF0YXNldC5pc3N1ZSkge1xuICAgICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJ1bmtub3duXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZSA9IG1lcmdlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xhenkvbGF6eS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxhenkoZ2V0dGVyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxhenlcIixcbiAgICByZWZlcmVuY2U6IGxhenksXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldHRlcixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldHRlcihkYXRhc2V0LnZhbHVlKVtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sYXp5L2xhenlBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxhenlBc3luYyhnZXR0ZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibGF6eVwiLFxuICAgIHJlZmVyZW5jZTogbGF6eUFzeW5jLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGdldHRlcixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXR0ZXIoZGF0YXNldC52YWx1ZSkpW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xpdGVyYWwvbGl0ZXJhbC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxpdGVyYWwobGl0ZXJhbF8sIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICByZWZlcmVuY2U6IGxpdGVyYWwsXG4gICAgZXhwZWN0czogX3N0cmluZ2lmeShsaXRlcmFsXyksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxfLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHRoaXMubGl0ZXJhbCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xvb3NlT2JqZWN0L2xvb3NlT2JqZWN0LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbG9vc2VPYmplY3QoZW50cmllczIsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxvb3NlX29iamVjdFwiLFxuICAgIHJlZmVyZW5jZTogbG9vc2VPYmplY3QsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW50cmllczogZW50cmllczIsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZW50cmllcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlU2NoZW1hID0gdGhpcy5lbnRyaWVzW2tleV07XG4gICAgICAgICAgaWYgKGtleSBpbiBpbnB1dCB8fCAodmFsdWVTY2hlbWEudHlwZSA9PT0gXCJleGFjdF9vcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwib3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm51bGxpc2hcIikgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIHZhbHVlU2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0ga2V5IGluIGlucHV0ID8gKFxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIGlucHV0W2tleV1cbiAgICAgICAgICAgICkgOiBnZXREZWZhdWx0KHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHZhbHVlU2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gZ2V0RmFsbGJhY2sodmFsdWVTY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEudHlwZSAhPT0gXCJleGFjdF9vcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoX2lzVmFsaWRPYmplY3RLZXkoaW5wdXQsIGtleSkgJiYgIShrZXkgaW4gdGhpcy5lbnRyaWVzKSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbG9vc2VPYmplY3QvbG9vc2VPYmplY3RBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxvb3NlT2JqZWN0QXN5bmMoZW50cmllczIsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxvb3NlX29iamVjdFwiLFxuICAgIHJlZmVyZW5jZTogbG9vc2VPYmplY3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXM6IGVudHJpZXMyLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlU2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBpbnB1dCB8fCAodmFsdWVTY2hlbWEudHlwZSA9PT0gXCJleGFjdF9vcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwib3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm51bGxpc2hcIikgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgdmFsdWVTY2hlbWEuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGtleSBpbiBpbnB1dCA/IChcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgaW5wdXRba2V5XVxuICAgICAgICAgICAgICApIDogYXdhaXQgZ2V0RGVmYXVsdCh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICB2YWx1ZVNjaGVtYSxcbiAgICAgICAgICAgICAgICBhd2FpdCB2YWx1ZVNjaGVtYVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgaW5wdXRba2V5XSxcbiAgICAgICAgICAgICAgdmFsdWVTY2hlbWEsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIHZhbHVlU2NoZW1hLCB2YWx1ZURhdGFzZXRdIG9mIHZhbHVlRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gYXdhaXQgZ2V0RmFsbGJhY2sodmFsdWVTY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEudHlwZSAhPT0gXCJleGFjdF9vcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChfaXNWYWxpZE9iamVjdEtleShpbnB1dCwga2V5KSAmJiAhKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IGlucHV0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sb29zZVR1cGxlL2xvb3NlVHVwbGUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBsb29zZVR1cGxlKGl0ZW1zLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJsb29zZV90dXBsZVwiLFxuICAgIHJlZmVyZW5jZTogbG9vc2VUdXBsZSxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW1zLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLml0ZW1zW2tleV1bXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChsZXQga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGg7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpbnB1dFtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xvb3NlVHVwbGUvbG9vc2VUdXBsZUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbG9vc2VUdXBsZUFzeW5jKGl0ZW1zLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJsb29zZV90dXBsZVwiLFxuICAgIHJlZmVyZW5jZTogbG9vc2VUdXBsZUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBjb25zdCBpdGVtRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoaXRlbSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlMiwgYXdhaXQgaXRlbVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgaXRlbURhdGFzZXRdIG9mIGl0ZW1EYXRhc2V0cykge1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGxldCBrZXkgPSB0aGlzLml0ZW1zLmxlbmd0aDsga2V5IDwgaW5wdXQubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGlucHV0W2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbWFwL21hcC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1hcChrZXksIHZhbHVlMiwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibWFwXCIsXG4gICAgcmVmZXJlbmNlOiBtYXAsXG4gICAgZXhwZWN0czogXCJNYXBcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0gb2YgaW5wdXQpIHtcbiAgICAgICAgICBjb25zdCBrZXlEYXRhc2V0ID0gdGhpcy5rZXlbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0S2V5IH0sIGNvbmZpZzIpO1xuICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGtleURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXQgPSB0aGlzLnZhbHVlW1wifnJ1blwiXShcbiAgICAgICAgICAgIHsgdmFsdWU6IGlucHV0VmFsdWUgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IGlucHV0S2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha2V5RGF0YXNldC50eXBlZCB8fCAhdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUuc2V0KGtleURhdGFzZXQudmFsdWUsIHZhbHVlRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXBBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1hcEFzeW5jKGtleSwgdmFsdWUyLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJtYXBcIixcbiAgICByZWZlcmVuY2U6IG1hcEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiTWFwXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIFsuLi5pbnB1dF0ubWFwKFxuICAgICAgICAgICAgKFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0pID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgaW5wdXRLZXksXG4gICAgICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMua2V5W1wifnJ1blwiXSh7IHZhbHVlOiBpbnB1dEtleSB9LCBjb25maWcyKSxcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZVtcIn5ydW5cIl0oeyB2YWx1ZTogaW5wdXRWYWx1ZSB9LCBjb25maWcyKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW1xuICAgICAgICAgIGlucHV0S2V5LFxuICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAga2V5RGF0YXNldCxcbiAgICAgICAgICB2YWx1ZURhdGFzZXRcbiAgICAgICAgXSBvZiBkYXRhc2V0cykge1xuICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGtleURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleURhdGFzZXQudHlwZWQgfHwgIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnNldChrZXlEYXRhc2V0LnZhbHVlLCB2YWx1ZURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uYW4vbmFuLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbmFuKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5hblwiLFxuICAgIHJlZmVyZW5jZTogbmFuLFxuICAgIGV4cGVjdHM6IFwiTmFOXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKE51bWJlci5pc05hTihkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25ldmVyL25ldmVyLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbmV2ZXIobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICByZWZlcmVuY2U6IG5ldmVyLFxuICAgIGV4cGVjdHM6IFwibmV2ZXJcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25OdWxsYWJsZS9ub25OdWxsYWJsZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vbk51bGxhYmxlKHdyYXBwZWQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5vbl9udWxsYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogbm9uTnVsbGFibGUsXG4gICAgZXhwZWN0czogXCIhbnVsbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YXNldCA9IHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25OdWxsYWJsZS9ub25OdWxsYWJsZUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm9uTnVsbGFibGVBc3luYyh3cmFwcGVkLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fbnVsbGFibGVcIixcbiAgICByZWZlcmVuY2U6IG5vbk51bGxhYmxlQXN5bmMsXG4gICAgZXhwZWN0czogXCIhbnVsbFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhc2V0ID0gYXdhaXQgdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxpc2gvbm9uTnVsbGlzaC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vbk51bGxpc2god3JhcHBlZCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibm9uX251bGxpc2hcIixcbiAgICByZWZlcmVuY2U6IG5vbk51bGxpc2gsXG4gICAgZXhwZWN0czogXCIoIW51bGwgJiAhdW5kZWZpbmVkKVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKCEoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApKSB7XG4gICAgICAgIGRhdGFzZXQgPSB0aGlzLndyYXBwZWRbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxpc2gvbm9uTnVsbGlzaEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm9uTnVsbGlzaEFzeW5jKHdyYXBwZWQsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5vbl9udWxsaXNoXCIsXG4gICAgcmVmZXJlbmNlOiBub25OdWxsaXNoQXN5bmMsXG4gICAgZXhwZWN0czogXCIoIW51bGwgJiAhdW5kZWZpbmVkKVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoIShkYXRhc2V0LnZhbHVlID09PSBudWxsIHx8IGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkpIHtcbiAgICAgICAgZGF0YXNldCA9IGF3YWl0IHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uT3B0aW9uYWwvbm9uT3B0aW9uYWwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub25PcHRpb25hbCh3cmFwcGVkLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fb3B0aW9uYWxcIixcbiAgICByZWZlcmVuY2U6IG5vbk9wdGlvbmFsLFxuICAgIGV4cGVjdHM6IFwiIXVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBkYXRhc2V0ID0gdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uT3B0aW9uYWwvbm9uT3B0aW9uYWxBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vbk9wdGlvbmFsQXN5bmMod3JhcHBlZCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibm9uX29wdGlvbmFsXCIsXG4gICAgcmVmZXJlbmNlOiBub25PcHRpb25hbEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiIXVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGRhdGFzZXQgPSBhd2FpdCB0aGlzLndyYXBwZWRbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsL251bGwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBudWxsXyhtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudWxsXCIsXG4gICAgcmVmZXJlbmNlOiBudWxsXyxcbiAgICBleHBlY3RzOiBcIm51bGxcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxhYmxlL251bGxhYmxlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbnVsbGFibGUod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibnVsbGFibGVcIixcbiAgICByZWZlcmVuY2U6IG51bGxhYmxlLFxuICAgIGV4cGVjdHM6IGAoJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbClgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsYWJsZS9udWxsYWJsZUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbnVsbGFibGVBc3luYyh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudWxsYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogbnVsbGFibGVBc3luYyxcbiAgICBleHBlY3RzOiBgKCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGwpYCxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2gudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBudWxsaXNoKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm51bGxpc2hcIixcbiAgICByZWZlcmVuY2U6IG51bGxpc2gsXG4gICAgZXhwZWN0czogYCgke3dyYXBwZWQuZXhwZWN0c30gfCBudWxsIHwgdW5kZWZpbmVkKWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbGlzaC9udWxsaXNoQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBudWxsaXNoQXN5bmMod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibnVsbGlzaFwiLFxuICAgIHJlZmVyZW5jZTogbnVsbGlzaEFzeW5jLFxuICAgIGV4cGVjdHM6IGAoJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbCB8IHVuZGVmaW5lZClgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVtYmVyL251bWJlci50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG51bWJlcihtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICByZWZlcmVuY2U6IG51bWJlcixcbiAgICBleHBlY3RzOiBcIm51bWJlclwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vYmplY3Qvb2JqZWN0LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gb2JqZWN0KGVudHJpZXMyLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICByZWZlcmVuY2U6IG9iamVjdCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBlbnRyaWVzOiBlbnRyaWVzMixcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5lbnRyaWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVTY2hlbWEgPSB0aGlzLmVudHJpZXNba2V5XTtcbiAgICAgICAgICBpZiAoa2V5IGluIGlucHV0IHx8ICh2YWx1ZVNjaGVtYS50eXBlID09PSBcImV4YWN0X29wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJvcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwibnVsbGlzaFwiKSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgdmFsdWVTY2hlbWEuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBrZXkgaW4gaW5wdXQgPyAoXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgaW5wdXRba2V5XVxuICAgICAgICAgICAgKSA6IGdldERlZmF1bHQodmFsdWVTY2hlbWEpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdmFsdWVTY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS5mYWxsYmFjayAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSBnZXRGYWxsYmFjayh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS50eXBlICE9PSBcImV4YWN0X29wdGlvbmFsXCIgJiYgdmFsdWVTY2hlbWEudHlwZSAhPT0gXCJvcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwibnVsbGlzaFwiKSB7XG4gICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJrZXlcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBleHBlY3RlZDogYFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0W2tleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29iamVjdC9vYmplY3RBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG9iamVjdEFzeW5jKGVudHJpZXMyLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICByZWZlcmVuY2U6IG9iamVjdEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgZW50cmllczogZW50cmllczIsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgdmFsdWVTY2hlbWFdKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGlucHV0IHx8ICh2YWx1ZVNjaGVtYS50eXBlID09PSBcImV4YWN0X29wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJvcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwibnVsbGlzaFwiKSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICB2YWx1ZVNjaGVtYS5kZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0ga2V5IGluIGlucHV0ID8gKFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBpbnB1dFtrZXldXG4gICAgICAgICAgICAgICkgOiBhd2FpdCBnZXREZWZhdWx0KHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICAgIHZhbHVlU2NoZW1hLFxuICAgICAgICAgICAgICAgIGF3YWl0IHZhbHVlU2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICBpbnB1dFtrZXldLFxuICAgICAgICAgICAgICB2YWx1ZVNjaGVtYSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgdmFsdWVTY2hlbWEsIHZhbHVlRGF0YXNldF0gb2YgdmFsdWVEYXRhc2V0cykge1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS5mYWxsYmFjayAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSBhd2FpdCBnZXRGYWxsYmFjayh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS50eXBlICE9PSBcImV4YWN0X29wdGlvbmFsXCIgJiYgdmFsdWVTY2hlbWEudHlwZSAhPT0gXCJvcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwibnVsbGlzaFwiKSB7XG4gICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJrZXlcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBleHBlY3RlZDogYFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0V2l0aFJlc3Qvb2JqZWN0V2l0aFJlc3QudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBvYmplY3RXaXRoUmVzdChlbnRyaWVzMiwgcmVzdCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwib2JqZWN0X3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogb2JqZWN0V2l0aFJlc3QsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW50cmllczogZW50cmllczIsXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5lbnRyaWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVTY2hlbWEgPSB0aGlzLmVudHJpZXNba2V5XTtcbiAgICAgICAgICBpZiAoa2V5IGluIGlucHV0IHx8ICh2YWx1ZVNjaGVtYS50eXBlID09PSBcImV4YWN0X29wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJvcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwibnVsbGlzaFwiKSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgdmFsdWVTY2hlbWEuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBrZXkgaW4gaW5wdXQgPyAoXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgaW5wdXRba2V5XVxuICAgICAgICAgICAgKSA6IGdldERlZmF1bHQodmFsdWVTY2hlbWEpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdmFsdWVTY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS5mYWxsYmFjayAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSBnZXRGYWxsYmFjayh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS50eXBlICE9PSBcImV4YWN0X29wdGlvbmFsXCIgJiYgdmFsdWVTY2hlbWEudHlwZSAhPT0gXCJvcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwibnVsbGlzaFwiKSB7XG4gICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJrZXlcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBleHBlY3RlZDogYFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0W2tleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChfaXNWYWxpZE9iamVjdEtleShpbnB1dCwga2V5KSAmJiAhKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMucmVzdFtcIn5ydW5cIl0oXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHsgdmFsdWU6IGlucHV0W2tleV0gfSxcbiAgICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0V2l0aFJlc3Qvb2JqZWN0V2l0aFJlc3RBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG9iamVjdFdpdGhSZXN0QXN5bmMoZW50cmllczIsIHJlc3QsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9iamVjdF93aXRoX3Jlc3RcIixcbiAgICByZWZlcmVuY2U6IG9iamVjdFdpdGhSZXN0QXN5bmMsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnRyaWVzOiBlbnRyaWVzMixcbiAgICByZXN0LFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBjb25zdCBbbm9ybWFsRGF0YXNldHMsIHJlc3REYXRhc2V0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gSWYga2V5IGlzIHByZXNlbnQgb3IgaXRzIGFuIG9wdGlvbmFsIHNjaGVtYSB3aXRoIGEgZGVmYXVsdCB2YWx1ZSxcbiAgICAgICAgICAvLyBwYXJzZSBpbnB1dCBvZiBrZXkgb3IgZGVmYXVsdCB2YWx1ZSBhc3luY2hyb25vdXNseVxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlU2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoa2V5IGluIGlucHV0IHx8ICh2YWx1ZVNjaGVtYS50eXBlID09PSBcImV4YWN0X29wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJvcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwibnVsbGlzaFwiKSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIHZhbHVlU2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGtleSBpbiBpbnB1dCA/IChcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIGlucHV0W2tleV1cbiAgICAgICAgICAgICAgICApIDogYXdhaXQgZ2V0RGVmYXVsdCh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICAgIHZhbHVlU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgYXdhaXQgdmFsdWVTY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGlucHV0W2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTY2hlbWEsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIFBhcnNlIG90aGVyIGVudHJpZXMgd2l0aCByZXN0IHNjaGVtYSBhc3luY2hyb25vdXNseVxuICAgICAgICAgIC8vIEhpbnQ6IFdlIGV4Y2x1ZGUgc3BlY2lmaWMga2V5cyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW5wdXQpLmZpbHRlcihcbiAgICAgICAgICAgICAgKFtrZXldKSA9PiBfaXNWYWxpZE9iamVjdEtleShpbnB1dCwga2V5KSAmJiAhKGtleSBpbiB0aGlzLmVudHJpZXMpXG4gICAgICAgICAgICApLm1hcChcbiAgICAgICAgICAgICAgYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzdFtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgdmFsdWVTY2hlbWEsIHZhbHVlRGF0YXNldF0gb2Ygbm9ybWFsRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gYXdhaXQgZ2V0RmFsbGJhY2sodmFsdWVTY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEudHlwZSAhPT0gXCJleGFjdF9vcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIHZhbHVlRGF0YXNldF0gb2YgcmVzdERhdGFzZXRzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb3B0aW9uYWwvb3B0aW9uYWwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBvcHRpb25hbCh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIHJlZmVyZW5jZTogb3B0aW9uYWwsXG4gICAgZXhwZWN0czogYCgke3dyYXBwZWQuZXhwZWN0c30gfCB1bmRlZmluZWQpYCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0XyxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29wdGlvbmFsL29wdGlvbmFsQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBvcHRpb25hbEFzeW5jKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgcmVmZXJlbmNlOiBvcHRpb25hbEFzeW5jLFxuICAgIGV4cGVjdHM6IGAoJHt3cmFwcGVkLmV4cGVjdHN9IHwgdW5kZWZpbmVkKWAsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0XyxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3BpY2tsaXN0L3BpY2tsaXN0LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGlja2xpc3Qob3B0aW9ucywgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwicGlja2xpc3RcIixcbiAgICByZWZlcmVuY2U6IHBpY2tsaXN0LFxuICAgIGV4cGVjdHM6IF9qb2luRXhwZWN0cyhvcHRpb25zLm1hcChfc3RyaW5naWZ5KSwgXCJ8XCIpLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlcyhkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3Byb21pc2UvcHJvbWlzZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHByb21pc2UobWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwicHJvbWlzZVwiLFxuICAgIHJlZmVyZW5jZTogcHJvbWlzZSxcbiAgICBleHBlY3RzOiBcIlByb21pc2VcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvcmVjb3JkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcmVjb3JkKGtleSwgdmFsdWUyLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICByZWZlcmVuY2U6IHJlY29yZCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBrZXksXG4gICAgdmFsdWU6IHZhbHVlMixcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeUtleSBpbiBpbnB1dCkge1xuICAgICAgICAgIGlmIChfaXNWYWxpZE9iamVjdEtleShpbnB1dCwgZW50cnlLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeVZhbHVlID0gaW5wdXRbZW50cnlLZXldO1xuICAgICAgICAgICAgY29uc3Qga2V5RGF0YXNldCA9IHRoaXMua2V5W1wifnJ1blwiXSh7IHZhbHVlOiBlbnRyeUtleSB9LCBjb25maWcyKTtcbiAgICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IGVudHJ5S2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlbnRyeVZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2Yga2V5RGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0ga2V5RGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdGhpcy52YWx1ZVtcIn5ydW5cIl0oXG4gICAgICAgICAgICAgIHsgdmFsdWU6IGVudHJ5VmFsdWUgfSxcbiAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5OiBlbnRyeUtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnlWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2V5RGF0YXNldC50eXBlZCB8fCAhdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5RGF0YXNldC52YWx1ZV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvcmVjb3JkQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByZWNvcmRBc3luYyhrZXksIHZhbHVlMiwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgcmVmZXJlbmNlOiByZWNvcmRBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGlucHV0KS5maWx0ZXIoKFtrZXkyXSkgPT4gX2lzVmFsaWRPYmplY3RLZXkoaW5wdXQsIGtleTIpKS5tYXAoXG4gICAgICAgICAgICAoW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSkgPT4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICBlbnRyeUtleSxcbiAgICAgICAgICAgICAgZW50cnlWYWx1ZSxcbiAgICAgICAgICAgICAgdGhpcy5rZXlbXCJ+cnVuXCJdKHsgdmFsdWU6IGVudHJ5S2V5IH0sIGNvbmZpZzIpLFxuICAgICAgICAgICAgICB0aGlzLnZhbHVlW1wifnJ1blwiXSh7IHZhbHVlOiBlbnRyeVZhbHVlIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBbXG4gICAgICAgICAgZW50cnlLZXksXG4gICAgICAgICAgZW50cnlWYWx1ZSxcbiAgICAgICAgICBrZXlEYXRhc2V0LFxuICAgICAgICAgIHZhbHVlRGF0YXNldFxuICAgICAgICBdIG9mIGRhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBlbnRyeUtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0ga2V5RGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IGVudHJ5S2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZW50cnlWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha2V5RGF0YXNldC50eXBlZCB8fCAhdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXlEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleURhdGFzZXQudmFsdWVdID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc2V0L3NldC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNldCh2YWx1ZTIsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIHJlZmVyZW5jZTogc2V0LFxuICAgIGV4cGVjdHM6IFwiU2V0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXQgPSB0aGlzLnZhbHVlW1wifnJ1blwiXShcbiAgICAgICAgICAgIHsgdmFsdWU6IGlucHV0VmFsdWUgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IG51bGwsXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5hZGQodmFsdWVEYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc2V0L3NldEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc2V0QXN5bmModmFsdWUyLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICByZWZlcmVuY2U6IHNldEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiU2V0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlMixcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBbLi4uaW5wdXRdLm1hcChcbiAgICAgICAgICAgIGFzeW5jIChpbnB1dFZhbHVlKSA9PiBbXG4gICAgICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMudmFsdWVbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0VmFsdWUgfSwgY29uZmlnMilcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2lucHV0VmFsdWUsIHZhbHVlRGF0YXNldF0gb2YgdmFsdWVEYXRhc2V0cykge1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IG51bGwsXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5hZGQodmFsdWVEYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaWN0T2JqZWN0L3N0cmljdE9iamVjdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHN0cmljdE9iamVjdChlbnRyaWVzMiwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic3RyaWN0X29iamVjdFwiLFxuICAgIHJlZmVyZW5jZTogc3RyaWN0T2JqZWN0LFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGVudHJpZXM6IGVudHJpZXMyLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmVudHJpZXMpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZVNjaGVtYSA9IHRoaXMuZW50cmllc1trZXldO1xuICAgICAgICAgIGlmIChrZXkgaW4gaW5wdXQgfHwgKHZhbHVlU2NoZW1hLnR5cGUgPT09IFwiZXhhY3Rfb3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm9wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJudWxsaXNoXCIpICYmIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICB2YWx1ZVNjaGVtYS5kZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGtleSBpbiBpbnB1dCA/IChcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICBpbnB1dFtrZXldXG4gICAgICAgICAgICApIDogZ2V0RGVmYXVsdCh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXQgPSB2YWx1ZVNjaGVtYVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpO1xuICAgICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlU2NoZW1hLmZhbGxiYWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IGdldEZhbGxiYWNrKHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlU2NoZW1hLnR5cGUgIT09IFwiZXhhY3Rfb3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm9wdGlvbmFsXCIgJiYgdmFsdWVTY2hlbWEudHlwZSAhPT0gXCJudWxsaXNoXCIpIHtcbiAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImtleVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiBgXCIke2tleX1cImAsXG4gICAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRba2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgICBpbnB1dDoga2V5LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcIm5ldmVyXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0W2tleV1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N0cmljdE9iamVjdC9zdHJpY3RPYmplY3RBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHN0cmljdE9iamVjdEFzeW5jKGVudHJpZXMyLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpY3Rfb2JqZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpY3RPYmplY3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXM6IGVudHJpZXMyLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlU2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBpbnB1dCB8fCAodmFsdWVTY2hlbWEudHlwZSA9PT0gXCJleGFjdF9vcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwib3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm51bGxpc2hcIikgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgdmFsdWVTY2hlbWEuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGtleSBpbiBpbnB1dCA/IChcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgaW5wdXRba2V5XVxuICAgICAgICAgICAgICApIDogYXdhaXQgZ2V0RGVmYXVsdCh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICB2YWx1ZVNjaGVtYSxcbiAgICAgICAgICAgICAgICBhd2FpdCB2YWx1ZVNjaGVtYVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgaW5wdXRba2V5XSxcbiAgICAgICAgICAgICAgdmFsdWVTY2hlbWEsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIHZhbHVlU2NoZW1hLCB2YWx1ZURhdGFzZXRdIG9mIHZhbHVlRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gYXdhaXQgZ2V0RmFsbGJhY2sodmFsdWVTY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEudHlwZSAhPT0gXCJleGFjdF9vcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImtleVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGtleSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJuZXZlclwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpY3RUdXBsZS9zdHJpY3RUdXBsZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHN0cmljdFR1cGxlKGl0ZW1zLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpY3RfdHVwbGVcIixcbiAgICByZWZlcmVuY2U6IHN0cmljdFR1cGxlLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbXMsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgdGhpcy5pdGVtcy5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IHRoaXMuaXRlbXNba2V5XVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpO1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShkYXRhc2V0Lmlzc3VlcyAmJiBjb25maWcyLmFib3J0RWFybHkpICYmIHRoaXMuaXRlbXMubGVuZ3RoIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXRbdGhpcy5pdGVtcy5sZW5ndGhdLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFt0aGlzLml0ZW1zLmxlbmd0aF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpY3RUdXBsZS9zdHJpY3RUdXBsZUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc3RyaWN0VHVwbGVBc3luYyhpdGVtcywgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic3RyaWN0X3R1cGxlXCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpY3RUdXBsZUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBjb25zdCBpdGVtRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoaXRlbSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlMiwgYXdhaXQgaXRlbVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgaXRlbURhdGFzZXRdIG9mIGl0ZW1EYXRhc2V0cykge1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShkYXRhc2V0Lmlzc3VlcyAmJiBjb25maWcyLmFib3J0RWFybHkpICYmIHRoaXMuaXRlbXMubGVuZ3RoIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXRbdGhpcy5pdGVtcy5sZW5ndGhdLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFt0aGlzLml0ZW1zLmxlbmd0aF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpbmcvc3RyaW5nLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc3RyaW5nKG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHJlZmVyZW5jZTogc3RyaW5nLFxuICAgIGV4cGVjdHM6IFwic3RyaW5nXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3ltYm9sL3N5bWJvbC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHN5bWJvbChtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICByZWZlcmVuY2U6IHN5bWJvbCxcbiAgICBleHBlY3RzOiBcInN5bWJvbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3R1cGxlL3R1cGxlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdHVwbGUoaXRlbXMsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgcmVmZXJlbmNlOiB0dXBsZSxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW1zLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLml0ZW1zW2tleV1bXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3R1cGxlL3R1cGxlQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0dXBsZUFzeW5jKGl0ZW1zLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgIHJlZmVyZW5jZTogdHVwbGVBc3luYyxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgaXRlbXMsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlbURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdGhpcy5pdGVtcy5tYXAoYXN5bmMgKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZTIsIGF3YWl0IGl0ZW1bXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKV07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIGl0ZW1EYXRhc2V0XSBvZiBpdGVtRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3R1cGxlV2l0aFJlc3QvdHVwbGVXaXRoUmVzdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHR1cGxlV2l0aFJlc3QoaXRlbXMsIHJlc3QsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInR1cGxlX3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogdHVwbGVXaXRoUmVzdCxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW1zLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgdGhpcy5pdGVtcy5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IHRoaXMuaXRlbXNba2V5XVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpO1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGxldCBrZXkgPSB0aGlzLml0ZW1zLmxlbmd0aDsga2V5IDwgaW5wdXQubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gdGhpcy5yZXN0W1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZVdpdGhSZXN0L3R1cGxlV2l0aFJlc3RBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHR1cGxlV2l0aFJlc3RBc3luYyhpdGVtcywgcmVzdCwgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidHVwbGVfd2l0aF9yZXN0XCIsXG4gICAgcmVmZXJlbmNlOiB0dXBsZVdpdGhSZXN0QXN5bmMsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGl0ZW1zLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgW25vcm1hbERhdGFzZXRzLCByZXN0RGF0YXNldHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIFBhcnNlIHNjaGVtYSBvZiBlYWNoIG5vcm1hbCBpdGVtXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoaXRlbSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICBhd2FpdCBpdGVtW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBQYXJzZSBvdGhlciBpdGVtcyB3aXRoIHJlc3Qgc2NoZW1hXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBpbnB1dC5zbGljZSh0aGlzLml0ZW1zLmxlbmd0aCkubWFwKGFzeW5jICh2YWx1ZTIsIGtleSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSArIHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgaXRlbURhdGFzZXRdIG9mIG5vcm1hbERhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCBpdGVtRGF0YXNldF0gb2YgcmVzdERhdGFzZXRzKSB7XG4gICAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmRlZmluZWQvdW5kZWZpbmVkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdW5kZWZpbmVkXyhtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ1bmRlZmluZWRcIixcbiAgICByZWZlcmVuY2U6IHVuZGVmaW5lZF8sXG4gICAgZXhwZWN0czogXCJ1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5kZWZpbmVkYWJsZS91bmRlZmluZWRhYmxlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdW5kZWZpbmVkYWJsZSh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ1bmRlZmluZWRhYmxlXCIsXG4gICAgcmVmZXJlbmNlOiB1bmRlZmluZWRhYmxlLFxuICAgIGV4cGVjdHM6IGAoJHt3cmFwcGVkLmV4cGVjdHN9IHwgdW5kZWZpbmVkKWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBnZXREZWZhdWx0KHRoaXMsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmRlZmluZWRhYmxlL3VuZGVmaW5lZGFibGVBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHVuZGVmaW5lZGFibGVBc3luYyh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ1bmRlZmluZWRhYmxlXCIsXG4gICAgcmVmZXJlbmNlOiB1bmRlZmluZWRhYmxlQXN5bmMsXG4gICAgZXhwZWN0czogYCgke3dyYXBwZWQuZXhwZWN0c30gfCB1bmRlZmluZWQpYCxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gYXdhaXQgZ2V0RGVmYXVsdCh0aGlzLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdXRpbHMvX3N1Yklzc3Vlcy9fc3ViSXNzdWVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gX3N1Yklzc3VlcyhkYXRhc2V0cykge1xuICBsZXQgaXNzdWVzO1xuICBpZiAoZGF0YXNldHMpIHtcbiAgICBmb3IgKGNvbnN0IGRhdGFzZXQgb2YgZGF0YXNldHMpIHtcbiAgICAgIGlmIChpc3N1ZXMpIHtcbiAgICAgICAgaXNzdWVzLnB1c2goLi4uZGF0YXNldC5pc3N1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNzdWVzID0gZGF0YXNldC5pc3N1ZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpc3N1ZXM7XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuaW9uL3VuaW9uLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdW5pb24ob3B0aW9ucywgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICByZWZlcmVuY2U6IHVuaW9uLFxuICAgIGV4cGVjdHM6IF9qb2luRXhwZWN0cyhcbiAgICAgIG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSxcbiAgICAgIFwifFwiXG4gICAgKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlOiBtZXNzYWdlMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGxldCB2YWxpZERhdGFzZXQ7XG4gICAgICBsZXQgdHlwZWREYXRhc2V0cztcbiAgICAgIGxldCB1bnR5cGVkRGF0YXNldHM7XG4gICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uRGF0YXNldCA9IHNjaGVtYVtcIn5ydW5cIl0oeyB2YWx1ZTogZGF0YXNldC52YWx1ZSB9LCBjb25maWcyKTtcbiAgICAgICAgaWYgKG9wdGlvbkRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9uRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlZERhdGFzZXRzKSB7XG4gICAgICAgICAgICAgIHR5cGVkRGF0YXNldHMucHVzaChvcHRpb25EYXRhc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHR5cGVkRGF0YXNldHMgPSBbb3B0aW9uRGF0YXNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkRGF0YXNldCA9IG9wdGlvbkRhdGFzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHVudHlwZWREYXRhc2V0cykge1xuICAgICAgICAgICAgdW50eXBlZERhdGFzZXRzLnB1c2gob3B0aW9uRGF0YXNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVudHlwZWREYXRhc2V0cyA9IFtvcHRpb25EYXRhc2V0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZERhdGFzZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkRGF0YXNldDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlZERhdGFzZXRzKSB7XG4gICAgICAgIGlmICh0eXBlZERhdGFzZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0eXBlZERhdGFzZXRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIGlzc3VlczogX3N1Yklzc3Vlcyh0eXBlZERhdGFzZXRzKVxuICAgICAgICB9KTtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVudHlwZWREYXRhc2V0cz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB1bnR5cGVkRGF0YXNldHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICBpc3N1ZXM6IF9zdWJJc3N1ZXModW50eXBlZERhdGFzZXRzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb25Bc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHVuaW9uQXN5bmMob3B0aW9ucywgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICByZWZlcmVuY2U6IHVuaW9uQXN5bmMsXG4gICAgZXhwZWN0czogX2pvaW5FeHBlY3RzKFxuICAgICAgb3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLmV4cGVjdHMpLFxuICAgICAgXCJ8XCJcbiAgICApLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBsZXQgdmFsaWREYXRhc2V0O1xuICAgICAgbGV0IHR5cGVkRGF0YXNldHM7XG4gICAgICBsZXQgdW50eXBlZERhdGFzZXRzO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBhd2FpdCBzY2hlbWFbXCJ+cnVuXCJdKFxuICAgICAgICAgIHsgdmFsdWU6IGRhdGFzZXQudmFsdWUgfSxcbiAgICAgICAgICBjb25maWcyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZWREYXRhc2V0cykge1xuICAgICAgICAgICAgICB0eXBlZERhdGFzZXRzLnB1c2gob3B0aW9uRGF0YXNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0eXBlZERhdGFzZXRzID0gW29wdGlvbkRhdGFzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZERhdGFzZXQgPSBvcHRpb25EYXRhc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1bnR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgICAgIHVudHlwZWREYXRhc2V0cy5wdXNoKG9wdGlvbkRhdGFzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bnR5cGVkRGF0YXNldHMgPSBbb3B0aW9uRGF0YXNldF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWREYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB2YWxpZERhdGFzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWREYXRhc2V0cykge1xuICAgICAgICBpZiAodHlwZWREYXRhc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZWREYXRhc2V0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICBpc3N1ZXM6IF9zdWJJc3N1ZXModHlwZWREYXRhc2V0cylcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1bnR5cGVkRGF0YXNldHM/Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdW50eXBlZERhdGFzZXRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgaXNzdWVzOiBfc3ViSXNzdWVzKHVudHlwZWREYXRhc2V0cylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3Vua25vd24vdW5rbm93bi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInVua25vd25cIixcbiAgICByZWZlcmVuY2U6IHVua25vd24sXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZhcmlhbnQvdmFyaWFudC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHZhcmlhbnQoa2V5LCBvcHRpb25zLCBtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ2YXJpYW50XCIsXG4gICAgcmVmZXJlbmNlOiB2YXJpYW50LFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGtleSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgb3V0cHV0RGF0YXNldDtcbiAgICAgICAgbGV0IG1heERpc2NyaW1pbmF0b3JQcmlvcml0eSA9IDA7XG4gICAgICAgIGxldCBpbnZhbGlkRGlzY3JpbWluYXRvcktleSA9IHRoaXMua2V5O1xuICAgICAgICBsZXQgZXhwZWN0ZWREaXNjcmltaW5hdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBwYXJzZU9wdGlvbnMgPSAodmFyaWFudDIsIGFsbEtleXMpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB2YXJpYW50Mi5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwidmFyaWFudFwiKSB7XG4gICAgICAgICAgICAgIHBhcnNlT3B0aW9ucyhzY2hlbWEsIG5ldyBTZXQoYWxsS2V5cykuYWRkKHNjaGVtYS5rZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldCBrZXlzQXJlVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICBsZXQgY3VycmVudFByaW9yaXR5ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBjdXJyZW50S2V5IG9mIGFsbEtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gc2NoZW1hLmVudHJpZXNbY3VycmVudEtleV07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRLZXkgaW4gaW5wdXQgPyBkaXNjcmltaW5hdG9yU2NoZW1hW1wifnJ1blwiXShcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXRbY3VycmVudEtleV0gfSxcbiAgICAgICAgICAgICAgICAgIHsgYWJvcnRFYXJseTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgKS5pc3N1ZXMgOiBkaXNjcmltaW5hdG9yU2NoZW1hLnR5cGUgIT09IFwiZXhhY3Rfb3B0aW9uYWxcIiAmJiBkaXNjcmltaW5hdG9yU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiBkaXNjcmltaW5hdG9yU2NoZW1hLnR5cGUgIT09IFwibnVsbGlzaFwiKSB7XG4gICAgICAgICAgICAgICAgICBrZXlzQXJlVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkRGlzY3JpbWluYXRvcktleSAhPT0gY3VycmVudEtleSAmJiAobWF4RGlzY3JpbWluYXRvclByaW9yaXR5IDwgY3VycmVudFByaW9yaXR5IHx8IG1heERpc2NyaW1pbmF0b3JQcmlvcml0eSA9PT0gY3VycmVudFByaW9yaXR5ICYmIGN1cnJlbnRLZXkgaW4gaW5wdXQgJiYgIShpbnZhbGlkRGlzY3JpbWluYXRvcktleSBpbiBpbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heERpc2NyaW1pbmF0b3JQcmlvcml0eSA9IGN1cnJlbnRQcmlvcml0eTtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgPSBjdXJyZW50S2V5O1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZERpc2NyaW1pbmF0b3JzID0gW107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgPT09IGN1cnJlbnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWREaXNjcmltaW5hdG9ycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYS5lbnRyaWVzW2N1cnJlbnRLZXldLmV4cGVjdHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHkrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoa2V5c0FyZVZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRGF0YXNldCA9IHNjaGVtYVtcIn5ydW5cIl0oeyB2YWx1ZTogaW5wdXQgfSwgY29uZmlnMik7XG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXREYXRhc2V0IHx8ICFvdXRwdXREYXRhc2V0LnR5cGVkICYmIG9wdGlvbkRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dERhdGFzZXQgPSBvcHRpb25EYXRhc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHB1dERhdGFzZXQgJiYgIW91dHB1dERhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VPcHRpb25zKHRoaXMsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFt0aGlzLmtleV0pKTtcbiAgICAgICAgaWYgKG91dHB1dERhdGFzZXQpIHtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0RGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgaW5wdXQ6IGlucHV0W2ludmFsaWREaXNjcmltaW5hdG9yS2V5XSxcbiAgICAgICAgICBleHBlY3RlZDogX2pvaW5FeHBlY3RzKGV4cGVjdGVkRGlzY3JpbWluYXRvcnMsIFwifFwiKSxcbiAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnZhbGlkRGlzY3JpbWluYXRvcktleSxcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRbaW52YWxpZERpc2NyaW1pbmF0b3JLZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZhcmlhbnQvdmFyaWFudEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdmFyaWFudEFzeW5jKGtleSwgb3B0aW9ucywgbWVzc2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidmFyaWFudFwiLFxuICAgIHJlZmVyZW5jZTogdmFyaWFudEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCBvdXRwdXREYXRhc2V0O1xuICAgICAgICBsZXQgbWF4RGlzY3JpbWluYXRvclByaW9yaXR5ID0gMDtcbiAgICAgICAgbGV0IGludmFsaWREaXNjcmltaW5hdG9yS2V5ID0gdGhpcy5rZXk7XG4gICAgICAgIGxldCBleHBlY3RlZERpc2NyaW1pbmF0b3JzID0gW107XG4gICAgICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IGFzeW5jICh2YXJpYW50MiwgYWxsS2V5cykgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHZhcmlhbnQyLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJ2YXJpYW50XCIpIHtcbiAgICAgICAgICAgICAgYXdhaXQgcGFyc2VPcHRpb25zKHNjaGVtYSwgbmV3IFNldChhbGxLZXlzKS5hZGQoc2NoZW1hLmtleSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IGtleXNBcmVWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgIGxldCBjdXJyZW50UHJpb3JpdHkgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRLZXkgb2YgYWxsS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBzY2hlbWEuZW50cmllc1tjdXJyZW50S2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEtleSBpbiBpbnB1dCA/IChhd2FpdCBkaXNjcmltaW5hdG9yU2NoZW1hW1wifnJ1blwiXShcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXRbY3VycmVudEtleV0gfSxcbiAgICAgICAgICAgICAgICAgIHsgYWJvcnRFYXJseTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgKSkuaXNzdWVzIDogZGlzY3JpbWluYXRvclNjaGVtYS50eXBlICE9PSBcImV4YWN0X29wdGlvbmFsXCIgJiYgZGlzY3JpbWluYXRvclNjaGVtYS50eXBlICE9PSBcIm9wdGlvbmFsXCIgJiYgZGlzY3JpbWluYXRvclNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgICAgICAga2V5c0FyZVZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgIT09IGN1cnJlbnRLZXkgJiYgKG1heERpc2NyaW1pbmF0b3JQcmlvcml0eSA8IGN1cnJlbnRQcmlvcml0eSB8fCBtYXhEaXNjcmltaW5hdG9yUHJpb3JpdHkgPT09IGN1cnJlbnRQcmlvcml0eSAmJiBjdXJyZW50S2V5IGluIGlucHV0ICYmICEoaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgaW4gaW5wdXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhEaXNjcmltaW5hdG9yUHJpb3JpdHkgPSBjdXJyZW50UHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWREaXNjcmltaW5hdG9yS2V5ID0gY3VycmVudEtleTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWREaXNjcmltaW5hdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGludmFsaWREaXNjcmltaW5hdG9yS2V5ID09PSBjdXJyZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkRGlzY3JpbWluYXRvcnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEuZW50cmllc1tjdXJyZW50S2V5XS5leHBlY3RzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFByaW9yaXR5Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGtleXNBcmVWYWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBhd2FpdCBzY2hlbWFbXCJ+cnVuXCJdKFxuICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogaW5wdXQgfSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0RGF0YXNldCB8fCAhb3V0cHV0RGF0YXNldC50eXBlZCAmJiBvcHRpb25EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXREYXRhc2V0ID0gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXREYXRhc2V0ICYmICFvdXRwdXREYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHBhcnNlT3B0aW9ucyh0aGlzLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbdGhpcy5rZXldKSk7XG4gICAgICAgIGlmIChvdXRwdXREYXRhc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dERhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGlucHV0OiBpbnB1dFtpbnZhbGlkRGlzY3JpbWluYXRvcktleV0sXG4gICAgICAgICAgZXhwZWN0ZWQ6IF9qb2luRXhwZWN0cyhleHBlY3RlZERpc2NyaW1pbmF0b3JzLCBcInxcIiksXG4gICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW52YWxpZERpc2NyaW1pbmF0b3JLZXksXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0W2ludmFsaWREaXNjcmltaW5hdG9yS2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy92b2lkL3ZvaWQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB2b2lkXyhtZXNzYWdlMikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ2b2lkXCIsXG4gICAgcmVmZXJlbmNlOiB2b2lkXyxcbiAgICBleHBlY3RzOiBcInZvaWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZTogbWVzc2FnZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMva2V5b2Yva2V5b2YudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBrZXlvZihzY2hlbWEsIG1lc3NhZ2UyKSB7XG4gIHJldHVybiBwaWNrbGlzdChPYmplY3Qua2V5cyhzY2hlbWEuZW50cmllcyksIG1lc3NhZ2UyKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvbWVzc2FnZS9tZXNzYWdlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWVzc2FnZShzY2hlbWEsIG1lc3NhZ2VfKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgcmV0dXJuIHNjaGVtYVtcIn5ydW5cIl0oZGF0YXNldCwgeyAuLi5jb25maWcyLCBtZXNzYWdlOiBtZXNzYWdlXyB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL29taXQvb21pdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG9taXQoc2NoZW1hLCBrZXlzKSB7XG4gIGNvbnN0IGVudHJpZXMyID0ge1xuICAgIC4uLnNjaGVtYS5lbnRyaWVzXG4gIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgZW50cmllczJba2V5XTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBlbnRyaWVzOiBlbnRyaWVzMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlL3BhcnNlLnRzXG5mdW5jdGlvbiBwYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcyKSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0IH0sIGdldEdsb2JhbENvbmZpZyhjb25maWcyKSk7XG4gIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgIHRocm93IG5ldyBWYWxpRXJyb3IoZGF0YXNldC5pc3N1ZXMpO1xuICB9XG4gIHJldHVybiBkYXRhc2V0LnZhbHVlO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJzZS9wYXJzZUFzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZUFzeW5jKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpIHtcbiAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHNjaGVtYVtcIn5ydW5cIl0oXG4gICAgeyB2YWx1ZTogaW5wdXQgfSxcbiAgICBnZXRHbG9iYWxDb25maWcoY29uZmlnMilcbiAgKTtcbiAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlFcnJvcihkYXRhc2V0Lmlzc3Vlcyk7XG4gIH1cbiAgcmV0dXJuIGRhdGFzZXQudmFsdWU7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlci9wYXJzZXIudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBwYXJzZXIoc2NoZW1hLCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bmMgPSAoaW5wdXQpID0+IHBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2VyL3BhcnNlckFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGFyc2VyQXN5bmMoc2NoZW1hLCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bmMgPSAoaW5wdXQpID0+IHBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnMik7XG4gIGZ1bmMuc2NoZW1hID0gc2NoZW1hO1xuICBmdW5jLmNvbmZpZyA9IGNvbmZpZzI7XG4gIHJldHVybiBmdW5jO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJ0aWFsL3BhcnRpYWwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBwYXJ0aWFsKHNjaGVtYSwga2V5cykge1xuICBjb25zdCBlbnRyaWVzMiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgIGVudHJpZXMyW2tleV0gPSAha2V5cyB8fCBrZXlzLmluY2x1ZGVzKGtleSkgPyBvcHRpb25hbChzY2hlbWEuZW50cmllc1trZXldKSA6IHNjaGVtYS5lbnRyaWVzW2tleV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZW50cmllczogZW50cmllczIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJ0aWFsL3BhcnRpYWxBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHBhcnRpYWxBc3luYyhzY2hlbWEsIGtleXMpIHtcbiAgY29uc3QgZW50cmllczIgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICBlbnRyaWVzMltrZXldID0gIWtleXMgfHwga2V5cy5pbmNsdWRlcyhrZXkpID8gb3B0aW9uYWxBc3luYyhzY2hlbWEuZW50cmllc1trZXldKSA6IHNjaGVtYS5lbnRyaWVzW2tleV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZW50cmllczogZW50cmllczIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9waWNrL3BpY2sudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBwaWNrKHNjaGVtYSwga2V5cykge1xuICBjb25zdCBlbnRyaWVzMiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZW50cmllczJba2V5XSA9IHNjaGVtYS5lbnRyaWVzW2tleV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZW50cmllczogZW50cmllczIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9waXBlL3BpcGUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBwaXBlKC4uLnBpcGUyKSB7XG4gIHJldHVybiB7XG4gICAgLi4ucGlwZTJbMF0sXG4gICAgcGlwZTogcGlwZTIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGlwZTIpIHtcbiAgICAgICAgaWYgKGl0ZW0ua2luZCAhPT0gXCJtZXRhZGF0YVwiKSB7XG4gICAgICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzICYmIChpdGVtLmtpbmQgPT09IFwic2NoZW1hXCIgfHwgaXRlbS5raW5kID09PSBcInRyYW5zZm9ybWF0aW9uXCIpKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5ICYmICFjb25maWcyLmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgICAgICBkYXRhc2V0ID0gaXRlbVtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3BpcGUvcGlwZUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGlwZUFzeW5jKC4uLnBpcGUyKSB7XG4gIHJldHVybiB7XG4gICAgLi4ucGlwZTJbMF0sXG4gICAgcGlwZTogcGlwZTIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGlwZTIpIHtcbiAgICAgICAgaWYgKGl0ZW0ua2luZCAhPT0gXCJtZXRhZGF0YVwiKSB7XG4gICAgICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzICYmIChpdGVtLmtpbmQgPT09IFwic2NoZW1hXCIgfHwgaXRlbS5raW5kID09PSBcInRyYW5zZm9ybWF0aW9uXCIpKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5ICYmICFjb25maWcyLmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgICAgICBkYXRhc2V0ID0gYXdhaXQgaXRlbVtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3JlcXVpcmVkL3JlcXVpcmVkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcmVxdWlyZWQoc2NoZW1hLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGFyZzIpID8gYXJnMiA6IHZvaWQgMDtcbiAgY29uc3QgbWVzc2FnZTIgPSBBcnJheS5pc0FycmF5KGFyZzIpID8gYXJnMyA6IGFyZzI7XG4gIGNvbnN0IGVudHJpZXMyID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5lbnRyaWVzKSB7XG4gICAgZW50cmllczJba2V5XSA9ICFrZXlzIHx8IGtleXMuaW5jbHVkZXMoa2V5KSA/IG5vbk9wdGlvbmFsKHNjaGVtYS5lbnRyaWVzW2tleV0sIG1lc3NhZ2UyKSA6IHNjaGVtYS5lbnRyaWVzW2tleV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZW50cmllczogZW50cmllczIsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9yZXF1aXJlZC9yZXF1aXJlZEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcmVxdWlyZWRBc3luYyhzY2hlbWEsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoYXJnMikgPyBhcmcyIDogdm9pZCAwO1xuICBjb25zdCBtZXNzYWdlMiA9IEFycmF5LmlzQXJyYXkoYXJnMikgPyBhcmczIDogYXJnMjtcbiAgY29uc3QgZW50cmllczIgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICBlbnRyaWVzMltrZXldID0gIWtleXMgfHwga2V5cy5pbmNsdWRlcyhrZXkpID8gbm9uT3B0aW9uYWxBc3luYyhzY2hlbWEuZW50cmllc1trZXldLCBtZXNzYWdlMikgOiBzY2hlbWEuZW50cmllc1trZXldO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGVudHJpZXM6IGVudHJpZXMyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlL3NhZmVQYXJzZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNhZmVQYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcyKSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0IH0sIGdldEdsb2JhbENvbmZpZyhjb25maWcyKSk7XG4gIHJldHVybiB7XG4gICAgdHlwZWQ6IGRhdGFzZXQudHlwZWQsXG4gICAgc3VjY2VzczogIWRhdGFzZXQuaXNzdWVzLFxuICAgIG91dHB1dDogZGF0YXNldC52YWx1ZSxcbiAgICBpc3N1ZXM6IGRhdGFzZXQuaXNzdWVzXG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2VBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmFzeW5jIGZ1bmN0aW9uIHNhZmVQYXJzZUFzeW5jKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpIHtcbiAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHNjaGVtYVtcIn5ydW5cIl0oXG4gICAgeyB2YWx1ZTogaW5wdXQgfSxcbiAgICBnZXRHbG9iYWxDb25maWcoY29uZmlnMilcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlZDogZGF0YXNldC50eXBlZCxcbiAgICBzdWNjZXNzOiAhZGF0YXNldC5pc3N1ZXMsXG4gICAgb3V0cHV0OiBkYXRhc2V0LnZhbHVlLFxuICAgIGlzc3VlczogZGF0YXNldC5pc3N1ZXNcbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlci9zYWZlUGFyc2VyLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc2FmZVBhcnNlcihzY2hlbWEsIGNvbmZpZzIpIHtcbiAgY29uc3QgZnVuYyA9IChpbnB1dCkgPT4gc2FmZVBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlci9zYWZlUGFyc2VyQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzYWZlUGFyc2VyQXN5bmMoc2NoZW1hLCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bmMgPSAoaW5wdXQpID0+IHNhZmVQYXJzZUFzeW5jKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvc3VtbWFyaXplL3N1bW1hcml6ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHN1bW1hcml6ZShpc3N1ZXMpIHtcbiAgbGV0IHN1bW1hcnkgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGlzc3VlIG9mIGlzc3Vlcykge1xuICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICBzdW1tYXJ5ICs9IFwiXFxuXCI7XG4gICAgfVxuICAgIHN1bW1hcnkgKz0gYFxceEQ3ICR7aXNzdWUubWVzc2FnZX1gO1xuICAgIGNvbnN0IGRvdFBhdGggPSBnZXREb3RQYXRoKGlzc3VlKTtcbiAgICBpZiAoZG90UGF0aCkge1xuICAgICAgc3VtbWFyeSArPSBgXG4gIFxcdTIxOTIgYXQgJHtkb3RQYXRofWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW1tYXJ5O1xufVxuXG4vLyBzcmMvbWV0aG9kcy91bndyYXAvdW53cmFwLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdW53cmFwKHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hLndyYXBwZWQ7XG59XG5leHBvcnQge1xuICBCQVNFNjRfUkVHRVgsXG4gIEJJQ19SRUdFWCxcbiAgQ1VJRDJfUkVHRVgsXG4gIERFQ0lNQUxfUkVHRVgsXG4gIERJR0lUU19SRUdFWCxcbiAgRU1BSUxfUkVHRVgsXG4gIEVNT0pJX1JFR0VYLFxuICBIRVhBREVDSU1BTF9SRUdFWCxcbiAgSEVYX0NPTE9SX1JFR0VYLFxuICBJTUVJX1JFR0VYLFxuICBJUFY0X1JFR0VYLFxuICBJUFY2X1JFR0VYLFxuICBJUF9SRUdFWCxcbiAgSVNPX0RBVEVfUkVHRVgsXG4gIElTT19EQVRFX1RJTUVfUkVHRVgsXG4gIElTT19USU1FU1RBTVBfUkVHRVgsXG4gIElTT19USU1FX1JFR0VYLFxuICBJU09fVElNRV9TRUNPTkRfUkVHRVgsXG4gIElTT19XRUVLX1JFR0VYLFxuICBNQUM0OF9SRUdFWCxcbiAgTUFDNjRfUkVHRVgsXG4gIE1BQ19SRUdFWCxcbiAgTkFOT19JRF9SRUdFWCxcbiAgT0NUQUxfUkVHRVgsXG4gIFJGQ19FTUFJTF9SRUdFWCxcbiAgU0xVR19SRUdFWCxcbiAgVUxJRF9SRUdFWCxcbiAgVVVJRF9SRUdFWCxcbiAgVmFsaUVycm9yLFxuICBfYWRkSXNzdWUsXG4gIF9nZXRCeXRlQ291bnQsXG4gIF9nZXRHcmFwaGVtZUNvdW50LFxuICBfZ2V0TGFzdE1ldGFkYXRhLFxuICBfZ2V0U3RhbmRhcmRQcm9wcyxcbiAgX2dldFdvcmRDb3VudCxcbiAgX2lzTHVobkFsZ28sXG4gIF9pc1ZhbGlkT2JqZWN0S2V5LFxuICBfam9pbkV4cGVjdHMsXG4gIF9zdHJpbmdpZnksXG4gIGFueSxcbiAgYXJncyxcbiAgYXJnc0FzeW5jLFxuICBhcnJheSxcbiAgYXJyYXlBc3luYyxcbiAgYXNzZXJ0LFxuICBhd2FpdEFzeW5jLFxuICBiYXNlNjQsXG4gIGJpYyxcbiAgYmlnaW50LFxuICBibG9iLFxuICBib29sZWFuLFxuICBicmFuZCxcbiAgYnl0ZXMsXG4gIGNoZWNrLFxuICBjaGVja0FzeW5jLFxuICBjaGVja0l0ZW1zLFxuICBjaGVja0l0ZW1zQXN5bmMsXG4gIGNvbmZpZyxcbiAgY3JlZGl0Q2FyZCxcbiAgY3VpZDIsXG4gIGN1c3RvbSxcbiAgY3VzdG9tQXN5bmMsXG4gIGRhdGUsXG4gIGRlY2ltYWwsXG4gIGRlbGV0ZUdsb2JhbENvbmZpZyxcbiAgZGVsZXRlR2xvYmFsTWVzc2FnZSxcbiAgZGVsZXRlU2NoZW1hTWVzc2FnZSxcbiAgZGVsZXRlU3BlY2lmaWNNZXNzYWdlLFxuICBkZXNjcmlwdGlvbixcbiAgZGlnaXRzLFxuICBlbWFpbCxcbiAgZW1vamksXG4gIGVtcHR5LFxuICBlbmRzV2l0aCxcbiAgZW50cmllcyxcbiAgZW50cmllc0Zyb21MaXN0LFxuICBlbnRyaWVzRnJvbU9iamVjdHMsXG4gIGVudW1fIGFzIGVudW0sXG4gIGVudW1fLFxuICBldmVyeUl0ZW0sXG4gIGV4YWN0T3B0aW9uYWwsXG4gIGV4YWN0T3B0aW9uYWxBc3luYyxcbiAgZXhjbHVkZXMsXG4gIGZhbGxiYWNrLFxuICBmYWxsYmFja0FzeW5jLFxuICBmaWxlLFxuICBmaWx0ZXJJdGVtcyxcbiAgZmluZEl0ZW0sXG4gIGZpbml0ZSxcbiAgZmxhdHRlbixcbiAgZmxhdm9yLFxuICBmb3J3YXJkLFxuICBmb3J3YXJkQXN5bmMsXG4gIGZ1bmN0aW9uXyBhcyBmdW5jdGlvbixcbiAgZnVuY3Rpb25fLFxuICBnZXREZWZhdWx0LFxuICBnZXREZWZhdWx0cyxcbiAgZ2V0RGVmYXVsdHNBc3luYyxcbiAgZ2V0RGVzY3JpcHRpb24sXG4gIGdldERvdFBhdGgsXG4gIGdldEZhbGxiYWNrLFxuICBnZXRGYWxsYmFja3MsXG4gIGdldEZhbGxiYWNrc0FzeW5jLFxuICBnZXRHbG9iYWxDb25maWcsXG4gIGdldEdsb2JhbE1lc3NhZ2UsXG4gIGdldE1ldGFkYXRhLFxuICBnZXRTY2hlbWFNZXNzYWdlLFxuICBnZXRTcGVjaWZpY01lc3NhZ2UsXG4gIGdldFRpdGxlLFxuICBncmFwaGVtZXMsXG4gIGd0VmFsdWUsXG4gIGhhc2gsXG4gIGhleENvbG9yLFxuICBoZXhhZGVjaW1hbCxcbiAgaW1laSxcbiAgaW5jbHVkZXMsXG4gIGluc3RhbmNlLFxuICBpbnRlZ2VyLFxuICBpbnRlcnNlY3QsXG4gIGludGVyc2VjdEFzeW5jLFxuICBpcCxcbiAgaXB2NCxcbiAgaXB2NixcbiAgaXMsXG4gIGlzT2ZLaW5kLFxuICBpc09mVHlwZSxcbiAgaXNWYWxpRXJyb3IsXG4gIGlzb0RhdGUsXG4gIGlzb0RhdGVUaW1lLFxuICBpc29UaW1lLFxuICBpc29UaW1lU2Vjb25kLFxuICBpc29UaW1lc3RhbXAsXG4gIGlzb1dlZWssXG4gIGtleW9mLFxuICBsYXp5LFxuICBsYXp5QXN5bmMsXG4gIGxlbmd0aCxcbiAgbGl0ZXJhbCxcbiAgbG9vc2VPYmplY3QsXG4gIGxvb3NlT2JqZWN0QXN5bmMsXG4gIGxvb3NlVHVwbGUsXG4gIGxvb3NlVHVwbGVBc3luYyxcbiAgbHRWYWx1ZSxcbiAgbWFjLFxuICBtYWM0OCxcbiAgbWFjNjQsXG4gIG1hcCxcbiAgbWFwQXN5bmMsXG4gIG1hcEl0ZW1zLFxuICBtYXhCeXRlcyxcbiAgbWF4RW50cmllcyxcbiAgbWF4R3JhcGhlbWVzLFxuICBtYXhMZW5ndGgsXG4gIG1heFNpemUsXG4gIG1heFZhbHVlLFxuICBtYXhXb3JkcyxcbiAgbWVzc2FnZSxcbiAgbWV0YWRhdGEsXG4gIG1pbWVUeXBlLFxuICBtaW5CeXRlcyxcbiAgbWluRW50cmllcyxcbiAgbWluR3JhcGhlbWVzLFxuICBtaW5MZW5ndGgsXG4gIG1pblNpemUsXG4gIG1pblZhbHVlLFxuICBtaW5Xb3JkcyxcbiAgbXVsdGlwbGVPZixcbiAgbmFuLFxuICBuYW5vaWQsXG4gIG5ldmVyLFxuICBub25FbXB0eSxcbiAgbm9uTnVsbGFibGUsXG4gIG5vbk51bGxhYmxlQXN5bmMsXG4gIG5vbk51bGxpc2gsXG4gIG5vbk51bGxpc2hBc3luYyxcbiAgbm9uT3B0aW9uYWwsXG4gIG5vbk9wdGlvbmFsQXN5bmMsXG4gIG5vcm1hbGl6ZSxcbiAgbm90Qnl0ZXMsXG4gIG5vdEVudHJpZXMsXG4gIG5vdEdyYXBoZW1lcyxcbiAgbm90TGVuZ3RoLFxuICBub3RTaXplLFxuICBub3RWYWx1ZSxcbiAgbm90VmFsdWVzLFxuICBub3RXb3JkcyxcbiAgbnVsbF8gYXMgbnVsbCxcbiAgbnVsbF8sXG4gIG51bGxhYmxlLFxuICBudWxsYWJsZUFzeW5jLFxuICBudWxsaXNoLFxuICBudWxsaXNoQXN5bmMsXG4gIG51bWJlcixcbiAgb2JqZWN0LFxuICBvYmplY3RBc3luYyxcbiAgb2JqZWN0V2l0aFJlc3QsXG4gIG9iamVjdFdpdGhSZXN0QXN5bmMsXG4gIG9jdGFsLFxuICBvbWl0LFxuICBvcHRpb25hbCxcbiAgb3B0aW9uYWxBc3luYyxcbiAgcGFyc2UsXG4gIHBhcnNlQXN5bmMsXG4gIHBhcnNlSnNvbixcbiAgcGFyc2VyLFxuICBwYXJzZXJBc3luYyxcbiAgcGFydGlhbCxcbiAgcGFydGlhbEFzeW5jLFxuICBwYXJ0aWFsQ2hlY2ssXG4gIHBhcnRpYWxDaGVja0FzeW5jLFxuICBwaWNrLFxuICBwaWNrbGlzdCxcbiAgcGlwZSxcbiAgcGlwZUFzeW5jLFxuICBwcm9taXNlLFxuICByYXdDaGVjayxcbiAgcmF3Q2hlY2tBc3luYyxcbiAgcmF3VHJhbnNmb3JtLFxuICByYXdUcmFuc2Zvcm1Bc3luYyxcbiAgcmVhZG9ubHksXG4gIHJlY29yZCxcbiAgcmVjb3JkQXN5bmMsXG4gIHJlZHVjZUl0ZW1zLFxuICByZWdleCxcbiAgcmVxdWlyZWQsXG4gIHJlcXVpcmVkQXN5bmMsXG4gIHJldHVybnMsXG4gIHJldHVybnNBc3luYyxcbiAgcmZjRW1haWwsXG4gIHNhZmVJbnRlZ2VyLFxuICBzYWZlUGFyc2UsXG4gIHNhZmVQYXJzZUFzeW5jLFxuICBzYWZlUGFyc2VyLFxuICBzYWZlUGFyc2VyQXN5bmMsXG4gIHNldCxcbiAgc2V0QXN5bmMsXG4gIHNldEdsb2JhbENvbmZpZyxcbiAgc2V0R2xvYmFsTWVzc2FnZSxcbiAgc2V0U2NoZW1hTWVzc2FnZSxcbiAgc2V0U3BlY2lmaWNNZXNzYWdlLFxuICBzaXplLFxuICBzbHVnLFxuICBzb21lSXRlbSxcbiAgc29ydEl0ZW1zLFxuICBzdGFydHNXaXRoLFxuICBzdHJpY3RPYmplY3QsXG4gIHN0cmljdE9iamVjdEFzeW5jLFxuICBzdHJpY3RUdXBsZSxcbiAgc3RyaWN0VHVwbGVBc3luYyxcbiAgc3RyaW5nLFxuICBzdHJpbmdpZnlKc29uLFxuICBzdW1tYXJpemUsXG4gIHN5bWJvbCxcbiAgdGl0bGUsXG4gIHRvTG93ZXJDYXNlLFxuICB0b01heFZhbHVlLFxuICB0b01pblZhbHVlLFxuICB0b1VwcGVyQ2FzZSxcbiAgdHJhbnNmb3JtLFxuICB0cmFuc2Zvcm1Bc3luYyxcbiAgdHJpbSxcbiAgdHJpbUVuZCxcbiAgdHJpbVN0YXJ0LFxuICB0dXBsZSxcbiAgdHVwbGVBc3luYyxcbiAgdHVwbGVXaXRoUmVzdCxcbiAgdHVwbGVXaXRoUmVzdEFzeW5jLFxuICB1bGlkLFxuICB1bmRlZmluZWRfIGFzIHVuZGVmaW5lZCxcbiAgdW5kZWZpbmVkXyxcbiAgdW5kZWZpbmVkYWJsZSxcbiAgdW5kZWZpbmVkYWJsZUFzeW5jLFxuICB1bmlvbixcbiAgdW5pb25Bc3luYyxcbiAgdW5rbm93bixcbiAgdW53cmFwLFxuICB1cmwsXG4gIHV1aWQsXG4gIHZhbHVlLFxuICB2YWx1ZXMsXG4gIHZhcmlhbnQsXG4gIHZhcmlhbnRBc3luYyxcbiAgdm9pZF8gYXMgdm9pZCxcbiAgdm9pZF8sXG4gIHdvcmRzXG59O1xuIl0sIm5hbWVzIjpbInN0b3JlIiwic2V0R2xvYmFsQ29uZmlnIiwiY29uZmlnMiIsImdldEdsb2JhbENvbmZpZyIsImxhbmciLCJtZXNzYWdlIiwiYWJvcnRFYXJseSIsImFib3J0UGlwZUVhcmx5IiwiZGVsZXRlR2xvYmFsQ29uZmlnIiwic3RvcmUyIiwic2V0R2xvYmFsTWVzc2FnZSIsIm1lc3NhZ2UyIiwiTWFwIiwic2V0IiwiZ2V0R2xvYmFsTWVzc2FnZSIsImdldCIsImRlbGV0ZUdsb2JhbE1lc3NhZ2UiLCJkZWxldGUiLCJzdG9yZTMiLCJzZXRTY2hlbWFNZXNzYWdlIiwiZ2V0U2NoZW1hTWVzc2FnZSIsImRlbGV0ZVNjaGVtYU1lc3NhZ2UiLCJzdG9yZTQiLCJzZXRTcGVjaWZpY01lc3NhZ2UiLCJyZWZlcmVuY2UiLCJnZXRTcGVjaWZpY01lc3NhZ2UiLCJkZWxldGVTcGVjaWZpY01lc3NhZ2UiLCJfc3RyaW5naWZ5IiwiaW5wdXQiLCJ0eXBlIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJfYWRkSXNzdWUiLCJjb250ZXh0IiwibGFiZWwiLCJkYXRhc2V0Iiwib3RoZXIiLCJ2YWx1ZSIsImV4cGVjdGVkIiwiZXhwZWN0cyIsInJlY2VpdmVkIiwiaXNzdWUiLCJraW5kIiwicmVxdWlyZW1lbnQiLCJwYXRoIiwiaXNzdWVzIiwiaXNTY2hlbWEiLCJ0eXBlZCIsInB1c2giLCJ0ZXh0RW5jb2RlciIsIl9nZXRCeXRlQ291bnQiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImxlbmd0aCIsInNlZ21lbnRlciIsIl9nZXRHcmFwaGVtZUNvdW50IiwiSW50bCIsIlNlZ21lbnRlciIsInNlZ21lbnRzIiwic2VnbWVudCIsImNvdW50IiwiXyIsIl9nZXRMYXN0TWV0YWRhdGEiLCJzY2hlbWEiLCJuZXN0ZWRTY2hlbWFzIiwiaW5kZXgiLCJwaXBlIiwiaXRlbSIsIm5lc3RlZFNjaGVtYSIsInJlc3VsdCIsIl9nZXRTdGFuZGFyZFByb3BzIiwidmVyc2lvbiIsInZlbmRvciIsInZhbGlkYXRlIiwidmFsdWUyIiwic3RvcmU1IiwiX2dldFdvcmRDb3VudCIsImxvY2FsZXMiLCJncmFudWxhcml0eSIsImlzV29yZExpa2UiLCJOT05fRElHSVRfUkVHRVgiLCJfaXNMdWhuQWxnbyIsIm51bWJlcjIiLCJyZXBsYWNlIiwibGVuZ3RoMiIsImJpdCIsInN1bSIsIl9pc1ZhbGlkT2JqZWN0S2V5Iiwib2JqZWN0MiIsImtleSIsImhhc093biIsIl9qb2luRXhwZWN0cyIsInZhbHVlczIiLCJzZXBhcmF0b3IiLCJsaXN0IiwiU2V0Iiwiam9pbiIsImVudHJpZXNGcm9tTGlzdCIsImVudHJpZXMyIiwiZW50cmllc0Zyb21PYmplY3RzIiwic2NoZW1hcyIsImFzc2lnbiIsImVudHJpZXMiLCJnZXREb3RQYXRoIiwiaXNPZktpbmQiLCJpc09mVHlwZSIsImlzVmFsaUVycm9yIiwiZXJyb3IiLCJWYWxpRXJyb3IiLCJFcnJvciIsImFyZ3MiLCJhc3luYyIsImZ1bmMiLCJhcmdzXyIsImFyZ3NEYXRhc2V0IiwiYXJnc0FzeW5jIiwiYXJnczIiLCJhd2FpdEFzeW5jIiwiQkFTRTY0X1JFR0VYIiwiQklDX1JFR0VYIiwiQ1VJRDJfUkVHRVgiLCJERUNJTUFMX1JFR0VYIiwiRElHSVRTX1JFR0VYIiwiRU1BSUxfUkVHRVgiLCJFTU9KSV9SRUdFWCIsIkhFWEFERUNJTUFMX1JFR0VYIiwiSEVYX0NPTE9SX1JFR0VYIiwiSU1FSV9SRUdFWCIsIklQVjRfUkVHRVgiLCJJUFY2X1JFR0VYIiwiSVBfUkVHRVgiLCJJU09fREFURV9SRUdFWCIsIklTT19EQVRFX1RJTUVfUkVHRVgiLCJJU09fVElNRV9SRUdFWCIsIklTT19USU1FX1NFQ09ORF9SRUdFWCIsIklTT19USU1FU1RBTVBfUkVHRVgiLCJJU09fV0VFS19SRUdFWCIsIk1BQzQ4X1JFR0VYIiwiTUFDNjRfUkVHRVgiLCJNQUNfUkVHRVgiLCJOQU5PX0lEX1JFR0VYIiwiT0NUQUxfUkVHRVgiLCJSRkNfRU1BSUxfUkVHRVgiLCJTTFVHX1JFR0VYIiwiVUxJRF9SRUdFWCIsIlVVSURfUkVHRVgiLCJiYXNlNjQiLCJ0ZXN0IiwiYmljIiwiYnJhbmQiLCJieXRlcyIsImNoZWNrIiwiY2hlY2tBc3luYyIsImNoZWNrSXRlbXMiLCJvcmlnaW4iLCJjaGVja0l0ZW1zQXN5bmMiLCJyZXF1aXJlbWVudFJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiQ1JFRElUX0NBUkRfUkVHRVgiLCJTQU5JVElaRV9SRUdFWCIsIlBST1ZJREVSX1JFR0VYX0xJU1QiLCJjcmVkaXRDYXJkIiwic2FuaXRpemVkIiwic29tZSIsInJlZ2V4MiIsImN1aWQyIiwiZGVjaW1hbCIsImRlc2NyaXB0aW9uIiwiZGVzY3JpcHRpb25fIiwiZGlnaXRzIiwiZW1haWwiLCJlbW9qaSIsImVtcHR5IiwiZW5kc1dpdGgiLCJzbGljZSIsImtleXMiLCJldmVyeUl0ZW0iLCJldmVyeSIsImV4Y2x1ZGVzIiwiaW5jbHVkZXMiLCJmaWx0ZXJJdGVtcyIsIm9wZXJhdGlvbiIsImZpbHRlciIsImZpbmRJdGVtIiwiZmluZCIsImZpbml0ZSIsIk51bWJlciIsImlzRmluaXRlIiwiZmxhdm9yIiwiZ3JhcGhlbWVzIiwiZ3RWYWx1ZSIsIkRhdGUiLCJ0b0pTT04iLCJIQVNIX0xFTkdUSFMiLCJtZDQiLCJtZDUiLCJzaGExIiwic2hhMjU2Iiwic2hhMzg0Iiwic2hhNTEyIiwicmlwZW1kMTI4IiwicmlwZW1kMTYwIiwidGlnZXIxMjgiLCJ0aWdlcjE2MCIsInRpZ2VyMTkyIiwiY3JjMzIiLCJjcmMzMmIiLCJhZGxlcjMyIiwiaGFzaCIsInR5cGVzIiwiUmVnRXhwIiwiaGV4YWRlY2ltYWwiLCJoZXhDb2xvciIsImltZWkiLCJpbnRlZ2VyIiwiaXNJbnRlZ2VyIiwiaXAiLCJpcHY0IiwiaXB2NiIsImlzb0RhdGUiLCJpc29EYXRlVGltZSIsImlzb1RpbWUiLCJpc29UaW1lU2Vjb25kIiwiaXNvVGltZXN0YW1wIiwiaXNvV2VlayIsImx0VmFsdWUiLCJtYWMiLCJtYWM0OCIsIm1hYzY0IiwibWFwSXRlbXMiLCJtYXhCeXRlcyIsIm1heEVudHJpZXMiLCJtYXhHcmFwaGVtZXMiLCJtYXhMZW5ndGgiLCJtYXhTaXplIiwic2l6ZSIsIm1heFZhbHVlIiwibWF4V29yZHMiLCJtZXRhZGF0YSIsIm1ldGFkYXRhXyIsIm1pbWVUeXBlIiwib3B0aW9uIiwibWluQnl0ZXMiLCJtaW5FbnRyaWVzIiwibWluR3JhcGhlbWVzIiwibWluTGVuZ3RoIiwibWluU2l6ZSIsIm1pblZhbHVlIiwibWluV29yZHMiLCJtdWx0aXBsZU9mIiwibmFub2lkIiwibm9uRW1wdHkiLCJub3JtYWxpemUiLCJmb3JtIiwibm90Qnl0ZXMiLCJub3RFbnRyaWVzIiwibm90R3JhcGhlbWVzIiwibm90TGVuZ3RoIiwibm90U2l6ZSIsIm5vdFZhbHVlIiwibm90VmFsdWVzIiwibm90V29yZHMiLCJvY3RhbCIsInBhcnNlSnNvbiIsImNvbmZpZyIsImNvbmZpZzMiLCJKU09OIiwicGFyc2UiLCJyZXZpdmVyIiwiX2lzUGFydGlhbGx5VHlwZWQiLCJwYXRocyIsImJvdW5kIiwiTWF0aCIsIm1pbiIsInBhcnRpYWxDaGVjayIsInBhcnRpYWxDaGVja0FzeW5jIiwicmF3Q2hlY2siLCJhY3Rpb24iLCJhZGRJc3N1ZSIsImluZm8iLCJyYXdDaGVja0FzeW5jIiwicmF3VHJhbnNmb3JtIiwib3V0cHV0IiwiTkVWRVIiLCJyYXdUcmFuc2Zvcm1Bc3luYyIsInJlYWRvbmx5IiwicmVkdWNlSXRlbXMiLCJpbml0aWFsIiwicmVkdWNlIiwicmVnZXgiLCJyZXR1cm5zIiwicmV0dXJuc0RhdGFzZXQiLCJyZXR1cm5zQXN5bmMiLCJyZmNFbWFpbCIsInNhZmVJbnRlZ2VyIiwiaXNTYWZlSW50ZWdlciIsInNsdWciLCJzb21lSXRlbSIsInNvcnRJdGVtcyIsInNvcnQiLCJzdGFydHNXaXRoIiwic3RyaW5naWZ5SnNvbiIsInN0cmluZ2lmeSIsInJlcGxhY2VyIiwic3BhY2UiLCJ0aXRsZSIsInRpdGxlXyIsInRvTG93ZXJDYXNlIiwidG9NYXhWYWx1ZSIsInRvTWluVmFsdWUiLCJ0b1VwcGVyQ2FzZSIsInRyYW5zZm9ybSIsInRyYW5zZm9ybUFzeW5jIiwidHJpbSIsInRyaW1FbmQiLCJ0cmltU3RhcnQiLCJ1bGlkIiwidXJsIiwiVVJMIiwidXVpZCIsInZhbHVlcyIsIndvcmRzIiwiYXNzZXJ0IiwiY29uZmlnXyIsImdldEZhbGxiYWNrIiwiZmFsbGJhY2siLCJmYWxsYmFjazIiLCJvdXRwdXREYXRhc2V0IiwiZmFsbGJhY2tBc3luYyIsImZsYXR0ZW4iLCJmbGF0RXJyb3JzIiwiZG90UGF0aCIsIm5lc3RlZCIsInJvb3QiLCJmb3J3YXJkIiwicHJldklzc3VlcyIsInBhdGhJbnB1dCIsInBhdGhWYWx1ZSIsInBhdGhJdGVtIiwiZm9yd2FyZEFzeW5jIiwiZ2V0RGVmYXVsdCIsImRlZmF1bHQiLCJnZXREZWZhdWx0cyIsIml0ZW1zIiwiZ2V0RGVmYXVsdHNBc3luYyIsImZyb21FbnRyaWVzIiwiZ2V0RGVzY3JpcHRpb24iLCJnZXRGYWxsYmFja3MiLCJnZXRGYWxsYmFja3NBc3luYyIsImdldE1ldGFkYXRhIiwiZGVwdGhGaXJzdE1lcmdlIiwic2NoZW1hMiIsImdldFRpdGxlIiwiaXMiLCJhbnkiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW1EYXRhc2V0IiwidW5zaGlmdCIsImFycmF5QXN5bmMiLCJpdGVtRGF0YXNldHMiLCJiaWdpbnQiLCJibG9iIiwiQmxvYiIsImJvb2xlYW4iLCJjdXN0b20iLCJjaGVjazIiLCJjdXN0b21Bc3luYyIsImRhdGUiLCJpc05hTiIsImVudW1fIiwiZW51bV9fIiwib3B0aW9ucyIsImVudW0iLCJleGFjdE9wdGlvbmFsIiwid3JhcHBlZCIsImRlZmF1bHRfIiwiZXhhY3RPcHRpb25hbEFzeW5jIiwiZmlsZSIsIkZpbGUiLCJmdW5jdGlvbl8iLCJpbnN0YW5jZSIsImNsYXNzXyIsImNsYXNzIiwiX21lcmdlIiwidmFsdWUxIiwiaW50ZXJzZWN0Iiwib3V0cHV0cyIsIm9wdGlvbkRhdGFzZXQiLCJtZXJnZURhdGFzZXQiLCJpbnRlcnNlY3RBc3luYyIsIm9wdGlvbkRhdGFzZXRzIiwibGF6eSIsImdldHRlciIsImxhenlBc3luYyIsImxpdGVyYWwiLCJsaXRlcmFsXyIsImxvb3NlT2JqZWN0IiwidmFsdWVTY2hlbWEiLCJ2YWx1ZURhdGFzZXQiLCJsb29zZU9iamVjdEFzeW5jIiwidmFsdWVEYXRhc2V0cyIsImxvb3NlVHVwbGUiLCJsb29zZVR1cGxlQXN5bmMiLCJpbnB1dEtleSIsImlucHV0VmFsdWUiLCJrZXlEYXRhc2V0IiwibWFwQXN5bmMiLCJkYXRhc2V0cyIsIm5hbiIsIm5ldmVyIiwibm9uTnVsbGFibGUiLCJub25OdWxsYWJsZUFzeW5jIiwibm9uTnVsbGlzaCIsIm5vbk51bGxpc2hBc3luYyIsIm5vbk9wdGlvbmFsIiwibm9uT3B0aW9uYWxBc3luYyIsIm51bGxfIiwibnVsbGFibGUiLCJudWxsYWJsZUFzeW5jIiwibnVsbGlzaCIsIm51bGxpc2hBc3luYyIsIm51bWJlciIsIm9iamVjdCIsIm9iamVjdEFzeW5jIiwib2JqZWN0V2l0aFJlc3QiLCJyZXN0Iiwib2JqZWN0V2l0aFJlc3RBc3luYyIsIm5vcm1hbERhdGFzZXRzIiwicmVzdERhdGFzZXRzIiwib3B0aW9uYWwiLCJvcHRpb25hbEFzeW5jIiwicGlja2xpc3QiLCJwcm9taXNlIiwicmVjb3JkIiwiZW50cnlLZXkiLCJlbnRyeVZhbHVlIiwicmVjb3JkQXN5bmMiLCJrZXkyIiwiYWRkIiwic2V0QXN5bmMiLCJzdHJpY3RPYmplY3QiLCJzdHJpY3RPYmplY3RBc3luYyIsInN0cmljdFR1cGxlIiwic3RyaWN0VHVwbGVBc3luYyIsInN0cmluZyIsInN5bWJvbCIsInR1cGxlIiwidHVwbGVBc3luYyIsInR1cGxlV2l0aFJlc3QiLCJ0dXBsZVdpdGhSZXN0QXN5bmMiLCJ1bmRlZmluZWRfIiwidW5kZWZpbmVkYWJsZSIsInVuZGVmaW5lZGFibGVBc3luYyIsIl9zdWJJc3N1ZXMiLCJ1bmlvbiIsInZhbGlkRGF0YXNldCIsInR5cGVkRGF0YXNldHMiLCJ1bnR5cGVkRGF0YXNldHMiLCJ1bmlvbkFzeW5jIiwidW5rbm93biIsInZhcmlhbnQiLCJtYXhEaXNjcmltaW5hdG9yUHJpb3JpdHkiLCJpbnZhbGlkRGlzY3JpbWluYXRvcktleSIsImV4cGVjdGVkRGlzY3JpbWluYXRvcnMiLCJwYXJzZU9wdGlvbnMiLCJ2YXJpYW50MiIsImFsbEtleXMiLCJrZXlzQXJlVmFsaWQiLCJjdXJyZW50UHJpb3JpdHkiLCJjdXJyZW50S2V5IiwiZGlzY3JpbWluYXRvclNjaGVtYSIsInZhcmlhbnRBc3luYyIsInZvaWRfIiwia2V5b2YiLCJtZXNzYWdlXyIsIm9taXQiLCJwYXJzZUFzeW5jIiwicGFyc2VyIiwicGFyc2VyQXN5bmMiLCJwYXJ0aWFsIiwicGFydGlhbEFzeW5jIiwicGljayIsInBpcGUyIiwicGlwZUFzeW5jIiwicmVxdWlyZWQiLCJhcmcyIiwiYXJnMyIsInJlcXVpcmVkQXN5bmMiLCJzYWZlUGFyc2UiLCJzdWNjZXNzIiwic2FmZVBhcnNlQXN5bmMiLCJzYWZlUGFyc2VyIiwic2FmZVBhcnNlckFzeW5jIiwic3VtbWFyaXplIiwic3VtbWFyeSIsInVud3JhcCIsImZ1bmN0aW9uIiwibnVsbCIsInVuZGVmaW5lZCIsInZvaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valibot/dist/index.js\n");

/***/ })

};
;